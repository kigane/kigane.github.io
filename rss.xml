<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://kigane.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Leonhardt's Blog</title>
    <link>https://kigane.github.io/</link>
    <description>想，都是问题。做，才是答案。</description>
    <language>en-US</language>
    <pubDate>Mon, 13 Dec 2021 15:51:33 GMT</pubDate>
    <lastBuildDate>Mon, 13 Dec 2021 15:51:33 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by Leonhardt</copyright>
    <category>C/C++</category>
    <category>python</category>
    <category>blog</category>
    <category>使用指南</category>
    <category>guide</category>
    <category>CV</category>
    <category>thesis</category>
    <category>Thesis</category>
    <item>
      <title>我的博客</title>
      <link>https://kigane.github.io/blog/</link>
      <guid>https://kigane.github.io/blog/</guid>
      <source url="https://kigane.github.io/rss.xml">我的博客</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="名言警句"> 名言警句</h2>
<blockquote>
<p>不积跬步无以至千里</p>
</blockquote>
<blockquote>
<p>Keep It Simple, Stupid.</p>
</blockquote>
<blockquote>
<p>快速推进，逐步优化</p>
</blockquote>
<blockquote>
<p>Make it work. Make it right. Make it fast.</p>
</blockquote>
<blockquote>
<p>前途很远，也很暗。
然而不要怕，不怕的人的面前才有路。</p>
</blockquote>
<blockquote>
<p>I want to create a collection of games during my career, so that when I am on my deathbed I can look back and see that I created all these wonderful things that brought people joy.</p>
</blockquote>
<blockquote>
<p>Less interests, more interest.</p>
</blockquote>
<blockquote>
<p>想，都是问题。做，才是答案。</p>
</blockquote>
<blockquote>
<p>形而上者谓之道，形而下者谓之器，能舍器而直接近道者，几稀！</p>
</blockquote>
<blockquote>
<p>比较的关键不在于相似特征的多少，而在于特征是不是揭示了事物的本质</p>
</blockquote>
<blockquote>
<p>Experience is what you get when you didn't get what you wanted.</p>
</blockquote>
<blockquote>
<p>&quot;luck&quot; is where preparation meets opportunity.</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>游戏引擎总览</title>
      <link>https://kigane.github.io/blog/game-engine-overview/</link>
      <guid>https://kigane.github.io/blog/game-engine-overview/</guid>
      <source url="https://kigane.github.io/rss.xml">游戏引擎总览</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="典型的游戏团队结构"> 典型的游戏团队结构</h2>
<ul>
<li>engineers
<ul>
<li>runtime programmer: engine&amp;game</li>
<li>tools programmer: offline tools for whole team</li>
</ul>
</li>
<li>artists
<ul>
<li>Concept artists: 概念设计</li>
<li>3D modelers: 建模师
<ul>
<li>foreground modelers: 人物，武器，交通工具等</li>
<li>background modelers: 静态背景几何体，如高楼，桥等</li>
</ul>
</li>
<li>Texture artists: 纹理艺术家</li>
<li>Lighting artists: 光照艺术家，调整光照以最大化艺术和情感上的冲击</li>
<li>Animators: 动画师</li>
<li>Motion capture actors: 动捕演员，提供粗略的运动数据供动画师整理和调整</li>
<li>Sound designers: 将音效和音乐混入游戏</li>
<li>Voice actors: 角色声优</li>
<li>composers: 作曲家，负责配乐</li>
</ul>
</li>
<li>game designers: gameplay 设计师，负责用户体验部分
<ul>
<li>宏观层面： 故事走向，人物和关卡的安排，玩家的宏观的目标和终点</li>
<li>微观层面： 场景设计，关卡设计，谜题设计</li>
<li>writers: 编剧</li>
</ul>
</li>
<li>producers: 在不同工作室中的职能不尽相同
<ul>
<li>有些负责日程安排和人力资源管理</li>
<li>有些负责游戏设计</li>
<li>也可能会负责团队之间(如开发部门和商业部门)的联系</li>
<li>小工作室可能不需要</li>
</ul>
</li>
<li>management&amp;support staff
<ul>
<li>执行管理</li>
<li>市场</li>
<li>行政</li>
<li>IT</li>
</ul>
</li>
<li>Publisher and Studio
<ul>
<li>发行商：负责游戏的营销，生产和发行，如EA,Nitendo, Sony等</li>
<li>游戏工作室
<ul>
<li>独立的，不依附于发行商，做好游戏后交给发行商发行，价格详谈。</li>
<li>依附于发行商的</li>
<li>第一方的：为特定平台开发游戏，如Naughty Dog 是 Sony 的第一方工作室。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="什么是游戏"> 什么是游戏？</h2>
<p>Koster断言，游戏“乐趣”的核心在于“学习(learning)”和“掌握(mastering)”,就像笑话只有在你“懂了(get-it)”的时候才有趣。</p>
<h3 id="soft-real-time-interactive-agent-based-computer-simulations"> soft real-time interactive agent-based computer simulations.</h3>
<ul>
<li>simulations: 对现实世界(即使是想象中的现实)的近似和简化。</li>
<li>agent-based: 有大量不同的实体(entity/agent)交互</li>
<li>interactive -- interactive temporal simulations: 交互式时间模拟。游戏状态随着时间的变化而不断改变，并对无法预测的输入作出响应。</li>
<li>real-time: 所有实时系统的核心都是&quot;deadline&quot;。例如
<ul>
<li>大多数游戏渲染的帧率为30/60帧每秒。(NTSC指定的显示器刷新率为29.97帧每秒)</li>
<li>电影的帧率至少为24帧每秒。(使用3:2 pulldown，即让两个电影帧，一帧占3个视频帧，另一帧占2个视频帧)</li>
<li>物理模拟要保持稳定，一秒要计算120次。</li>
<li>角色AI至少一秒运行一次</li>
<li>音频也要每1/60 s调用一次以保持audio buffer充满，防止听觉故障。</li>
</ul>
</li>
<li>soft: 表示即使错过了deadline也不会带来灾难性的后果。与之相反的是hard real-time system ，如直升机的航空电子系统，核电站的控制杆系统。一旦错过deadline，操作者可能会死。</li>
</ul>
<h3 id="游戏中的数学模型"> 游戏中的数学模型</h3>
<p>分析型：有闭式公式。可以求得任意时刻的状态。只能解决一小部分问题。<br>
数值型：通过不断求导等方法，估计离散点的数值。</p>
<p>通常在一个游戏循环中，每次迭代都有机会进行物理系统，AI，游戏逻辑的计算，最后根据计算结果进行渲染。</p>
<h2 id="什么是游戏引擎"> 什么是游戏引擎？</h2>
<p><img src="/assets/img/game-engine-reusability-gamut.png" alt="&quot;game-engine-reusability-gamut&quot;" /></p>
<p>游戏引擎与游戏的区别在于数据驱动的架构。固定的部分越多，就越难修改为其他的游戏。就越接近游戏而非游戏引擎。
另外，一个游戏引擎或中间件越泛用，对于特定的游戏或平台，其最优性就越低。这很容易理解，每个软件在设计的时候都需要权衡(trade-off)，权衡的基准就是软件将会如何被使用或将在哪个平台运行。
即使现在游戏引擎越来越强大，一般性与最优性的权衡仍然存在。所以顶尖的游戏工作室都会使用自研引擎。</p>
<h2 id="不同类型游戏的游戏引擎的区别"> 不同类型游戏的游戏引擎的区别</h2>
<h3 id="fps"> FPS</h3>
<p>通常FPS游戏目标是给玩家沉浸在充满细节，高度写实的世界中的感觉。是所有游戏类型中技术挑战最大的。毫不意外的是，游戏行业的大型技术创新都是出于FPS游戏。</p>
<p>FPS游戏需要的典型技术有</p>
<ul>
<li>高效渲染大型3D虚拟世界</li>
<li>响应式的镜头控制和瞄准机制</li>
<li>高保真的人物肢体动画和武器动画</li>
<li>大量可持有的武器</li>
<li>人物移动和碰撞模型(可能会产生漂浮感)</li>
<li>NPC的AI和动画</li>
<li>小规模多人对战，死亡竞技模式</li>
</ul>
<p>FPS游戏中的渲染技术需要高度优化且根据所处环境仔细调整。例如室内和室外环境，渲染技术大不相同，室外渲染优化通常需要遮挡剔除，离线游戏世界区域化(即手动或自动指定从源区域可以看到哪些目标区域)。</p>
<p>当然，为了沉浸感，需要的远不止高质量的图像优化技术，角色动画，音效，音乐，刚体物理，游戏运镜等等都要使用非常前沿的技术。</p>
<h3 id="平台游戏和其他第三人称游戏"> 平台游戏和其他第三人称游戏</h3>
<p>与FPS相比，更重视人物整体的动画，而非漂浮的手(洗手液战神Eason🤣)。主角也通常是更偏卡通风格，分辨率不用太高类人型角色，有丰富的动作和动画。</p>
<p>需要的典型技术有</p>
<ul>
<li>移动的平台，梯子，绳子，齿轮和其他有趣的移动方式</li>
<li>带有谜题性质的环境元素</li>
<li>相机跟随玩家，且视角可变</li>
<li>复杂的相机碰撞系统，保证视点不会卡进背景几何体或动态前景物体。</li>
</ul>
<h3 id="格斗游戏"> 格斗游戏</h3>
<p>技术要点</p>
<ul>
<li>丰富的战斗动画</li>
<li>精确的击打检测(hit detection)</li>
<li>检测用户输入的复杂按键</li>
<li>相对静态的背景人群</li>
</ul>
<p>可以用到更高技术水平的特色有</p>
<ul>
<li>高清人物</li>
<li>真实的皮肤渲染，表面散射和流汗效果</li>
<li>photo-realistic lighting 和粒子效果</li>
<li>高保真角色动画</li>
<li>基于物理的衣服效果，头发模拟</li>
</ul>
<h3 id="竞速游戏"> 竞速游戏</h3>
<p>典型技术</p>
<ul>
<li>大量用于处理远景的&quot;技巧&quot;，如用远处的山，树用二维卡片代替</li>
<li>赛道通常会分解为二维的区域(sector)以帮助决定可见区域和AI的自动寻路</li>
<li>相机通常处在载具后或驾驶座</li>
<li>当赛道进入非常狭小的空间时，需要作出很大的努力来保证相机不与背景几何体碰撞</li>
</ul>
<h3 id="策略游戏"> 策略游戏</h3>
<p>通常视角固定，对与渲染优化是个好消息。世界通常是基于网格构建的。</p>
<p>典型技术</p>
<ul>
<li>同屏可显示大量单位，从而分辨率会相当低</li>
<li>游戏设计和游玩的画布通常是Height-field terrain 😕</li>
<li>玩家通常可以在领土中建造建筑和军队</li>
<li>单位的选取方式要多样</li>
</ul>
<h3 id="mmog"> MMOG</h3>
<p>服务器。</p>
<h3 id="virtualreality-augumentedr-mixedr"> VirtualReality,AugumentedR,MixedR</h3>
<p>VR的难点</p>
<ul>
<li>立体渲染，同一帧画面要渲染两次(左右眼)</li>
<li>需要高帧率，至少90帧，否则会引发人体不适</li>
<li>导航问题，在虚拟现实世界中如何移动？原地踏步？WSAD？手柄？</li>
</ul>
<p>其他略</p>
<h2 id="有名的游戏引擎"> 有名的游戏引擎</h2>
<p>Quake/Quake2
<a href="https://github.com/id-Software/Quake-2" target="_blank" rel="noopener noreferrer">Quake2 源码</a><br>
架构合理且干净，但可能有点过时，且几乎是用纯C语言写的。
如果有Quake2游戏，非常推荐下载源码来跑跑，设置断点来分析引擎如何工作。</p>
<p>Unreal Engine
开放，开源。不多说。</p>
<p>Source Engine
Half-Life系列使用的引擎。</p>
<p>DICE的Frostbite引擎
质量效应，星球大战：前线2，龙腾世纪，极品飞车(Need for Speed)系列</p>
<p>Rockstar Advanced Game Engine(RAGE)
给他爱系列。荒野大镖客系列。</p>
<p>CryEngine
Far Cry等</p>
<p>Sony的PhyreEngine</p>
<p>微软的 XNA Game Studio，2014年没了</p>
<p>Unity
Unity的设计初衷是简化开发和跨平台。
代表作杀出重围，空洞骑士，茶杯头。</p>
<h2 id="开源引擎列表"> 开源引擎列表</h2>
<ul>
<li><a href="https://github.com/id-Software/Quake-2" target="_blank" rel="noopener noreferrer">Quake2</a></li>
<li><a href="https://www.ogre3d.org/" target="_blank" rel="noopener noreferrer">OGRE 一个架构好，易学易用的3D渲染引擎</a></li>
<li><a href="https://www.panda3d.org/" target="_blank" rel="noopener noreferrer">Panda3D a script-based engine，设计用于快速方便的制作3D游戏原型和虚拟世界</a></li>
<li>Crystal Space is a game engine with an extensible modular architecture.</li>
</ul>
<h2 id="运行时引擎架构"> 运行时引擎架构</h2>
<p>游戏引擎是个巨大的软件系统。通常是一层层(layers)构建的，且上层依赖于下层。</p>
<p><img src="/assets/img/game-engine-archtecture.png" alt="game-engine-archtecture" /></p>
<h3 id="目标硬件"> 目标硬件</h3>
<p>Windows,Linux,MacOS-PC，移动平台，PSV，PS4，PS5，Switch，Wii，NDS，XBOX等等。</p>
<h3 id="设备驱动"> 设备驱动</h3>
<p>管理硬件资源并为操作系统和引擎上层屏蔽无数的硬件设备细节。</p>
<h3 id="操作系统"> 操作系统</h3>
<p>操作系统上通常运行着多个程序(分时抢占式多任务)，这意味着PC游戏永远无法假设它能完全控制硬件，故必须保证它能与系统中的其他程序一起“play nice”。
现在的游戏机上也有操作系统了。开发逐渐趋近于PC。</p>
<h3 id="第三方sdk-software-development-kits-和中间件-middleware"> 第三方SDK(software development kits)和中间件(Middleware)</h3>
<p>大多数引擎都利用了大量第三方SDK和中间件，SDK提供的功能或类接口经常被叫做API。</p>
<h4 id="数据结构和算法"> 数据结构和算法</h4>
<p>任何软件的开发都离不开容器和算法。常用的第三方库有</p>
<ul>
<li><a href="https://www.boost.org/" target="_blank" rel="noopener noreferrer">Boost</a></li>
<li>Folly:扩展C++标准库和Boost，注重最大化代码性能</li>
<li>Loki：强大的泛型模板编程库</li>
</ul>
<h4 id="图形"> 图形</h4>
<ul>
<li>OpenGL</li>
<li>DirectX</li>
<li>Vulkan</li>
<li>libgcm</li>
<li>...</li>
</ul>
<h4 id="碰撞和物理"> 碰撞和物理</h4>
<ul>
<li>Havok</li>
<li>PhysX</li>
<li>ODE(Open Dynamic Engine)</li>
</ul>
<h4 id="角色动画"> 角色动画</h4>
<ul>
<li>Granny：作者认为设计最好，API也最符合逻辑的库。处理速度也快。</li>
<li>Havok Animation</li>
<li>OrbisAnim</li>
<li>Endorphin and Euphoria:使用真实的人类移动生物力学模型来模拟人物移动</li>
</ul>
<h3 id="平台无关层"> 平台无关层</h3>
<p>将更底层的API封装一层成为你的游戏引擎更上层使用的API。以屏蔽平台底层的差异。另外，以后要将某个功能的实现库换了，如物理/碰撞检测的库，上层的代码也不用动。</p>
<h3 id="核心系统"> 核心系统</h3>
<p>游戏引擎是一个巨大且复杂的C++应用，需要一系列有用的软件工具，我们将其分类为核心系统(core system)。</p>
<p>典型的核心系统层见架构图。</p>
<p>核心系统层通常提供的工具，例如</p>
<ul>
<li>断言(Assertion)：用于检查代码的逻辑错误和违反程序员意图的行为。通常不会出现在最终的游戏产品中。</li>
<li>内存管理(Memeory management)：几乎每个游戏引擎都会实现自身的内存分配系统以保证高速内存分配和限制内存碎片的副作用。</li>
<li>数学库：通常需要提供高效的向量和矩阵运算，四元数旋转，三角学，直线的集合操作，光线，球体等，齿轮操作(spline manipulation)，数值计算，解方程组等等。</li>
<li>自定义数据结构和算法：主要是为了最小化或消除动态内存分配并保证在目标平台上的最优运行时性能。</li>
</ul>
<h3 id="资源管理器"> 资源管理器</h3>
<p>为获取所有类型的游戏资源(game assets)和游戏入数据提供统一的接口。有些引擎以高度中心化和一致的方式管理资源，如Unreal的package，OGRE和ResourceManager类。其他一些引擎采取一种临时的方式 ，将资源的处理留给游戏程序员，让程序员可以直接访问硬盘上的原文件或压缩包中的文件，如Quake的PAK文件。典型结构见架构图。</p>
<h3 id="渲染引擎"> 渲染引擎</h3>
<p>游戏引擎中最大，最复杂的组件。渲染器的架构方法多种多样，且目前没有统一的标准。</p>
<h4 id="底层渲染器-low-level-renderer"> 底层渲染器(low-level renderer)</h4>
<p>包含所有引擎的所有原始渲染能力。在这一层，设计目标主要是尽可能快地渲染一系列几何图元，不考虑其在场景中是否可见。这个组件可以细分为大量子组件，例如</p>
<ul>
<li>图形设备接口(Graphics Device Interface):图形SDK，如DirectX，OpenGL，Vulkan等的使用都需要大量的代码，包括初始化，资源获取和绑定等等。典型的用于处理这些的组件称为GDI(每个引擎的术语可能不同)。</li>
<li>其他：光照，纹理，视口，几何图元的提交，材质，相机等等。</li>
</ul>
<h4 id="剔除优化-culling-optimization-场景图-scene-graph"> 剔除优化(Culling Optimization)/场景图(Scene Graph)</h4>
<p>用于根据某种可见性判断标准来限制需要渲染的图元数量。对于小型的世界，最简单的frustum cull，即将相机视锥外的图形剔除。对大型的世界，需要更高级的数据结构spatial subdivision来提高渲染效率，通过spatial subdivision可以非常快速的确定潜在可见物体集(the Potentila Visiable Set of Object, PVS)。</p>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/game-engine-reusability-gamut.png" type="image/png"/>
    </item>
    <item>
      <title>Hazel</title>
      <link>https://kigane.github.io/blog/hazel/</link>
      <guid>https://kigane.github.io/blog/hazel/</guid>
      <source url="https://kigane.github.io/rss.xml">Hazel</source>
      <category>C/C++</category>
      <pubDate>Mon, 13 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="eventsystem"> EventSystem</h2>
<ul>
<li>EntryPoint.h -- Game Main Loop
<ul>
<li>app = CreateApplicaiton();</li>
<li>app-&gt;run();</li>
<li>delete app;</li>
</ul>
</li>
<li>Application.h
<ul>
<li>Application(name)
<ul>
<li>创建窗口，设置回调</li>
<li>渲染初始化</li>
<li>创建ImGui层</li>
</ul>
</li>
<li>OnEvent(e)
<ul>
<li>Dispatch Event=&gt;function</li>
<li>Layer-&gt;OnEvent(e) 传播机制</li>
</ul>
</li>
<li>Run() 更新Layers和Window</li>
</ul>
</li>
<li>Event.h
<ul>
<li>创建事件 Event</li>
<li>分发事件 EventDispatcher</li>
<li>具体事件继承Event</li>
</ul>
</li>
</ul>
<p>一个窗口事件发生，有glfwWindow捕获，产生glfw事件。通过在创建窗口时，设置的各种事件回调函数(glfwSetWindowSizeCallback(window,callback))，将glfw事件转化为Hazel事件，并用Application::OnEvent回调函数处理。</p>
<h2 id="precompiled-header"> precompiled header</h2>
<p>当项目中cpp文件多了以后，每个cpp文件编译时都需要解析其include的头文件，其中有些头文件可能被多个cpp文件所引用，但每个编译单元(cpp文件)都要独立解析各自的头文件，效率比较低。<br>
因此，对于这些常用的，通常不会有修改的头文件(例如，iostream,vector,string....)，可以预先编译好，变成一个二进制文件。在后续cpp文件编译，链接时，可以直接查找这个编译好的二进制文件，效率高。</p>
<p>怎么做？</p>
<ul>
<li>建立一个pch.h头文件，将需要预编译的头文件包含进来</li>
<li>MSVC需要建立一个pch.cpp，内容仅需include &quot;pch.h&quot;即可。</li>
<li>VS2019相关设置
<ul>
<li>C/C++-&gt;precompiled headers-&gt;Precompiled Header 设为 Use</li>
<li>C/C++-&gt;precompiled headers-&gt;Precompiled Header File 设为 pch.h</li>
</ul>
</li>
<li>premake设置(proejct下)
<ul>
<li>pchheader &quot;pch.h&quot;</li>
<li>pchsource &quot;src/pch.cpp&quot;</li>
</ul>
</li>
</ul>
<p>PS: 如果pch.h中的头文件有任何一个改动，整个pch.h都需要重新编译。所以，不要将可能经常改动的头文件放入预编译头。</p>
<h2 id="layers"> Layers</h2>
<ul>
<li>Layer &amp; LayerStack</li>
<li>LayerStack是Layer的wrapper(一个vector&lt;Layer&gt;)，主要用于设定渲染顺序，以及事件的传播顺序(和渲染顺序相反)，将不同Layer的渲染和事件处理隔离开。</li>
<li>OnUpdate() 在每一帧渲染时调用</li>
<li>OnEvent() 在反向传播事件</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>numpy用法</title>
      <link>https://kigane.github.io/blog/numpy/</link>
      <guid>https://kigane.github.io/blog/numpy/</guid>
      <source url="https://kigane.github.io/rss.xml">numpy用法</source>
      <category>python</category>
      <pubDate>Sun, 05 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="索引"> 索引</h2>
<h3 id="采样"> 采样</h3>
<p>x是一维数组，<code>x[i]</code>，为x的第i个元素，np支持数组索引，<code>x[[i, j, k]]</code>，得到<code>[x[i], x[j], x[k]]</code>。如果<code>x[]</code>中传入的数组大于一维，得到的结果类似于将数组flatten后作为索引，得到的结果再reshape成索引数组的形状。</p>
<div><pre><code>x <span>=</span> np<span>.</span>arange<span>(</span><span>12</span><span>)</span>
y <span>=</span> np<span>.</span>array<span>(</span><span>[</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>]</span><span>]</span><span>)</span>
x<span>[</span>y<span>]</span> <span># y必须是np数组才行</span>
<span># array([[1, 2, 3, 4],</span>
<span>#        [2, 3, 4, 7]])</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="np-clip"> np.clip</h2>
<div><pre><code><span># numpy.clip(a, a_min, a_max, out=None, **kwargs)</span>
a <span>=</span> np<span>.</span>arange<span>(</span><span>5</span><span>)</span>
np<span>.</span>clip<span>(</span>a<span>,</span> <span>1</span><span>,</span> <span>3</span><span>)</span> <span># [1,1,2,3,3]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="np-random-shuffle"> np.random.shuffle</h2>
<p>原地打乱数组元素的顺序</p>
<div><pre><code>x <span>=</span> np<span>.</span>arange<span>(</span><span>10</span><span>)</span>
np<span>.</span>random<span>.</span>shuffle<span>(</span>x<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="np-cumsum"> np.cumsum</h2>
<p>计算列表元素的累积和</p>
<div><pre><code>a <span>=</span> np<span>.</span>array<span>(</span><span>[</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>,</span> <span>[</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span><span>]</span><span>)</span>
<span># 未指定axis则会先flatten，再计算cumsum</span>
np<span>.</span>cumsum<span>(</span>a<span>)</span> <span># 1, 3, 6, 10, 15, 21</span>
<span># 沿指定轴计算 </span>
np<span>.</span>cumsum<span>(</span>a<span>,</span>axis<span>=</span><span>0</span><span>)</span> <span># [[1, 2, 3], [5, 7, 9]]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="np-diff"> np.diff</h2>
<p>计算列表相邻元素之间的差值</p>
<div><pre><code><span># numpy.diff(a, n=1, axis=-1, prepend=&lt;no value>, append=&lt;no value>)</span>
x <span>=</span> np<span>.</span>array<span>(</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>0</span><span>]</span><span>)</span>
np<span>.</span>diff<span>(</span>x<span>)</span> <span># [1, 2, 3, -7]</span>
<span># n表示递归地做n次diff</span>
np<span>.</span>diff<span>(</span>x<span>,</span> n<span>=</span><span>2</span><span>)</span> <span># [1, 1, -10]</span>
<span># prepend=1表示在a的最后一维的所有列表前添加一个1，再计算cumsum。append同理</span>
np<span>.</span>diff<span>(</span>x<span>,</span> prepend<span>=</span><span>1</span><span>)</span> <span># [0, 1, 2, 3, -7]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="np-ma-masked-where"> np.ma.masked_where</h2>
<p>得到列表中满足条件的元素被设为True的掩码</p>
<div><pre><code><span># ma.masked_where(condition, a, copy=True)</span>
a <span>=</span> np<span>.</span>arange<span>(</span><span>4</span><span>)</span>
c <span>=</span> ma<span>.</span>masked_where<span>(</span>a <span>&lt;=</span> <span>2</span><span>,</span> a<span>)</span>
<span># c: masked_array(data=[--, --, --, 3],</span>
<span>#              mask=[ True,  True,  True, False],</span>
<span>#        fill_value=999999)</span>
c<span>[</span><span>0</span><span>]</span><span>=</span><span>99</span>
<span># masked_array(data=[99, --, --, 3],</span>
<span>#              mask=[False,  True,  True, False],</span>
<span>#        fill_value=999999)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>masked_equal(a, value, copy=True)</li>
<li>masked_less_equal(a, value, copy=True)</li>
<li>masked_inside(a, v1, v2, copy=True)</li>
<li>ma.masked_invalid(a, copy=True)</li>
<li>...</li>
</ul>
<p>填充被masked的位置，使用np.ma.filled</p>
<div><pre><code>x <span>=</span> np<span>.</span>ma<span>.</span>array<span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>]</span><span>,</span> mask<span>=</span><span>[</span><span>0</span><span>,</span><span>0</span><span>,</span><span>1</span><span>,</span><span>0</span><span>,</span><span>1</span><span>]</span><span>,</span> fill_value<span>=</span><span>-</span><span>999</span><span>)</span>
x<span>.</span>filled<span>(</span><span>)</span>
<span># array([   1,    2, -999,    4, -999])</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>katex 常用写法</title>
      <link>https://kigane.github.io/blog/katex-cheatsheet/</link>
      <guid>https://kigane.github.io/blog/katex-cheatsheet/</guid>
      <source url="https://kigane.github.io/rss.xml">katex 常用写法</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="常用符号"> 常用符号</h2>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">写法</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">写法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>ϕ</span></span></span></span></td>
<td style="text-align:center">\phi</td>
<td style="text-align:center"><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span>Φ</span></span></span></span></td>
<td style="text-align:center">\Phi</td>
</tr>
<tr>
<td style="text-align:center"><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span style="margin-right:0.03588em;">ω</span></span></span></span></td>
<td style="text-align:center">\omega</td>
<td style="text-align:center"><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span>Ω</span></span></span></span></td>
<td style="text-align:center">\Omega</td>
</tr>
</tbody>
</table>
<h2 id="环境"> 环境</h2>
<p><img src="/assets/img/katex-environments.png" alt="环境" /></p>
<p>多行公式在vuepress中无效，使用aligned环境替代。</p>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/katex-environments.png" type="image/png"/>
    </item>
    <item>
      <title>python</title>
      <link>https://kigane.github.io/blog/python/</link>
      <guid>https://kigane.github.io/blog/python/</guid>
      <source url="https://kigane.github.io/rss.xml">python</source>
      <category>python</category>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基础"> 基础</h2>
<h3 id="内置方法"> 内置方法</h3>
<ul>
<li><code>any(lst)</code>: lst中任意元素为True则返回True。即列表所有元素取or。</li>
<li><code>all(lst)</code>: lst中所有元素为True才返回True。即列表所有元素取and。</li>
</ul>
<h3 id="import"> import</h3>
<h4 id="module"> module</h4>
<ul>
<li>dir(): 无参数，查看全局命名空间的变量</li>
<li>dir(module): 查看指定模块的变量</li>
<li>一个.py文件可看作一个模块
<ul>
<li>import module (as alias) 引入module，可使用module命名空间及其内的变量</li>
<li>from module import var 将var从module中导入全局命名空间</li>
</ul>
</li>
</ul>
<h4 id="package"> package</h4>
<ul>
<li>一个目录，包含目录和子模块。</li>
<li>创建一个package需要在目录下创建一个<code>__init__.py</code></li>
<li>需要在<code>__init__.py</code>中引入子模块，否则import package时空有命名空间，而无内容</li>
</ul>
<h4 id="模块查找顺序"> 模块查找顺序</h4>
<ul>
<li>sys.module</li>
<li>python标准库</li>
<li>sys.path</li>
</ul>
<h4 id="相对导入"> 相对导入</h4>
<ul>
<li><code>.</code>，当前目录, <code>..</code>上一级目录, <code>...</code>上上一级目录。</li>
</ul>
<h4 id="importlib-模块"> importlib 模块</h4>
<ul>
<li><code>import_module('module_name', package=__name__)</code> 返回值即模块</li>
<li>package用于考虑相对导入</li>
</ul>
<h3 id="解包-自动"> 解包(自动)</h3>
<ul>
<li>等号右边的序列可以直接解包为单个元素，只要在左边分配同样数量的变量。</li>
<li>数量必须相同，否则会报错</li>
<li>可以部分解包，即在等号左边某个变量前加<code>*</code>号，则其会接受所有为未分配的值，并形成一个数组。(序列元素数量必须多于分配的变量数)。例如 <code>a, *b, c = [1, 2, 3, 4, 5]</code>，则有<code>b=[2,3,4]</code></li>
</ul>
<h3 id="压缩-zip"> 压缩(zip)</h3>
<ul>
<li><code>zip(range(3), reverse(range(5))) -&gt; [(0, 4), (1, 3), (2, 2)]</code></li>
<li>创建字典时很有用: dict(zip(keys, values))</li>
</ul>
<h3 id="itertools-chain"> itertools.chain</h3>
<ul>
<li>itertools.chain(range(3), range(4), range(5))</li>
<li>作用是将三个生成器(range())合并成一个新的，生成<code>[0,1,2,0,1,2,3,0,1,2,3,4]</code></li>
</ul>
<h3 id="函数"> 函数</h3>
<h4 id="参数"> 参数</h4>
<ul>
<li><code>def add(*args)</code>: 这里<code>*</code>作用是将所有剩下的未解析参数打包到一个元组中，赋给args。调用时可以用<code>*args</code>的到解包后的值。</li>
<li><code>def init(**kwargs)</code>: 这里<code>**</code>作用是将所有剩下未解析的关键字参数打包成字典，赋给kwargs。</li>
<li><code>def say(a, b, *, key=val...)</code>: 这里<code>*</code>是标识符，左边是位置参数，右边是关键字参数。</li>
<li>参数类型的声明顺序
<ul>
<li>必须参数</li>
<li>可选参数(提供默认值的参数)</li>
<li><code>*args</code></li>
<li><code>**kwargs</code></li>
</ul>
</li>
</ul>
<h4 id="函数注解"> 函数注解</h4>
<ul>
<li>python中对参数类型(参数后的冒号部分)和返回值类型(函数括号后，行尾冒号前的<code>-&gt;xx</code>部分)的描述方法</li>
<li><code>def prepend_rows(row:list, prefix:str) -&gt; list:</code></li>
<li>这些部分属于注解而非表达式，所以内容是无限制的。</li>
</ul>
<h3 id="lambda"> lambda</h3>
<ul>
<li><code>f = lambda x: x*x</code></li>
<li>语法: <code>lambda params:body</code>, <code>lambda: body</code></li>
<li>body必须是返回一个值的单个表达式</li>
</ul>
<h3 id="类"> 类</h3>
<h4 id="基础-2"> 基础</h4>
<ul>
<li>python类声明的主体是一个代码块，可以包含任何有效的python代码</li>
<li>在类声明中声明的变量会成为类对象的一个属性(即，类会创建一个新的命名空间记录这些变量)</li>
<li>super(Class, instance, ...) 使用instance的MRO，从Class位置开始向上找。</li>
</ul>
<h4 id="动态加载"> 动态加载</h4>
<ul>
<li>python所有的类都是type()的子类</li>
<li>type()用于实例化类的三部分信息:
<ul>
<li>类名称</li>
<li>基类</li>
<li>命名空间字典，在执行类的主体时被填充</li>
</ul>
</li>
<li>type()称为元类</li>
</ul>
<div><pre><code><span>class</span> <span>A</span><span>(</span><span>int</span><span>)</span><span>:</span>
    spam <span>=</span> <span>'eggs'</span>

<span># 等价于</span>
<span># 第一个A是为了创建类， 第二个A是用于将类名绑定到命名空间，两者可以不同(实际用时也确实是不同的)</span>
A <span>=</span> <span>type</span><span>(</span><span>'A'</span><span>,</span> <span>(</span><span>int</span><span>,</span><span>)</span><span>,</span> <span>{</span><span>'spam'</span><span>:</span> <span>'eggs'</span><span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="自定义元类"> 自定义元类</h4>
<div><pre><code><span># 通过继承type自定义元类</span>
<span>class</span> <span>SimpleMeta</span><span>(</span><span>type</span><span>)</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>cls<span>,</span> name<span>,</span> bases<span>,</span> attrs<span>)</span><span>:</span>
        <span>print</span><span>(</span>name<span>)</span>
        <span>super</span><span>(</span>SimpleMeta<span>,</span> cls<span>)</span><span>.</span>__init__<span>(</span>name<span>,</span> bases<span>,</span> attrs<span>)</span>

<span># 使用元类，效果是：python会自动将类定义传递给元类进行处理</span>
<span>class</span> <span>Example</span><span>(</span>metaclass<span>=</span>SimpleMeta<span>)</span><span>:</span>
    <span>pass</span> <span># 效果和标准类型一样</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="成员变量"> 成员变量</h4>
<ul>
<li>getattr() 用名称检索成员变量 访问类中不存在的成员变量时会触发<code>__getattr__</code>(d['attr'])</li>
<li>setattr() 用名称设置成员变量 设置类成员时触发<code>__setattr__</code>(d.attr = 'attr')</li>
<li>delattr() 用名称删除成员变量 删除类成员时触发<code>__delattr__</code>(del d.attr)</li>
<li><code>__str__</code> toString方法</li>
<li><code>__repr__</code> 在解释器中单独引用对象时触发</li>
</ul>
<h3 id="打包到pip"> 打包到pip</h3>
<ul>
<li>新建文件夹</li>
<li>将package放进去(包含__init__.py)</li>
<li>在根目录新建setup.py</li>
<li>在根目录执行
<ul>
<li>python setup.py bdist_wheel 打包成wheel</li>
<li>python setup.py sdist 打包成tar</li>
</ul>
</li>
<li>在打包好的文件目录下pip install 打包好的文件名</li>
<li>pip uninstall setup.name 即可卸载</li>
</ul>
<div><pre><code><span>from</span> setuptools <span>import</span> setup
<span>from</span> setuptools <span>import</span> find_packages

setup<span>(</span>name<span>=</span><span>'MySheet'</span><span>,</span>
      version<span>=</span><span>'0.1'</span><span>,</span>
      author<span>=</span><span>'hwk'</span><span>,</span>
      author_email<span>=</span><span>'abc@fg.com'</span><span>,</span>
      url<span>=</span><span>'https://hello.com'</span><span>,</span>
      packages<span>=</span>find_packages<span>(</span><span>)</span><span>,</span>
      zip_safe<span>=</span><span>False</span><span>,</span>
<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="anaconda"> anaconda</h2>
<h3 id="常用命令"> 常用命令</h3>
<ul>
<li>conda list: 查看安装了哪些包。</li>
<li>conda env list: 查看当前存在哪些虚拟环境</li>
<li>conda create -n your_env_name python=X.X: 创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件夹下找到。</li>
<li>activate your_env_name: Windows下激活虚拟环境</li>
<li>deactivate 退出</li>
<li>Linux下，激活，退出都在开头加一个source</li>
<li>conda remove -n your_env_name --all: 移除虚拟环境</li>
<li>conda install package_name: 在当前环境中安装包</li>
<li>conda install -n your_env_name package_name: 在指定环境中安装包</li>
<li>update, remove语法和install相同</li>
<li>conda search pname: 模糊搜索package</li>
<li>conda search --full-name pname: 全名查找</li>
<li>conda env export &gt; environment.yml: 导出环境配置</li>
<li>conda env create -f environment.yml: 导入环境配置</li>
</ul>
<h2 id="plt"> plt</h2>
<h3 id="markevery-指定会在图上标记的点的位置-间距"> markevery--指定会在图上标记的点的位置，间距</h3>
<ul>
<li>markevery=3 每三个数据点标记一个(标记，不标记，不标记，标记...)</li>
<li>markevery=(30, 3) 第30个之后，每三个数据点标记一个</li>
<li><code>markevery=[1,2,3,4]</code> 手动给出需要标记的点</li>
<li>markevery=slice(30, 90, 3) 在给定的区间(30, 90)内，每三个数据点标记一个</li>
<li>整型是以数据顺序为准，若是浮点型则以坐标轴长度为准。</li>
</ul>
<h3 id="极坐标"> 极坐标</h3>
<ul>
<li>subplot_kw={'projection': 'polar'} 映射到极坐标上</li>
</ul>
<h2 id="pytorch"> pytorch</h2>
<p>https://pytorch.org/get-started/locally/#windows-anaconda</p>
<h3 id="可重复性"> 可重复性</h3>
<ul>
<li>torch.backends.cudnn.benchmark = False 固定cuDNN在程序运行时使用的卷积算法</li>
<li>torch.backends.cudnn.deterministic = True  程序运行时设定的算法也可能不同，将其确定下来</li>
<li>torch.manual_seed(seed) 设置CPU和CUDA的RNG种子</li>
<li>torch.cuda.manual_seed_all(seed) 设置所有GPU的RNG种子</li>
<li>np.random.seed(seed) 设置NumPy的全局RNG种子</li>
</ul>
<h3 id="基础-3"> 基础</h3>
<ul>
<li>函数以_结尾，说明函数会原地修改调用者</li>
<li>torch.matmul 矩阵乘法</li>
<li>torch.no_grad() 禁止gradient操作</li>
<li>tensor.detach() 将张量从求梯度时建立的计算图中去掉，需要固定参数时很有用</li>
<li>tensor.cpu() 在CPU内存中返回对象的copy，如果已经在CPU了，则什么也不做</li>
<li>tensor.item() 当Tensor只有一个元素时，返回相应的python原生对象</li>
<li>torch.mean(tensor) 可以用dim=aixNum指定要在多维数组的那个维度求mean, 用keepdim=True可以让结果以指定的dim消失，但其他dim保留的形式显示。</li>
<li>tensor.std()</li>
<li>tensor.squeeze(dim) 去除指定的只有一个元素的维度</li>
<li>tensor.unsqueeze(dim) 添加一个只有一个元素的维度</li>
<li>dim=x，x为tensor.shape的第x+1个元素</li>
<li>tensor.transpose(dim1, dim2) 转置两个指定维度</li>
<li>torch.cat([x, y, z], dim=1) 将张量x,y,z在dim=1轴上合并</li>
<li>模型的保存加载
<ul>
<li>torch.save(model.state_dict(), PATH)</li>
<li>model = Model(*args, **kargs)</li>
<li>model.load_state_dict(torch.load(PATH))</li>
<li>model.eval()</li>
</ul>
</li>
<li>dataloader
<ul>
<li>drop_last=True 如果batch_size不能被样本数整除，则丢弃最后一个不完整的batch。</li>
<li>pin_memory=True the data loader will copy Tensors into CUDA pinned memory(CUDA的固定内存，可直接用物理地址访问，速度快) before returning them.</li>
</ul>
</li>
</ul>
<ul>
<li>广播机制
<ul>
<li>每个张量必须至少有1维</li>
<li>维数遍历是从最后一维开始的，可广播的条件是，两个张量相应的维度
<ul>
<li>相等</li>
<li>其中一个是1</li>
<li>其中一个不存在</li>
</ul>
</li>
<li>其中
<ul>
<li>相等，就是正常情况</li>
<li>其中一个不存在时，就加一维，令其成为1</li>
<li>其中一个为1，会将其复制扩张到另一个张量的大小</li>
</ul>
</li>
</ul>
</li>
<li>torch.normal(mean, std, size, *, out=None) → Tensor 生成正态分布的随机数组成的tensor</li>
</ul>
<h2 id="tqdm"> tqdm</h2>
<p>用在被遍历的可迭代对象上，自动产生进度条。</p>
<div><pre><code><span>from</span> tqdm <span>import</span> tqdm
<span>from</span> tqdm<span>.</span>notebook <span>import</span> tqdm_notebook
<span>import</span> time
<span>for</span> i <span>in</span> tqdm<span>(</span><span>range</span><span>(</span><span>20</span><span>)</span><span>,</span> desc<span>=</span><span>'Process Bar'</span><span>)</span><span>:</span>
    time<span>.</span>sleep<span>(</span><span>0.5</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>随机数</title>
      <link>https://kigane.github.io/blog/random/</link>
      <guid>https://kigane.github.io/blog/random/</guid>
      <source url="https://kigane.github.io/rss.xml">随机数</source>
      <category>blog</category>
      <pubDate>Sun, 05 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="固定种子"> 固定种子</h2>
<p>np.random.seed(seed)</p>
<h2 id="均匀分布的随机数"> 均匀分布的随机数</h2>
<h3 id="_0-1-内"> [0, 1)内</h3>
<div><pre><code><span># random.rand(d0, d1, ..., dn)</span>
np<span>.</span>random<span>.</span>rand<span>(</span><span>)</span> <span># 返回单个随机数</span>
np<span>.</span>random<span>.</span>rand<span>(</span><span>3</span><span>,</span> <span>2</span><span>)</span> <span># 返回(3, 2)的随机数数组</span>
<span>(</span>b <span>-</span> a<span>)</span> <span>*</span> np<span>.</span>random<span>.</span>rand<span>(</span><span>)</span> <span>+</span> a <span># [a, b)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="指定范围内的离散的"> 指定范围内的离散的</h3>
<div><pre><code><span># random.randint(low, high=None, size=None, dtype=int)</span>
np<span>.</span>random<span>.</span>randint<span>(</span><span>1</span><span>,</span> <span>7</span><span>,</span> <span>(</span><span>6</span><span>,</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="高斯分布的随机数"> 高斯分布的随机数</h2>
<div><pre><code><span># random.randn(d0, d1, ..., dn)</span>
np<span>.</span>random<span>.</span>randn<span>(</span><span>)</span>
np<span>.</span>random<span>.</span>randn<span>(</span><span>3</span><span>,</span> <span>2</span><span>)</span>
mu <span>+</span> sigma <span>*</span> np<span>.</span>random<span>.</span>randn<span>(</span><span>3</span><span>,</span> <span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="其他分布"> 其他分布</h2>
<p>np.random.xx</p>
<ul>
<li>chisquare</li>
<li>gamma</li>
<li></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>组件禁用</title>
      <link>https://kigane.github.io/guide/disable/</link>
      <guid>https://kigane.github.io/guide/disable/</guid>
      <source url="https://kigane.github.io/rss.xml">组件禁用</source>
      <description>&amp;lt;p&amp;gt;你可以通过设置页面的 Frontmatter，在页面禁用一些功能。&amp;lt;/p&amp;gt;
</description>
      <category>使用指南</category>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>

<p>本页面应当禁用了:</p>
<ul>
<li>导航栏</li>
<li>侧边栏</li>
<li>路径导航</li>
<li>页面信息</li>
<li>贡献者</li>
<li>编辑此页链接</li>
<li>更新时间</li>
<li>上一篇/下一篇 链接</li>
<li>评论</li>
<li>页脚</li>
<li>返回顶部按钮</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>VuePress 默认主题设置</title>
      <link>https://kigane.github.io/guide/configuration/</link>
      <guid>https://kigane.github.io/guide/configuration/</guid>
      <source url="https://kigane.github.io/rss.xml">VuePress 默认主题设置</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="frontmatter"> frontmatter</h2>
<p>必须在每个 .md 文件开头，通常以 yaml 格式表示。</p>
<div><pre><code><span>---</span>
<span>title</span><span>:</span> hello vuepress
<span>lang</span><span>:</span> zh<span>-</span>CN

<span>sidebarDepth</span><span>:</span> <span>2</span> 
<span>navbar</span><span>:</span> <span>false</span> 
<span>sidebar</span><span>:</span> <span>false</span>
<span>search</span><span>:</span> <span>false</span>
<span>tags</span><span>:</span>
  <span>-</span> configuration
  <span>-</span> theme
  <span>-</span> indexing
<span>prev</span><span>:</span> ./some<span>-</span>other<span>-</span>page
<span>next</span><span>:</span> <span>false</span>
<span>pageClass</span><span>:</span> custom<span>-</span>page<span>-</span>class
<span>layout</span><span>:</span> SpecialLayout
<span>---</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>title 会自动作为 sidebar 的一级链接标题(优先级低于在 config.js 中配置)。</li>
<li>sidebarDepth 见下文内嵌链接</li>
<li>navbar 用于在本页面关闭导航栏</li>
<li>sidebar 用于在本页面关闭侧边栏</li>
<li>search 用于在本页面关闭搜索框</li>
<li>tag 用于搜索(内置的搜索只搜索文章的 h2, h3 和 frontmatter 中设置的 tags)</li>
<li>prev 文章底部，上一篇文章的链接</li>
<li>next 文章底部，下一篇文章的链接</li>
<li>pageClass 为这一页自定义一个 class，用于在 .vuepress/styles/index.styl 添加自定义 css</li>
<li>layout 通常每个 .md 文件内容都是在容器 <code>&lt;div class=&quot;page&quot;&gt;</code> 中渲染的，包含侧边栏，上一篇，下一篇链接等。使用这个选项，可以设置使用特定的 vue 组件渲染该 .md 文件。(.vuepress/components/SpecialLayout.vue)</li>
</ul>
<h2 id="navbar"> navbar</h2>
<p>外部链接自动获得两个属性 target=&quot;_blank&quot; &amp; rel=&quot;noopener noreferrer&quot;。你也可以自定义。</p>
<ul>
<li>text 是显示的标题</li>
<li>ariaLabel 不知道有什么用</li>
<li>link 当然就是链接啦</li>
<li>items 用于套娃，最多两层(第一层有下拉菜单，第二层之间有分割线)。</li>
</ul>
<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code>themeConfig<span>:</span> <span>{</span>
    logo<span>:</span> <span>'/assets/img/ChernoLogo.png'</span><span>,</span> <span>// 左上角的图标</span>
    <span>// 导航栏</span>
    nav<span>:</span> <span>[</span>
      <span>{</span> text<span>:</span> <span>'Home'</span><span>,</span> link<span>:</span> <span>'/'</span> <span>}</span><span>,</span>
      <span>{</span> text<span>:</span> <span>'Guide'</span><span>,</span> link<span>:</span> <span>'/guide/'</span> <span>}</span><span>,</span>
      <span>{</span> text<span>:</span> <span>'External'</span><span>,</span> link<span>:</span> <span>'https://google.com'</span> <span>,</span> target<span>:</span><span>'_self'</span><span>,</span> rel<span>:</span><span>false</span> <span>}</span><span>,</span>
      <span>{</span>
        text<span>:</span> <span>'Languages'</span><span>,</span>
        ariaLabel<span>:</span> <span>'Language Menu'</span><span>,</span>
        items<span>:</span> <span>[</span> <span>// 还可以继续套娃</span>
          <span>{</span>
            text<span>:</span> <span>'Chinese'</span><span>,</span>
            ariaLabel<span>:</span> <span>'Chinese Menu'</span><span>,</span> <span>// 没啥用啊，这属性</span>
            items<span>:</span> <span>[</span>
              <span>{</span> text<span>:</span> <span>'ah'</span><span>,</span> link<span>:</span> <span>'https://google.com'</span> <span>}</span><span>,</span>
              <span>{</span> text<span>:</span> <span>'nj'</span><span>,</span> link<span>:</span> <span>'https://google.com'</span> <span>}</span><span>,</span>
            <span>]</span>
          <span>}</span><span>,</span>
          <span>{</span>
            text<span>:</span> <span>'English'</span><span>,</span>
            ariaLabel<span>:</span> <span>'English Menu'</span><span>,</span> <span>// 没啥用啊，这属性</span>
            items<span>:</span> <span>[</span>
              <span>{</span> text<span>:</span> <span>'sf'</span><span>,</span> link<span>:</span> <span>'https://google.com'</span> <span>}</span><span>,</span>
              <span>{</span> text<span>:</span> <span>'ny'</span><span>,</span> link<span>:</span> <span>'https://google.com'</span> <span>}</span><span>,</span>
            <span>]</span>
          <span>}</span><span>,</span>
        <span>]</span>
      <span>}</span>
    <span>]</span><span>,</span>

</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id="sidebar"> sidebar</h2>
<div><pre><code><span>// .vuepress/config.js</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  themeConfig<span>:</span> <span>{</span>
    sidebar<span>:</span> <span>[</span>
      <span>'/'</span><span>,</span>
      <span>'/page-a'</span><span>,</span>
      <span>[</span><span>'/page-b'</span><span>,</span> <span>'显示指定链接标题'</span><span>]</span>
    <span>]</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>指定路径时，可以忽略.md后缀，以'path/'结尾的路径，对应的内容为 path/README.md。如果需要显示指定标题，则如例子中的第三行。</p>
<h3 id="内嵌链接"> 内嵌链接</h3>
<p>默认抓取 Markdown 文档的所有二级标题作为当前链接的子链接。对应的设置为 themeConfig.sidebarDepth = 1。</p>
<p>sidebarDepth = 0 表示没有子链接。
sidebarDepth = 2 会抓取h2,h3作为子链接。最大层次就是2。效果见本文。</p>
<p>这个设置除了在配置中改，也可以在 .md 的 frontmatter 部分改。</p>
<div><pre><code><span>---</span>
<span>sidebarDepth</span><span>:</span> <span>0</span>
<span>---</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="展开所有子链接"> 展开所有子链接</h3>
<div><pre><code><span>// .vuepress/config.js</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  themeConfig<span>:</span> <span>{</span>
    displayAllHeaders<span>:</span> <span>true</span> <span>// Default: false</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="导航栏分组"> 导航栏分组</h3>
<p>顾名思义</p>
<div><pre><code>sidebar<span>:</span> <span>[</span>
      <span>{</span>
        title<span>:</span> <span>'Group1'</span><span>,</span> <span>// 必须要有分组名</span>
        collapsable<span>:</span> <span>false</span><span>,</span> <span>// 默认是折叠，设为 true 表示直接展开</span>
        children<span>:</span> <span>[</span><span>'/blog/'</span><span>,</span> <span>'/blog/test'</span><span>]</span> <span>// 有多个分组成员</span>
      <span>}</span><span>,</span>
      <span>{</span> <span>// 只有一个分组成员</span>
        title<span>:</span> <span>'Group2'</span><span>,</span>
        path<span>:</span> <span>'/guide/'</span><span>,</span>
      <span>}</span><span>,</span>
      <span>'/'</span><span>,</span>
    <span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="多重侧边栏"> 多重侧边栏</h3>
<p>不同的分区可以对应不同的侧边导航栏。<br>
<strong>fallback 必须放在最后！</strong><br>
auto 的意思是这一个 md 自动生成一个它独占的侧边栏。</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre><code>sidebar<span>:</span> <span>{</span>
      <span>'/foo/'</span><span>:</span> <span>[</span>
        <span>''</span><span>,</span>     <span>/* /foo/ */</span>
        <span>'one'</span><span>,</span>  <span>/* /foo/one.html */</span>
        <span>'two'</span>   <span>/* /foo/two.html */</span>
      <span>]</span><span>,</span>

      <span>'/bar/'</span><span>:</span> <span>[</span>
        <span>''</span><span>,</span>      <span>/* /bar/ */</span>
        <span>'three'</span><span>,</span> <span>/* /bar/three.html */</span>
        <span>'four'</span>   <span>/* /bar/four.html */</span>
      <span>]</span><span>,</span>

      <span>'/baz/'</span><span>:</span> <span>'auto'</span><span>,</span> <span>/* automatically generate single-page sidebars */</span>

      <span>// fallback</span>
      <span>'/'</span><span>:</span> <span>[</span>
        <span>''</span><span>,</span>        <span>/* / */</span>
        <span>'contact'</span><span>,</span> <span>/* /contact.html */</span>
        <span>'about'</span>    <span>/* /about.html */</span>
      <span>]</span>
    <span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="code-groups"> code groups</h2>
<p>CodeGroupItem之间需要空一行</p>
<div><pre><code><span><span><span>&lt;</span>CodeGroup</span><span>></span></span>
<span><span><span>&lt;</span>CodeGroupItem</span> <span>title</span><span><span>=</span><span>"</span>YARN<span>"</span></span><span>></span></span>
\`\`\`bash
yarn create vuepress-site [optionalDirectoryName]
\`\`\`
<span><span><span>&lt;/</span>CodeGroupItem</span><span>></span></span>

<span><span><span>&lt;</span>CodeGroupItem</span> <span>title</span><span><span>=</span><span>"</span>NPM<span>"</span></span><span>></span></span>
\`\`\`bash
npx create-vuepress-site [optionalDirectoryName]
\`\`\`
<span><span><span>&lt;/</span>CodeGroupItem</span><span>></span></span>
<span><span><span>&lt;/</span>CodeGroup</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>效果如下</p>
<CodeGroup>
<CodeGroupItem title="YARN">
<div><pre><code><span>yarn</span> create vuepress-site <span>[</span>optionalDirectoryName<span>]</span>
</code></pre>
<div><span>1</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="NPM">
<div><pre><code>npx create-vuepress-site <span>[</span>optionalDirectoryName<span>]</span>
</code></pre>
<div><span>1</span><br></div></div></CodeGroupItem>
</CodeGroup>]]></content:encoded>
    </item>
    <item>
      <title>密码加密的文章</title>
      <link>https://kigane.github.io/guide/encrypt/</link>
      <guid>https://kigane.github.io/guide/encrypt/</guid>
      <source url="https://kigane.github.io/rss.xml">密码加密的文章</source>
      <category>使用指南</category>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="密码加密的文章"> 密码加密的文章</h1>
<p>实际的文章内容。</p>
<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>
<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 增强</title>
      <link>https://kigane.github.io/guide/markdown/</link>
      <guid>https://kigane.github.io/guide/markdown/</guid>
      <source url="https://kigane.github.io/rss.xml">Markdown 增强</source>
      <description>&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;vuepress-theme-hope&amp;lt;/code&amp;gt; 通过内置 &amp;lt;a href=&amp;quot;https://vuepress-theme-hope.github.io/md-enhance&amp;quot; target=&amp;quot;_blank&amp;quot; rel=&amp;quot;noopener noreferrer&amp;quot;&amp;gt;md-enhance&amp;lt;/a&amp;gt;，在 Markdown 中启用了更多的语法与新功能。&amp;lt;/p&amp;gt;
</description>
      <category>使用指南</category>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>vuepress-theme-hope</code> 通过内置 <a href="https://vuepress-theme-hope.github.io/md-enhance" target="_blank" rel="noopener noreferrer">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>

<h2 id="一键启用"> 一键启用</h2>
<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href="https://vuepress-theme-hope.github.io/md-enhance" target="_blank" rel="noopener noreferrer">md-enhance</a> 插件的所有功能。</p>
<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  themeConfig<span>:</span> <span>{</span>
    mdEnhance<span>:</span> <span>{</span>
      enableAll<span>:</span> <span>true</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="新增的更多语法"> 新增的更多语法</h2>
<h3 id="上下角标"> 上下角标</h3>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<details><summary>代码</summary>
<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/sup-sub/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="自定义对齐"> 自定义对齐</h3>
<p>::: center</p>
<p>我是居中的</p>
<p>:::</p>
<p>::: right</p>
<p>我在右对齐</p>
<p>:::</p>
<details><summary>代码</summary>
<div><pre><code>::: center

我是居中的

:::

::: right

我在右对齐

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/align/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="脚注"> 脚注</h3>
<p>此文字有脚注<sup></sup>.</p>
<details><summary>代码</summary>
<div><pre><code>此文字有脚注[^first].

<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/footnote/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="标记"> 标记</h3>
<p>你可以标记 ==重要的内容== 。</p>
<details><summary>代码</summary>
<div><pre><code>你可以标记 ==重要的内容== 。
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/mark/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="任务列表"> 任务列表</h3>
<ul>
<li>[x] 计划 1</li>
<li>[ ] 计划 2</li>
</ul>
<details><summary>Code</summary>
<div><pre><code><span>-</span> [x] 计划 1
<span>-</span> [ ] 计划 2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/guide/markdown/tasklist/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="流程图"> 流程图</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code><span><span>```</span><span>flow</span>
<span>cond=>condition: Process?
process=>operation: Process
e=>end: End

cond(yes)->process->e
cond(no)->e</span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/flowchart/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h2 id="mermaid"> Mermaid</h2>
<Mermaid id="mermaid-64a57026" data-code="sequenceDiagram%0A%20%20%20%20Alice%20-%3E%3E%20Bob%3A%20Hello%20Bob%2C%20how%20are%20you%3F%0A%20%20%20%20Bob--%3E%3EJohn%3A%20How%20about%20you%20John%3F%0A%20%20%20%20Bob--x%20Alice%3A%20I%20am%20good%20thanks!%0A%20%20%20%20Bob-x%20John%3A%20I%20am%20good%20thanks!%0A%20%20%20%20Note%20right%20of%20John%3A%20Bob%20thinks%20a%20long%3Cbr%2F%3Elong%20time%2C%20so%20long%3Cbr%2F%3Ethat%20the%20text%20does%3Cbr%2F%3Enot%20fit%20on%20a%20row.%0A%0A%20%20%20%20Bob--%3EAlice%3A%20Checking%20with%20John...%0A%20%20%20%20Alice-%3EJohn%3A%20Yes...%20John%2C%20how%20are%20you%3F%0A"></Mermaid><details><summary>代码</summary>
<div><pre><code>```sequence
Alice ->> Bob: Hello Bob, how are you?
Bob-->>John: How about you John?
Bob--x Alice: I am good thanks!
Bob-x John: I am good thanks!
Note right of John: Bob thinks a long<span><span><span>&lt;</span>br</span><span>/></span></span>long time, so long<span><span><span>&lt;</span>br</span><span>/></span></span>that the text does<span><span><span>&lt;</span>br</span><span>/></span></span>not fit on a row.

Bob-->Alice: Checking with John...
Alice->John: Yes... John, how are you?
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/mermaid/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="tex-语法"> Tex 语法</h3>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.4em;vertical-align:-0.95em;"></span><span><span></span><span><span><span><span style="height:1.3714em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.05556em;">∂</span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.05556em;">∂</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.0277em;vertical-align:-1.2777em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>{</span></span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span><span><span><span style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span></span><span><span><span><span style="height:1.5017em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.1667em;"></span><span>⋯</span><span style="margin-right:0.1667em;"></span><span>(</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span><span>i</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span>1</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02778em;">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>}</span></span></span></span></span></span></span></p>
<details><summary>代码</summary>
<div><pre><code>$$
\frac {\partial^r} {\partial \omega^r} \left(\frac {y^{\omega}} {\omega}\right)
= \left(\frac {y^{\omega}} {\omega}\right) \left\{(\log y)^r + \sum_{i=1}^r \frac {(-1)^i r \cdots (r-i+1) (\log y)^{r-i}} {\omega^i} \right\}
$$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/tex/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="代码案例"> 代码案例</h3>

          <div
            id="code-demo-5ac6bc9f"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>alert</span><span>(</span><span>"十分帅"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

<span><span>```</span><span>html</span>
<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span></span>
<span>```</span></span>

<span><span>```</span><span>js</span>
<span>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>alert</span><span>(</span><span>"十分帅"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>

          <div
            id="code-demo-693e1878"
           
  data-type="react"
 data-title="%E4%B8%80%E4%B8%AA%20React%20Demo"

            data-code="%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Hope%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> message<span>:</span> <span>"十分帅"</span> <span>}</span><span>;</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div className<span>=</span><span>"box-react"</span><span>></span>
        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>
      <span>&lt;</span><span>/</span>div<span>></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo [react] 一个 React Demo

<span><span>```</span><span>js</span>
<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> message<span>:</span> <span>"十分帅"</span> <span>}</span><span>;</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div className<span>=</span><span>"box-react"</span><span>></span>
        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>
      <span>&lt;</span><span>/</span>div<span>></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span></span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>.box-react span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>

          <div
            id="code-demo-2c0b9cdb"
           
  data-type="vue"
 data-title="%E4%B8%80%E4%B8%AA%20Vue%20Demo"

            data-code="%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Hope%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> message<span>:</span> <span>"十分帅"</span> <span>}</span><span>)</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.box span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo [vue] 一个 Vue Demo

<span><span>```</span><span>vue</span>
<span>&lt;template>
  &lt;div>
    Mr.Hope &lt;span>{{ message }}&lt;/span>
  &lt;/div>
&lt;/template>
&lt;script>
export default {
  data: () => ({ message: "十分帅" }),
};
&lt;/script>
&lt;style>
.box span {
  color: red;
}
&lt;/style></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>

          <div
            id="code-demo-2869b0e2"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22md%22%3A%22%23%20%E6%A0%87%E9%A2%98%5Cn%5Cn%E5%8D%81%E5%88%86%E5%B8%85%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span>#</span> 标题</span>

十分帅
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>"Mr.Hope"</span><span>;</span>

document<span>.</span><span>querySelector</span><span>(</span><span>"h1"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>
  <span>font-style</span><span>:</span> italic<span>;</span>

  <span>+ p </span><span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

<span><span>```</span><span>md</span>
<span><span><span>#</span> 标题</span>

十分帅</span>
<span>```</span></span>

<span><span>```</span><span>ts</span>
<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>"Mr.Hope"</span><span>;</span>

document<span>.</span><span>querySelector</span><span>(</span><span>"h1"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>
<span>```</span></span>

<span><span>```</span><span>scss</span>
<span><span>h1 </span><span>{</span>
  <span>font-style</span><span>:</span> italic<span>;</span>

  <span>+ p </span><span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
  <span>}</span>
<span>}</span></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/demo/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="幻灯片"> 幻灯片</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code>@slidestart

<span><span>##</span> 幻灯片 1</span>

一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落

<span>---</span>

<span><span>##</span> 幻灯片 2</span>

<span>-</span> 列表 1
<span>-</span> 列表 2

<span>---</span>

<span><span>##</span> 幻灯片 3.1</span>

<span><span>```</span><span>js</span>
<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>
<span>```</span></span>

--

<span><span>##</span> 幻灯片 3.2</span>

$$
J(\theta_0,\theta_1) = \sum_{i=0}
$$

@slideend
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/presentation/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h2 id="其他语法"> 其他语法</h2>
<div><p>自定义标题</p>
<p>信息容器</p>
</div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<details><summary>代码</summary>
<div><pre><code>::: info 自定义标题

信息容器

:::

::: tip 自定义标题

提示容器

:::

::: warning 自定义标题

警告容器

:::

::: danger 自定义标题

危险容器

:::

::: details 自定义标题

详情容器

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>
<hr>
<section>
<ol>
<li id="footnote1"><p>这是脚注内容 </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>页面配置</title>
      <link>https://kigane.github.io/guide/page/</link>
      <guid>https://kigane.github.io/guide/page/</guid>
      <source url="https://kigane.github.io/rss.xml">页面配置</source>
      <category>guide</category>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="页面信息"> 页面信息</h2>
<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>
<ul>
<li>
<p>作者设置为 Ms.Hope。</p>
</li>
<li>
<p>写作时间应为 2020 年 1 月 1 日</p>
</li>
<li>
<p>分类为 “使用指南”</p>
</li>
<li>
<p>标签为 “页面配置” 和 “使用指南”</p>
</li>
</ul>
<h2 id="页面内容"> 页面内容</h2>
<p>你可以自由在这里书写你的 Markdown。</p>
<div><p>Tips</p>
<ul>
<li>
<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>
</li>
<li>
<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>
</li>
</ul>
</div>
<p>主题包含了一个自定义徽章章可以使用:</p>
<blockquote>
<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Not supported content</i></p>
</blockquote>
<h2 id="页面结构"> 页面结构</h2>
<p>此页面应当包含：</p>
<ul>
<li>返回顶部按钮</li>
<li>路径导航</li>
<li>评论</li>
<li>页脚</li>
</ul>
<h2 id="slide"> slide</h2>
<i>Not supported content</i>]]></content:encoded>
    </item>
    <item>
      <title>Hello Vuepress</title>
      <link>https://kigane.github.io/guide/</link>
      <guid>https://kigane.github.io/guide/</guid>
      <source url="https://kigane.github.io/rss.xml">Hello Vuepress</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="遇到的问题"> 遇到的问题</h2>
<p>在根目录的readme中设置footer内容时使用双引号，会出现YAML Exception。项目无法正常编译。</p>
<h2 id="math"> math</h2>
<p>安装 markdown-it-katex 插件</p>
<div><pre><code><span>yarn</span> <span>add</span> markdown-it-katex -D
</code></pre>
<div><span>1</span><br></div></div><p>再设置</p>
<div><pre><code><span>// .vuepress/config.js</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  markdown<span>:</span> <span>{</span>
    <span>// 开启代码块行号</span>
    lineNumbers<span>:</span> <span>true</span><span>,</span>
    <span>// 选择目录层级</span>
    toc<span>:</span> <span>{</span> includeLevel<span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span> <span>}</span><span>,</span>
    <span>// 加载插件</span>
    <span>extendMarkdown</span><span>:</span> <span>md</span> <span>=></span> <span>{</span>
      <span>// use more markdown-it plugins!</span>
      md<span>.</span><span>use</span><span>(</span><span>require</span><span>(</span><span>'markdown-it-katex'</span><span>)</span><span>)</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>// 要使 markdown-it-katex 插件生效，还需要设置在每个 html 的 &lt;head> 部分，加上一些依赖的引用。</span>
  head<span>:</span> <span>[</span>
    <span>[</span><span>'link'</span><span>,</span> <span>{</span>
      rel<span>:</span> <span>'stylesheet'</span><span>,</span>
      href<span>:</span> <span>'https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css'</span>
    <span>}</span><span>]</span><span>,</span>
    <span>[</span><span>'link'</span><span>,</span> <span>{</span>
      rel<span>:</span> <span>"stylesheet"</span><span>,</span>
      href<span>:</span> <span>"https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"</span>
    <span>}</span><span>]</span><span>,</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>效果如下：<br>
<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.1901em;vertical-align:-0.345em;"></span><span><span></span><span><span><span><span style="height:0.8451em;"><span style="top:-2.655em;"><span style="height:3em;"></span><span><span><span>n</span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span style="height:3em;"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.345em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1.0622em;vertical-align:-0.2481em;"></span><span><span>n</span><span><span><span><span style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.4637em;vertical-align:-0.9819em;"></span><span><span><span style="width:0.5em;"></span><span><span><span><span style="height:1.4819em;"><span style="top:-3.4819em;"><span style="height:3.4819em;"></span><span><span><span><span style="top:0em;"><span>[</span></span><span><span><span style="width:0.5em;"></span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>cos</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>−</span><span style="margin-right:0.1667em;"></span><span>sin</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span></span><span>​</span></span><span><span style="height:0.95em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>sin</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>cos</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span></span><span>​</span></span><span><span style="height:0.95em;"><span></span></span></span></span></span><span style="width:0.5em;"></span></span></span><span style="top:0em;"><span>]</span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>[</span></span><span><span><span style="width:0.5em;"></span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.95em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.95em;"><span></span></span></span></span></span><span style="width:0.5em;"></span></span></span><span style="top:0em;"><span>]</span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>[</span></span><span><span><span style="width:0.5em;"></span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>cos</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>sin</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span></span><span>​</span></span><span><span style="height:0.95em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:1.45em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>−</span><span style="margin-right:0.1667em;"></span><span>sin</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>cos</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span></span><span>​</span></span><span><span style="height:0.95em;"><span></span></span></span></span></span><span style="width:0.5em;"></span></span></span><span style="top:0em;"><span>]</span></span></span><span style="margin-right:0.2778em;"></span><span>=</span></span><span><span><span style="top:0em;"><span>[</span></span><span><span><span style="width:0.5em;"></span><span><span><span><span style="height:1.4819em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span>cos</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>ϕ</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span>sin</span><span><span><span><span style="height:0.8719em;"><span style="top:-3.1208em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span><span style="top:-2.3781em;"><span style="height:3em;"></span><span><span><span style="top:0em;">(</span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="top:0em;">)</span></span><span style="margin-right:0.1667em;"></span><span>cos</span><span style="margin-right:0.1667em;"></span><span>ϕ</span><span style="margin-right:0.1667em;"></span><span>sin</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span></span><span>​</span></span><span><span style="height:0.9819em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:1.4819em;"><span style="top:-3.61em;"><span style="height:3em;"></span><span><span><span style="top:0em;">(</span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="top:0em;">)</span></span><span style="margin-right:0.1667em;"></span><span>cos</span><span style="margin-right:0.1667em;"></span><span>ϕ</span><span style="margin-right:0.1667em;"></span><span>sin</span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span><span style="top:-2.3781em;"><span style="height:3em;"></span><span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span>cos</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>ϕ</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span><span>λ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span>sin</span><span><span><span><span style="height:0.8719em;"><span style="top:-3.1208em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>ϕ</span></span></span></span><span>​</span></span><span><span style="height:0.9819em;"><span></span></span></span></span></span><span style="width:0.5em;"></span></span></span><span style="top:0em;"><span>]</span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.9819em;"><span></span></span></span></span></span><span style="width:0.5em;"></span></span></span></span></span></span></span></p>
<h2 id="git-hub-tables"> git hub tables</h2>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h2 id="container"> container</h2>
<div><p>Tips</p>
<p>this is tips</p>
</div>
<div><p>Note</p>
<p>this is warning</p>
</div>
<div><p>STOP</p>
<p>this is danger warning</p>
</div>
<details><summary>custom title</summary>
<p>more details here</p>
</details>
<h2 id="语法高亮"> 语法高亮</h2>
<p>代码块内某些行高亮。{}里面行号之间不能有空格。</p>
<div><div><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br></div><pre><code><span><span>#</span><span>version</span> <span><span>330</span> core</span></span>
<span>(</span><span>layout</span> location <span>=</span> <span>0</span><span>)</span> <span>in</span> <span>vec3</span> a_Pos

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    gl_Position <span>=</span> a_Pos<span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="部署"> 部署</h2>
<p>按文档来，没成功。git push -f xxxxx master 会在github库中新建一个master分支，而且有时候推送失败，原因不明。<br>
因为我安装了 wsl2，执行bash命令会进入Ubantu18.04，也导致shell脚本出错。<br>
最终，解决方法如下：</p>
<p>在package.json中添加npm命令，用于执行shell脚本。</p>
<div><div><br><br><br><div>&nbsp;</div><br><br></div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
    <span>"docs:dev"</span><span>:</span> <span>"vuepress dev docs"</span><span>,</span>
    <span>"docs:build"</span><span>:</span> <span>"vuepress build docs"</span><span>,</span>
    <span>"docs:deploy"</span><span>:</span> <span>"deploy.sh"</span>
  <span>}</span><span>,</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>手动clone GithubPage关联库 https://github.com/username/username.github.io.git 到本地，并放在目录project/docs/.vuepress/下。(和生成的dist目录同级)</p>
<p>deploy.sh内容为</p>
<div><pre><code><span>#!/usr/bin/env sh</span>

<span># abort on errors</span>
<span>set</span> -e

<span># build</span>
<span>npm</span> run docs:build

<span># navigate into the build output directory</span>
<span>cd</span> docs/.vuepress/dist

<span># 将一个目录下的一些文件移动到另一个目录下</span>
<span>cp</span> -R * <span>..</span>/username.github.io

<span>cd</span> <span>..</span>/username.github.io

<span>git</span> <span>add</span> -A
<span>git</span> commit -m <span>'deploy'</span>
<span>git</span> push

<span>cd</span> -

<span># 执行完不立即退出shell，便于查看错误信息。</span>
<span>read</span> -n <span>1</span> -p <span>'Press any key to continue...'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>deploy.sh 实际上完成了三件事</p>
<ol>
<li>执行 npm run docs:build 生成要发布的内容。(重复生成时 dist 文件夹会先被清空，再生成新文件。)</li>
<li>将 dist 文件夹中的所有文件都复制到 username.githbu.io 文件夹中</li>
<li>在 username.githbu.io 文件夹中(GithubPage关联的库)，提交修改并推送到远程库</li>
</ol>
<h2 id="全局computed"> 全局Computed</h2>
<p>因为 ketex 公式分隔符是 'dollar', 和 vue 提供的全局变量前缀冲突了。所以一页只能有一个全局变量保持正常。<br>
site = {{$site}}</p>
]]></content:encoded>
    </item>
    <item>
      <title>Intro Page</title>
      <link>https://kigane.github.io/intro/</link>
      <guid>https://kigane.github.io/intro/</guid>
      <source url="https://kigane.github.io/rss.xml">Intro Page</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="intro-page"> Intro Page</h1>
<p>Place your introducation and profile here.</p>
]]></content:encoded>
    </item>
    <item>
      <title>这主题废弃了标题？</title>
      <link>https://kigane.github.io/home/</link>
      <guid>https://kigane.github.io/home/</guid>
      <source url="https://kigane.github.io/rss.xml">这主题废弃了标题？</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>This is an example of a normal homepage. You can place your main content here.</p>
<p>To use this layout, you need to set <code>home: true</code> in the page front matter.</p>
<p>For related descriptions of configuration items, please see <a href="https://vuepress-theme-hope.github.io/guide/layout/home/" target="_blank" rel="noopener noreferrer">Project HomePage Layout Config</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Custom Layout</title>
      <link>https://kigane.github.io/layout/</link>
      <guid>https://kigane.github.io/layout/</guid>
      <source url="https://kigane.github.io/rss.xml">Custom Layout</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>You can use slots with markdown and component support to custom page layout.</p>
<div><p>Note</p>
<p>This is just a demo, you should add styles according to your own needs.</p>


</div>
<template #page-top><p>Page top content</p>
</template><template #page-bottom><p>Page bottom content</p>
</template><template #content-top><p>Content top content</p>
</template><template #content-bottom><p>Content bottom content</p>
</template><template #navbar-start><p>Navbar start content</p>
</template><template #navbar-center><p>Navbar center content</p>
</template><template #navbar-end><p>Navbar end content</p>
</template><template #sidebar-top><p>Sidebar top content</p>
</template><template #sidebar-center><p>Sidebar center content</p>
</template><template #sidebar-bottom><p>Sidebar bottom content</p>
</template><p>For details, see <a href="https://vuepress-theme-hope.github.io/guide/layout/custom/" target="_blank" rel="noopener noreferrer">Custom layout</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>算法</title>
      <link>https://kigane.github.io/note/algorithm/</link>
      <guid>https://kigane.github.io/note/algorithm/</guid>
      <source url="https://kigane.github.io/rss.xml">算法</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="随机生成表达式"> 随机生成表达式</h2>
<p><a href="https://softwareengineering.stackexchange.com/questions/195813/generating-random-math-expression/195850#195850" target="_blank" rel="noopener noreferrer">参考</a></p>
<div><pre><code><span>4</span> <span>+</span> <span>2</span>                          
<span>3</span> <span>*</span> <span>6</span> <span>-</span> <span>7</span> <span>+</span> <span>2</span>                  
<span>6</span> <span>*</span> <span>2</span> <span>+</span> <span>(</span><span>5</span> <span>-</span> <span>3</span><span>)</span> <span>*</span> <span>3</span> <span>-</span> <span>8</span>        
<span>(</span><span>3</span> <span>+</span> <span>4</span><span>)</span> <span>+</span> <span>7</span> <span>*</span> <span>2</span> <span>-</span> <span>1</span> <span>-</span> <span>9</span>        
<span>5</span> <span>-</span> <span>2</span> <span>+</span> <span>4</span> <span>*</span> <span>(</span><span>8</span> <span>-</span> <span>(</span><span>5</span> <span>+</span> <span>1</span><span>)</span><span>)</span> <span>+</span> <span>9</span>  
<span>(</span><span>8</span> <span>-</span> <span>1</span> <span>+</span> <span>3</span><span>)</span> <span>*</span> <span>6</span> <span>-</span> <span>(</span><span>(</span><span>3</span> <span>+</span> <span>7</span><span>)</span> <span>*</span> <span>2</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>设置产生规则</p>
<ul>
<li>E -&gt; I</li>
<li>E -&gt; (E '+' E)</li>
<li>E -&gt; (E '*' E)</li>
</ul>
<p>通过递归可以生成符合要求的表达式。但会产生很多多余的括号。</p>
<ul>
<li>E -&gt; I</li>
<li>E -&gt; M '*' M</li>
<li>E -&gt; E '+' E</li>
<li>M -&gt; I</li>
<li>M -&gt; M '*' M</li>
<li>M -&gt; '(' E '+' E ')'</li>
</ul>
<p>这种规则不会产生多余的括号。</p>
<div><pre><code><span>// 简单的实现</span>
<span>int</span> num <span>=</span> <span>0</span><span>;</span>
<span>char</span> num_buf<span>[</span><span>20</span><span>]</span> <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>uint32_t</span> <span>choose</span><span>(</span><span>unit32_t</span> n<span>)</span><span>;</span> <span>// 产生0~n-1中的随机整数。</span>

<span>void</span> <span>gen_rand_expr</span><span>(</span><span>int</span> flag<span>)</span>
<span>{</span>
    <span>switch</span> <span>(</span><span>choose</span><span>(</span><span>6</span><span>)</span><span>)</span>
    <span>{</span>
        <span>case</span> <span>0</span><span>:</span> 
            <span>gen_rand_expr</span><span>(</span>false<span>)</span><span>;</span>
            <span>strcat</span><span>(</span>buf<span>,</span> <span>"*"</span><span>)</span><span>;</span>
            <span>gen_rand_expr</span><span>(</span>false<span>)</span><span>;</span>
            <span>break</span><span>;</span>
        <span>case</span> <span>1</span><span>:</span>
            <span>if</span> <span>(</span><span>!</span>flag<span>)</span> <span>strcat</span><span>(</span><span>"buf"</span><span>,</span> <span>"("</span><span>)</span><span>;</span>
            <span>gen_rand_expr</span><span>(</span>false<span>)</span><span>;</span>
            <span>strcat</span><span>(</span>buf<span>,</span> <span>"+"</span><span>)</span><span>;</span>
            <span>gen_rand_expr</span><span>(</span>false<span>)</span><span>;</span>
            <span>if</span> <span>(</span><span>!</span>flag<span>)</span> <span>strcat</span><span>(</span><span>"buf"</span><span>,</span> <span>")"</span><span>)</span><span>;</span>
        <span>default</span><span>:</span>
            num <span>=</span> <span>gen_num</span><span>(</span><span>)</span><span>;</span>
            <span>sprintf</span><span>(</span>num_buf<span>,</span> <span>"%u"</span><span>,</span> num<span>)</span><span>;</span>
            <span>strcat</span><span>(</span>buf<span>,</span> num_buf<span>)</span><span>;</span>
            <span>break</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>C语言</title>
      <link>https://kigane.github.io/note/cpp/c/</link>
      <guid>https://kigane.github.io/note/cpp/c/</guid>
      <source url="https://kigane.github.io/rss.xml">C语言</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="union和匿名结构"> Union和匿名结构</h2>
<p>Union: 定义类似struct，但内存分配方式不一样。struct会为所有成员分配内存空间，union是所有成员共用一个内存空间，大小以最大的成员为准。
匿名：通常嵌套于union或strcut中，可以用外层类型的变量名直接访问匿名的结构成员。union中的匿名比较有用，因为可以将一系列成员包裹起来以获取更大的内存空间。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdint.h></span></span>

<span>typedef</span> <span>union</span>  
<span>{</span>
    <span>union</span>
    <span>{</span>
        <span>uint32_t</span> _32<span>;</span>
        <span>uint16_t</span> _16<span>;</span>
        <span>uint8_t</span> _8<span>[</span><span>2</span><span>]</span><span>;</span>
    <span>}</span> gpr<span>[</span><span>8</span><span>]</span><span>;</span> <span>// 32B</span>

    <span>struct</span>
    <span>{</span>
        <span>uint32_t</span> eax<span>,</span> ecx<span>,</span> edx<span>,</span> ebx<span>,</span> esp<span>,</span> ebp<span>,</span> esi<span>,</span> edi<span>;</span>
        <span>uint64_t</span> pc<span>;</span>
    <span>}</span><span>;</span> <span>// 40B</span>
<span>}</span> CPU<span>;</span>


<span>int</span> <span>main</span><span>(</span><span>int</span> argc<span>,</span> <span>char</span> <span>const</span> <span>*</span>argv<span>[</span><span>]</span><span>)</span>
<span>{</span>
    CPU cpu<span>;</span>
    cpu<span>.</span>gpr<span>[</span><span>0</span><span>]</span><span>.</span>_32 <span>=</span> <span>666</span><span>;</span>
    <span>printf</span><span>(</span><span>"CPU size: %d\n"</span><span>,</span> <span>sizeof</span><span>(</span>CPU<span>)</span><span>)</span><span>;</span> <span>// 40</span>
    <span>printf</span><span>(</span><span>"cpu.eax: %d\n"</span><span>,</span> cpu<span>.</span>eax<span>)</span><span>;</span>      <span>// 666</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="bitfield"> bitfield</h3>
<p>只能在struct或union中声明。</p>
<div><pre><code><span>struct</span> <span>{</span>
      <span>/* field 4 bits wide */</span>
      <span>unsigned</span> field1 <span>:</span><span>4</span><span>;</span>
      <span>/*
       * unnamed 3 bit field
       * unnamed fields allow for padding
       */</span>
      <span>unsigned</span>        <span>:</span><span>3</span><span>;</span>
      <span>/*
       * one-bit field
       * can only be 0 or -1 in two's complement!
       */</span>
      <span>signed</span> field2   <span>:</span><span>1</span><span>;</span>
      <span>/* align next field on a storage unit */</span>
      <span>unsigned</span>        <span>:</span><span>0</span><span>;</span>
      <span>unsigned</span> field3 <span>:</span><span>6</span><span>;</span>
<span>}</span>full_of_fields<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>1bit的有符号bitfield只能表示0和-1.</li>
<li>bitfield可以用const，volatile修饰</li>
<li>C不能保证机器内的字段的排序。标准没有定义，取决于机器和编译器的实现。</li>
<li>要强制对准到存储单元边界，请在想要对齐的字段之前使用零宽度字段。</li>
<li>gcc可能是从LSB开始分配的。</li>
</ul>
<h2 id="getopt-int-argc-char-const-argv-const-char-optstring"> getopt(int argc, char* const argv[], const char* optstring)</h2>
<p>选项处理过程</p>
<div><pre><code><span>int</span> optind<span>;</span> <span>// argv中下一个要处理的元素的索引(初始为 1)</span>
<span>int</span> opterr<span>;</span> <span>// 是否输出错误信息</span>
<span>int</span> optopt<span>;</span> <span>// 导致错误的选项字符</span>
<span>char</span><span>*</span> optarg<span>;</span>

<span>struct</span> <span>option</span> <span>{</span>
    <span>const</span> <span>char</span> <span>*</span>name<span>;</span> <span>// 长选项(--option)的名称</span>
    <span>int</span> has_arg<span>;</span> <span>// 0:无参数 1:有参数 2:参数可选</span>
    <span>int</span> <span>*</span>flag<span>;</span> <span>// flag为NULL：getopt_long()返回val。否则getopt_long()返回0，flag指向的变量值为val(如果该option用户设置了的话)</span>
    <span>int</span> val<span>;</span> <span>// 返回值或放入flag</span>
<span>}</span><span>;</span> <span>// 结构体数组的最后一个元素必须设为0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>如果getopt()找到下一个选项字符，就返回那个字符，更新optind和一个static变量nextchar</p>
<p>optstring包含了所有合法的选项，如果字符后面跟着一个<code>:</code>，说明需要参数，两个说明是可选参数。<br>
如果选项中包含文本(-oarg, o 是选项，arg是文本)，则文本会保存在optarg中其他情况下，optarg设为0.
GNU扩展,optstring中的<code>W:</code>表示将<code>-W foo</code>看作<code>--foo</code>看待。</p>
<p>默认情况下,getopt()按输入顺序排列argv的内容。所以，所有的非选项参数放在最后。
optstring的首字符决定使用的模式</p>
<ul>
<li><code>+</code> 遇到任何一个非选项参数就终止选项处理</li>
<li><code>-</code> 强制将所有非选项参数看作选项的参数
<code>--</code> 在任何模式下都可以强行终止选项处理过程。</li>
</ul>
<p>Errors</p>
<ul>
<li>处理的选项不再optstring中</li>
<li>设置为有参数的选项没有检测到参数
处理</li>
<li>默认输出错误信息，将导致错误的选项字符放在optopt中，函数返回 ?</li>
<li>如果调用者将opterr设为0，则不会输出错误信息，函数仍返回 ?</li>
<li>如果optstring的第一个字符(不包括描述模式的<code>+,-</code>)为<code>:</code>。函数同样不输出错误信息，并且在设为有参数的选项没有参数时返回值变为<code>:</code>，从而可以区别出这种情况。</li>
</ul>
<p>getopt()返回值</p>
<ul>
<li>如果所有的命令行选项都处理完了，则返回 -1.</li>
<li>如果遇到没在optstring中指定的字符，返回 ?</li>
<li>如果遇到选项丢失参数的情况，看optstring中的第一个字符，如果是<code>:</code> 则返回 <code>:</code>，否则返回 ?</li>
</ul>
<p><code>int getopt_long(int argc, char* const argv[], const char* optstring, const struct option* longopts, int* longindex)</code></p>
<p>getopt_long(),getopt_long_only()</p>
<ul>
<li>当识别到短选项时，也返回值</li>
<li>长选项，见flag注释。</li>
<li>Error和-1和getopt()一样</li>
<li>识别到模糊匹配和冗余参数会返回 ?</li>
<li>longindex为longopts的索引，如果不为NULL的话</li>
</ul>
<h2 id="readline"> readline</h2>
<p><code>char* readline(const char* prompt)</code><br>
GNU的命令行编辑接口。readline会从终端读入一行并返回，其参数prompt为命令行开头的提示符(例如gdb中的&quot;(gdb)&quot;)。其返回值不包括换行符，仅保留输入的文本。另外返回值使用malloc分配内存的，调用者需要手动free。</p>
<h2 id="str系列"> str系列</h2>
<p>strtok</p>
<ul>
<li><code>char *strtok(char *str, const char *delim)</code>： 使用了static buffer，不是线程安全的。</li>
<li><code>char *strtok_r(char *str, const char *delim, char **saveptr)</code>: 多线程安全</li>
<li>这个函数用于将字符串分解为一系列非空token(子串)。第一次调用strtok时str是需要被分解的字符串，之后处理相同字符串时str必须为NULL。delim参数为用于分解的分隔符，可以指定多个字符为同一级分隔符。</li>
<li>strtok内部有一个指针，该指针决定了每个token的起点。第一次调用时指向str的第一个字符，第二次调用时指向第一个分割符后第一个不是分割符的字符，如果找不到这样的字符，strtok返回NULL。</li>
<li>每个token的终点为分隔符(会被替换为'\0')或null('\0')。</li>
<li>strtok的返回值要么是非空字符串，要么是NULL。(例如,'aaa;bbb'分隔符为';',顺序调用strtok的返回值为 'aaa', 'bbb', NULL)</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;string.h></span></span>

<span>int</span> <span>main</span><span>(</span><span>int</span> argc<span>,</span> <span>char</span> <span>const</span> <span>*</span>argv<span>[</span><span>]</span><span>)</span>
<span>{</span>
    <span>char</span> <span>*</span>str1<span>,</span> <span>*</span>str2<span>,</span> <span>*</span>token<span>,</span> <span>*</span>subtoken<span>;</span>
    <span>char</span> <span>*</span>savaptr1<span>,</span> <span>*</span>saveptr2<span>;</span>
    <span>int</span> j<span>;</span>
    <span>if</span> <span>(</span>argc <span>!=</span> <span>4</span><span>)</span>
    <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>"Usage: %s string delim subdelim\n"</span><span>,</span> argv<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span>EXIT_FAILURE<span>)</span><span>;</span>
    <span>}</span>

    <span>for</span> <span>(</span>j <span>=</span> <span>1</span><span>,</span> str1 <span>=</span> argv<span>[</span><span>1</span><span>]</span><span>;</span> <span>;</span>j<span>++</span><span>,</span> str1 <span>=</span> <span>NULL</span><span>)</span>
    <span>{</span>
        token <span>=</span> <span>strtok_r</span><span>(</span>str1<span>,</span> argv<span>[</span><span>2</span><span>]</span><span>,</span> <span>&amp;</span>savaptr1<span>)</span><span>;</span>
        <span>printf</span><span>(</span><span>"saveptr1 %d %s\n"</span><span>,</span> j<span>,</span> savaptr1<span>)</span><span>;</span> <span>// 剩余未处理的部分</span>
        <span>if</span> <span>(</span>token <span>==</span> <span>NULL</span><span>)</span>
            <span>break</span><span>;</span>
        <span>printf</span><span>(</span><span>"%d: %s\n"</span><span>,</span> j<span>,</span> token<span>)</span><span>;</span>

        <span>for</span> <span>(</span>str2 <span>=</span> token<span>;</span> <span>;</span> str2 <span>=</span> <span>NULL</span><span>)</span>
        <span>{</span>
            subtoken <span>=</span> <span>strtok_r</span><span>(</span>str2<span>,</span> argv<span>[</span><span>3</span><span>]</span><span>,</span> <span>&amp;</span>saveptr2<span>)</span><span>;</span>
            <span>if</span> <span>(</span>subtoken <span>==</span> <span>NULL</span><span>)</span>
                <span>break</span><span>;</span>
            <span>printf</span><span>(</span><span>" --> %s\n"</span><span>,</span> subtoken<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>exit</span><span>(</span>EXIT_SUCCESS<span>)</span><span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><ul>
<li><code>size_t strlen(const char *s)</code>:返回字符串的长度，即string中有多少byte。不包含'\0'。</li>
<li><code>size_t strnlen(const char *s, size_t max)</code>:返回字符串的长度，但不会超过最大值。</li>
<li><code>int strcmp(const char *s1, const char *s2)</code>: 比较两个字符串是否相等。逐字符比较，如果第一个不相等的字符s1 &lt; s2，则返回负值，反之返回正值。都相等则返回0。</li>
<li><code>int strncmp(const char *s1, const char *s2, size_t n)</code>:比较两个字符串是否相等，但只比前n个。</li>
<li><code>int strcoll(const char *s1, const char *s2)</code>:比较两个字符串是否相等，基于程序当前的locale设置解释的字符串,locale的值为环境变量LC_COLLATE。</li>
<li><code>char *strcpy(char *dest,const char *src)</code>: 复制字符串，包含最后的'\0'。dest需要足够大。返回dest指针。</li>
<li><code>char *strncpy(char *dest,const char *src, size_t n)</code>:将src的前n个字符复制到dest。注意如果前n个字符中没有'\0'，则dest也不会添加，导致dest没有正常的终止符。如果n&gt;strlen(src)+1，剩下的字符会用'\0'补全。</li>
<li><code>char *strcat(char *dest, const char *src)</code>: 将src(不包括'\0')连接到dest后，dest的'\0'会被覆盖，且会在整个字符串后添加一个'\0'。dest要足够大。</li>
<li><code>char *strncat(char *dest, const char *src, size_t n)</code>:类似strcat。但最多使用src中的n个字符。另外，src可以没有'\0'。</li>
</ul>
<h2 id="scanf系列-printf系列"> scanf系列&amp;printf系列</h2>
<ul>
<li>
<p><code>int scanf(const char *format, ...)</code></p>
</li>
<li>
<p><code>int fscanf(FILE *stream, const char *format, ...)</code></p>
</li>
<li>
<p><code>int sscanf(const char *str, const char *format, ...)</code></p>
</li>
<li>
<p><code>sprintf, snprintf, fprintf</code></p>
</li>
<li>
<p><code>int vscanf(const char *format, va_list ap)</code></p>
</li>
<li>
<p><code>int vfscanf(FILE *stream, const char *format, va_list ap)</code></p>
</li>
<li>
<p><code>int vsscanf(const char *str, const char *format, va_list ap)</code></p>
</li>
</ul>
<p>format可能包含转换规约(%m.nf)，转换的结果被储存在format后的指针中，指针的类型要可format中的转换规约一致。如果format中的%数量多于指针参数的数量，则结果未定义。反之，则多余的指针参数会被忽略。</p>
<ul>
<li>scanf从stdin读取输入。</li>
<li>fscanf从指定的文件流stream中读取输入。</li>
<li>sscanf从字符串str中读取输入。</li>
<li>加v的读取变量参数列表(a variable arguemnt list)</li>
</ul>
<p>返回值</p>
<ul>
<li>成功：返回匹配的转换数</li>
<li>失败：EOF</li>
</ul>
<p>PS：format可以是变量而非双引号字符串。例如：打印程序的命令行参数。</p>
<div><pre><code><span>while</span> <span>(</span><span>--</span>argc <span>></span> <span>0</span><span>)</span>
    <span>printf</span><span>(</span><span>(</span>argc <span>></span> <span>1</span><span>)</span> <span>?</span> <span>"%s "</span> <span>:</span> <span>"%s"</span><span>,</span> <span>*</span><span>++</span>argv<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="转换规约"> 转换规约</h3>
<p>格式：<code>%#.#char</code> 其中第一个#为maximum field width。即最多匹配|输出的字符数。.#表示保留的小数点位数。char为转换说明符。
printf的格式串中</p>
<ul>
<li>\NNN 最多3八进制数字，表示对应的ASCII字符</li>
<li>\xHH 最多两个十六进制数字，表示对应的ASCII字符</li>
<li>\uHHHH Unicode字符</li>
<li>\UHHHHHHHH Unicode字符</li>
</ul>
<p>输入</p>
<ul>
<li>%: 匹配%。</li>
<li>d: 匹配有符号十进制整数，对应的指针类型必须为int*。</li>
<li>i: 匹配有符号整数，对应的指针类型必须为int*。用于scanf，如果输入的整数以0x开头，则以16进制读，以0开头，则以8进制读，否则以十进制读。</li>
<li>o: 匹配无符号八进制整数。对应的指针类型必须为unsigned int*。</li>
<li>u: 匹配无符号十进制整数。对应的指针类型必须为unsigned int*。</li>
<li>x|X: 匹配无符号十六进制整数。对应的指针类型必须为unsigned int*。</li>
<li>f | e | E | g | a: 匹配浮点数。对应的指针类型必须为float*。</li>
<li>s: 匹配一连串字符，到空白符或字符数组满了(要留一个位置给自动加上的'\0')为止。对应的指针类型必须为char数组。</li>
<li>%.5s: 表示从给定字符串中最多读5个字符。</li>
<li>c: 匹配一个字符，不会加上'\0'。对应的指针类型必须为char*。</li>
<li>[char set]: 匹配指定字符集中的字符。对应的指针类型必须为char*。特殊字符<code>]</code>，要匹配它，必须将它放在<code>[</code>后，要排除它，则需放在<code>^</code>后。 <code>-</code>必须放在字符集的开头或结尾。</li>
<li>p: 匹配指针。对应的指针类型必须为void**。</li>
<li>n: 没看懂</li>
</ul>
<p>指针类型修改符</p>
<ul>
<li>
<p>h: 针对diouxXn,将指针类型改为short int 或 unsigned short int。</p>
</li>
<li>
<p>hh: signed char, unsigned char</p>
</li>
<li>
<p>j: intmax_t,uintmax_t</p>
</li>
<li>
<p>t: ptrdiff_t</p>
</li>
<li>
<p>z: size_t</p>
</li>
<li>
<p>l: signed long int, unsigned long int; 针对f,则指针类型变为double; 针对c,s，相关的指针类型被认为是wide charater?</p>
</li>
<li>
<p>L: signed long long int, unsigned long long int; long long double</p>
</li>
<li>
<p>m: %ms, %#mc 为输入字符串分配一块内存，指针类型改为char**。</p>
</li>
</ul>
<p>输出
<a href="https://alvinalexander.com/programming/printf-format-cheat-sheet/" target="_blank" rel="noopener noreferrer">一些使用示例</a></p>
<p>// FLag characters</p>
<ul>
<li>#: #必须紧跟在%后面，用于o，总是显示0####。用于x，总是显示0x####。用于[aAeEfFgG]，总是会显示小数点。注意：0,0x是被算进field  width的。</li>
<li>0: 不足的位在左边用0补足。如果指定了浮点数的精度，则被忽略。</li>
<li>-: 在maximum field width的左边界对齐。</li>
<li>' ': 空格。有符号正数最前面放一个空格。</li>
<li>+: 有符号正数前面加+。</li>
</ul>
<p>// Sing Unix Specification</p>
<ul>
<li>
<p>': 十进制数以千为单位加逗号。</p>
</li>
<li>
<p>I: idu, 使用本地对应的字符输出。</p>
</li>
<li>
<p>d,i:十进制有符号</p>
</li>
<li>
<p>o,u,x,X</p>
</li>
<li>
<p>e,E: [-]d.ddde[+-]dd</p>
</li>
<li>
<p>f,F: 常见小数形式</p>
</li>
<li>
<p>g,G: 看情况转换为f,e,F,G中的一种</p>
</li>
<li>
<p>a,A: 十六进制的小数形式0xh.hhhp[+-]</p>
</li>
<li>
<p>c</p>
</li>
<li>
<p>s</p>
</li>
<li>
<p>p</p>
</li>
<li>
<p>n</p>
</li>
<li>
<p>%</p>
</li>
</ul>
<h3 id="号"> *号</h3>
<div><pre><code><span>printf</span><span>(</span><span>"%*d"</span><span>,</span> <span>9</span><span>,</span> <span>123</span><span>)</span><span>;</span> <span>// '      1223'</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>*</code>在格式串中表示filed witdh和precision这两个部分使用下一个参数表示。<code>*</code>本身所在的<code>%</code>对应的参数则延后一位。<br>
在Single UNIX Specification中还有另一种等价表示。</p>
<div><pre><code><span>printf</span><span>(</span><span>"%2$*1$d"</span><span>,</span> <span>9</span><span>,</span> <span>123</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>其中<code>%2$</code>代替了<code>%</code>，<code>*2$</code>代替了<code>*</code>，<code>#$</code>代表使用对应的参数位置。值得一提的是，这种写法可以通过<code>#$</code>使用同一个变量。可惜，C99中没有这个功能。</p>
<h2 id="regex系列"> regex系列</h2>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;sys/types.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;regex.h></span></span>

<span>int</span> <span>regcomp</span><span>(</span><span>regex_t</span> <span>*</span>preg<span>,</span> <span>const</span> <span>char</span> <span>*</span>regex<span>,</span> <span>int</span> cflags<span>)</span><span>;</span>
<span>int</span> <span>regexec</span><span>(</span><span>const</span> <span>regex_t</span> <span>*</span>preg<span>,</span> <span>const</span> <span>char</span> <span>*</span>string<span>,</span> <span>size_t</span> nmatch<span>,</span>
            <span>regmatch_t</span> pmatch<span>[</span><span>]</span><span>,</span> <span>int</span> eflags<span>)</span><span>;</span>
<span>size_t</span> <span>regerror</span><span>(</span><span>int</span> errcode<span>,</span> <span>regex_t</span> <span>*</span>preg<span>,</span> <span>char</span> <span>*</span>errbuf<span>,</span> <span>size_t</span> errbuf_size<span>)</span><span>;</span>
<span>void</span> <span>regfree</span><span>(</span><span>regex_t</span> <span>*</span>preg<span>)</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>regoff_t</span> rm_so<span>;</span> <span>// 匹配的子串开头位置</span>
    <span>regoff_t</span> rm_eo<span>;</span> <span>// 匹配子串的结尾位置，相对于子串开头。</span>
<span>}</span> <span>regmatch_t</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>regcomp()用于将正则表达式编译为适用于后续regexec()搜索的形式。</p>
<ul>
<li>preg 指针指向pattern buffer的储存区域</li>
<li>regex 指针指向c风格字符串(the null-terminated string)</li>
<li>cflags 用于决定编译的类型
<ul>
<li>REG_EXTENDED：使用POSIX扩展的正则表达式语法</li>
<li>REG_ICASE: 忽略大小写</li>
<li>REG_NOSUB: 不比报告匹配的位置。regexec()中的nmatch, pmatch参数会被忽略。</li>
<li>REG_NEWLINE: <code>*</code>不会匹配 newline, <code>[^...]</code> 即使不包含newline，也不会匹配newline。紧跟在newline后<code>^</code>匹配空字符。newline前的<code>$</code>也立即匹配空字符。</li>
</ul>
</li>
<li>eflags
<ul>
<li>REG_NOTBOL: <code>^</code>总是匹配失败。常用于一大堆字符串被拆分为多个子串分别传入regexec()处理。</li>
<li>REG_NOTEOL: <code>$</code>总是匹配失败。</li>
</ul>
</li>
<li>nmatch 匹配几个</li>
<li>pmatch 匹配结果</li>
<li>regcomp()返回0表示成功编译，其他为错误码。regexec返回0表示匹配成功，REG_NOMATCH表示匹配失败，其他为错误码。</li>
</ul>
<p>所有的正则表达式的搜索都必须使用编译过的pattern buffer。因此regexec的preg参数必须是经过regcomp编译过的。
regerror()用于将regcomp()和regexec()的错误码转换为错误信息，存储在errbuf中。<br>
regfree()释放预编译的pattern buffer的内存。</p>
<h2 id="system"> system</h2>
<p><code>int system(const char *command);</code> 在 stdlib.h 中</p>
<p>使用fork(2)创建子进程使用execl(3)执行command: execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, (char *)NULL);</p>
<h2 id="popen-pclose"> popen/pclose</h2>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdio.h></span></span>
FILE <span>*</span><span>popen</span><span>(</span><span>const</span> <span>char</span> <span>*</span>command<span>,</span> <span>const</span> <span>char</span> <span>*</span>type<span>)</span><span>;</span>
<span>int</span> <span>pclose</span><span>(</span>FILE <span>*</span>stream<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>popen() 通过创建一个管道打开一个进程。因为管道是单向的，所以type只能是r或w。</li>
<li>popen() 的返回值是一个标准I/O流，必须用pclose()关闭。</li>
<li>popen() type=w时，向返回的流中写相当于向command的标准输入写。type=r时，从流中读，相当于从command的标准输出中读。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>宏</title>
      <link>https://kigane.github.io/note/cpp/macro/</link>
      <guid>https://kigane.github.io/note/cpp/macro/</guid>
      <source url="https://kigane.github.io/rss.xml">宏</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="预定义的宏"> 预定义的宏</h2>
<p>注意：不同的编译器宏的名称可能不同。</p>
<ul>
<li><code>__func__</code> 所在函数名</li>
<li><code>__FILE__</code> 所在文件名</li>
<li><code>__LINE__</code> 所在行数</li>
<li><code>__DATE__</code> 当前源文件的编译时间</li>
<li>``</li>
</ul>
<p><a href="https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-160" target="_blank" rel="noopener noreferrer">MSVC</a></p>
<h2 id="操作符"> #操作符</h2>
<ul>
<li>#x 用来把参数转换成字符串</li>
<li>a##b 将两个单独的符号合并成一个，且该符号必须是有效的。</li>
<li><code>## __VA_ARGS__</code> 这里##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&quot;,&quot;去掉的作用,否则会编译出错</li>
</ul>
<div><pre><code><span><span>#</span><span>define</span> <span>__T</span><span><span>(</span>x<span>)</span>  L </span><span>##</span> <span>x </span><span>// 如果x是字符串 "abc" 则__T(x) 相当于 L"abc"</span></span>

<span><span>#</span><span>define</span> <span>paster</span><span><span>(</span> n <span>)</span> <span>printf_s</span><span>(</span> </span><span>"token"</span> <span><span><span>#</span><span>n</span> </span></span><span>" = %d"</span><span><span>,</span> token</span><span>##</span><span>n <span>)</span></span></span>
<span>int</span> token9 <span>=</span> <span>9</span><span>;</span>
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
   <span>paster</span><span>(</span><span>9</span><span>)</span><span>;</span> <span>// 输出 token9 = 9</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="多行宏"> 多行宏</h2>
<p>对于复杂的多行宏。推荐的写法为</p>
<div><pre><code><span><span>#</span><span>define</span> <span>some_marco</span><span><span>(</span><span>)</span></span><span>\</span>
  <span><span>do</span> <span>{</span></span><span>\</span>
    <span>contents</span><span>\</span>
  <span><span>}</span> <span>while</span> <span>(</span><span>0</span><span>)</span></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><a href="https://stackoverflow.com/questions/1067226/c-multi-line-macro-do-while0-vs-scope-block" target="_blank" rel="noopener noreferrer">解释</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>C++ 小知识</title>
      <link>https://kigane.github.io/note/cpp/</link>
      <guid>https://kigane.github.io/note/cpp/</guid>
      <source url="https://kigane.github.io/rss.xml">C++ 小知识</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="lvalue-rvalue"> lvalue &amp; rvalue</h2>
<p>简单来说</p>
<ul>
<li>左值(lvalue)：是变量，占用某一块确定的内存。</li>
<li>右值(rvalue)：是字面量或临时量。</li>
</ul>
<div><pre><code><span>int</span> i <span>=</span> <span>10</span><span>;</span> <span>// i 是左值， 10 是右值(字面量) </span>
<span>int</span> a <span>=</span> i<span>;</span> <span>// a, i 都是左值</span>
<span>int</span> b <span>=</span> a <span>+</span> i<span>;</span> <span>// b 是左值，a+i 是右值(临时量)</span>

<span>int</span> <span>GetInt</span><span>(</span><span>)</span><span>{</span> <span>int</span> a <span>=</span> <span>7</span><span>;</span><span>return</span> a<span>;</span><span>}</span>    <span>// 返回值是右值</span>
<span>int</span><span>&amp;</span> <span>GetInt</span><span>(</span><span>int</span><span>&amp;</span> a<span>)</span><span>{</span> a <span>=</span> <span>7</span><span>;</span><span>return</span> a<span>;</span><span>}</span> <span>// 返回值是左值</span>

<span>// 有一些方法如下</span>
<span>void</span> <span>GetVal1</span><span>(</span><span>int</span> a<span>)</span><span>{</span>cout <span>&lt;&lt;</span> a<span>;</span><span>}</span>
<span>void</span> <span>GetVal2</span><span>(</span><span>int</span><span>&amp;</span> a<span>)</span><span>{</span>cout <span>&lt;&lt;</span> a<span>;</span><span>}</span>
<span>void</span> <span>GetVal3</span><span>(</span><span>const</span> <span>int</span><span>&amp;</span> a<span>)</span><span>{</span>cout <span>&lt;&lt;</span> a<span>;</span><span>}</span>
<span>void</span> <span>GetVal4</span><span>(</span><span>int</span><span>&amp;&amp;</span> a<span>)</span><span>{</span>cout <span>&lt;&lt;</span> a<span>;</span><span>}</span>

<span>GetVal1</span><span>(</span>a<span>+</span>i<span>)</span><span>;</span> <span>// 正常</span>
<span>GetVal2</span><span>(</span>a<span>+</span>i<span>)</span><span>;</span> <span>// 编译错误，非常量引用的初始值必须为左值</span>
<span>GetVal3</span><span>(</span>a<span>+</span>i<span>)</span><span>;</span> <span>// 正常。常量引用的初始值可以是左值，也可以是右值 ==> 所以字符串参数常常声明为常量引用。</span>
<span>GetVal4</span><span>(</span>a<span>+</span>i<span>)</span><span>;</span> <span>// 正常。&amp;&amp; 表示右值引用。</span>
<span>GetVal4</span><span>(</span>b<span>)</span><span>;</span> <span>// 编译错误，无法将右值引用绑定到左值。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>有啥好处呢？好处在于可以通过重载函数，区分出传入的参数是不是临时的，因此可以做一些特殊处理。</p>
<div><pre><code><span>// 可以接受左值和右值</span>
<span>void</span> <span>PrintName</span><span>(</span><span>const</span> string<span>&amp;</span> name<span>)</span><span>{</span>cout <span>&lt;&lt;</span> <span>"[lvalue]"</span> <span>&lt;&lt;</span> name<span>;</span><span>}</span>
<span>// 对于右值，有特殊重载</span>
<span>void</span> <span>PrintName</span><span>(</span>string<span>&amp;&amp;</span> name<span>)</span><span>{</span>cout <span>&lt;&lt;</span> <span>"[rvalue]"</span> <span>&lt;&lt;</span> name<span>;</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="移动语义-move-semantics"> 移动语义(move semantics)</h2>
<p>先看一个例子</p>
<div><pre><code><span>class</span> <span>String</span>
<span>{</span>
<span>public</span><span>:</span>
    <span>String</span><span>(</span><span>)</span> <span>=</span> <span>default</span><span>;</span>
    <span>String</span><span>(</span><span>const</span> <span>char</span><span>*</span> str<span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"Created!\n"</span><span>)</span><span>;</span>
        m_Size <span>=</span> <span>strlen</span><span>(</span>str<span>)</span><span>;</span>
        m_Data <span>=</span> <span>new</span> <span>char</span><span>[</span>m_Size<span>]</span><span>;</span>
        <span>memcpy</span><span>(</span>m_Data<span>,</span> str<span>,</span> m_Size<span>)</span><span>;</span>
    <span>}</span>

    <span>String</span><span>(</span><span>const</span> String<span>&amp;</span> other<span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"Copied!\n"</span><span>)</span><span>;</span>
        m_Size <span>=</span> other<span>.</span>m_Size<span>;</span>
        m_Data <span>=</span> <span>new</span> <span>char</span><span>[</span>m_Size<span>]</span><span>;</span>
        <span>memcpy</span><span>(</span>m_Data<span>,</span> other<span>.</span>m_Data<span>,</span> m_Size<span>)</span><span>;</span>
    <span>}</span>

    <span>~</span><span>String</span><span>(</span><span>)</span>
    <span>{</span>
        <span>printf</span><span>(</span><span>"Deleted!\n"</span><span>)</span><span>;</span>
        <span>delete</span> m_Data<span>;</span>
    <span>}</span> 

    <span>void</span> <span>Print</span><span>(</span><span>)</span>
    <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> m_Size<span>;</span> <span>++</span>i<span>)</span>
            <span>printf</span><span>(</span><span>"%c"</span><span>,</span> m_Data<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>printf</span><span>(</span><span>"\n"</span><span>)</span><span>;</span>
    <span>}</span>
<span>private</span><span>:</span>
    <span>int</span> m_Size<span>;</span>
    <span>char</span><span>*</span> m_Data<span>;</span>
<span>}</span><span>;</span>

<span>class</span> <span>Entity</span>
<span>{</span>
<span>public</span><span>:</span>
    <span>Entity</span><span>(</span><span>)</span> <span>=</span> <span>default</span><span>;</span>
    <span>Entity</span><span>(</span><span>const</span> String<span>&amp;</span> name<span>)</span> <span>:</span> <span>m_Name</span><span>(</span>name<span>)</span> <span>{</span><span>}</span>
    <span>void</span> <span>PrintName</span><span>(</span><span>)</span><span>{</span> m_Name<span>.</span><span>Print</span><span>(</span><span>)</span><span>;</span> <span>}</span>
<span>private</span><span>:</span>
    String m_Name<span>;</span>
<span>}</span><span>;</span>

<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    Entity <span>entity</span><span>(</span><span>"Sekiro"</span><span>)</span><span>;</span>
    entity<span>.</span><span>PrintName</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>执行结果为：</p>
<div><pre><code>Created!
Copied!
Deleted!
Sekiro
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这意味着，在Entity(String name)的初始化列表中，为右值&quot;Sekiro&quot;调用String的相应构造函数，再调用String的拷贝构造函数，将其值传入Entity.m_Name，最后销毁保存&quot;Sekiro&quot;的临时对象。
一个简单的赋值操作，竟调用了两次构造函数，在堆上分配了两次内存。问题很大🤔。</p>
<p>解决方法是，对于传入的右值做特殊处理，在构造出来临时对象后，直接赋值，不要再调用拷贝构造函数。</p>
<div><pre><code><span>// 在String中添加</span>
<span>String</span><span>(</span>String<span>&amp;&amp;</span> other<span>)</span> <span>noexcept</span>
<span>{</span>
    <span>printf</span><span>(</span><span>"Moved!\n"</span><span>)</span><span>;</span>
    m_Size <span>=</span> other<span>.</span>m_Size<span>;</span>
    m_Data <span>=</span> other<span>.</span>m_Data<span>;</span>

    <span>// 临时变量会被销毁，所以需要防止析构时删除数据</span>
    other<span>.</span>m_Data <span>=</span> <span>nullptr</span><span>;</span>
    other<span>.</span>m_Size <span>=</span> <span>0</span><span>;</span>
<span>}</span>

<span>// 在 Entity 中修改 std::move(name) 相当于 (String&amp;&amp;) name</span>
<span>Entity</span><span>(</span><span>const</span> String<span>&amp;</span> name<span>)</span> <span>:</span> <span>m_Name</span><span>(</span>std<span>::</span><span>move</span><span>(</span>name<span>)</span><span>)</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>现在执行结果为</p>
<div><pre><code>Created!
Moved!
Deleted!
Sekiro
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>节省了一次堆内存分配。</p>
<h2 id="inline"> inline</h2>
<p>直接在类中声明并实现的方法是隐式的inline函数，不需要再加inline前缀。</p>
<h2 id="constexpr"> constexpr</h2>
<p>指明变量或函数的值可以出现在常量表达式中。通过添加constexpr来声明的变量或函数，可以在编译期进行计算。</p>
<ul>
<li>literal type: 标量类型，引用类型，以及前两种的数组类型。(C++20还可能有更多)</li>
<li>constexpr 变量，函数返回值和参数类型必须是literal type。</li>
<li>inline是将函数体直接搬过来，减少函数调用的开销。constexpr是直接将编译器可计算的结果算出来，来减少调用，执行函数的开销。</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span><span>&lt;iostream></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
  
<span>constexpr</span> <span>long</span> <span>int</span> <span>fib</span><span>(</span><span>int</span> n<span>)</span>
<span>{</span>
    <span>return</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span><span>?</span> n <span>:</span> <span>fib</span><span>(</span>n<span>-</span><span>1</span><span>)</span> <span>+</span> <span>fib</span><span>(</span>n<span>-</span><span>2</span><span>)</span><span>;</span>
<span>}</span>
  
<span>int</span> <span>main</span> <span>(</span><span>)</span>
<span>{</span>
    <span>// value of res is computed at compile time. 执行的非常快。</span>
    <span>const</span> <span>long</span> <span>int</span> res <span>=</span> <span>fib</span><span>(</span><span>30</span><span>)</span><span>;</span> 
    cout <span>&lt;&lt;</span> res<span>;</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="可变参数"> 可变参数</h2>
<ul>
<li>在 stdarg.h 中</li>
<li>va_list 为存储可变参数的类型。即function中的 <code>...</code></li>
<li>va_start() 宏。有两个参数，第一个为va_list类型的变量，第二个为可变参数<code>...</code>的前一个参数。用于初始化可变参数列表。</li>
<li>va_arg() 宏。有两个参数，第一个为va_list类型的变量，第二个为用于接受可变参数的类型。用于获取可变参数列表中的下一个参数。(PS:printf的format string就是用于确定va_arg需要处理的变量类型。)</li>
<li>va_end() 宏。一个参数，为va_list类型的变量。用于清理va_list</li>
</ul>
<p>示例：</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdarg.h></span></span>
<span>double</span> <span>avg</span><span>(</span><span>int</span> num<span>,</span> <span>.</span><span>.</span><span>.</span><span>)</span>
<span>{</span>
    va_list args<span>;</span>
    <span>double</span> sum <span>=</span> <span>0</span><span>;</span>
    <span>va_start</span><span>(</span>args<span>,</span> num<span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>;</span> <span>++</span>i<span>)</span>
    <span>{</span>
        sum <span>+=</span> <span>va_arg</span><span>(</span>args<span>,</span> <span>double</span><span>)</span><span>;</span>
    <span>}</span>
    <span>va_end</span><span>(</span>args<span>)</span><span>;</span>
    <span>return</span> sum <span>/</span> num<span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> argc<span>,</span> <span>const</span> <span>char</span><span>*</span> argv<span>[</span><span>]</span><span>)</span>
<span>{</span>
    <span>printf</span><span>(</span><span>"average = %4.2f\n"</span><span>,</span> <span>avg</span><span>(</span><span>3</span><span>,</span> <span>1.2</span><span>,</span> <span>3.4</span><span>,</span> <span>5.6</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>PS: float在通过<code>...</code>传递时，会被提升为double。如果用float接收，程序会abort。</p>
]]></content:encoded>
    </item>
    <item>
      <title>C/C++ 文件 IO</title>
      <link>https://kigane.github.io/note/cpp/file-io/</link>
      <guid>https://kigane.github.io/note/cpp/file-io/</guid>
      <source url="https://kigane.github.io/rss.xml">C/C++ 文件 IO</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="c"> C</h2>
<h3 id="读写"> 读写</h3>
<p>C提供两种访问文件的途径：二进制模式和文本模式。二进制模式中打开的文件一个字节都不会变，而文本模式中打开的文件中的行末尾和文件末尾会被映射为C模式(行尾:\n, 文件末尾: EOF)。</p>
<p>模式串</p>
<ul>
<li>r 读</li>
<li>w 写。如果文件不存在，会创建新文件。如果文件存在，会先删除文件内容。</li>
<li>a 写，添加。如果文件不存在，会创建新文件。</li>
<li><code>+</code> 后缀，表示以更新模式打开，可读可写。但有一些规则
<ul>
<li>从读模式转换到写模式前，需要先调用一个文件定位函数，或遇到EOF</li>
<li>从写模式转换到读模式前，必须先调用fflush函数</li>
</ul>
</li>
<li>b 后缀，表示以二进制模式打开</li>
<li>x 后缀，C11</li>
</ul>
<p>stdio.h头文件中包含stdin,stdout,stderr三个标准流文件的文件指针。</p>
<ul>
<li>FILE *fopen(const char *filename, const char *mode);</li>
<li>int fclose(FILE *stream);</li>
<li>FILE *freopen(const char *filename, const char *mode, FILE *stream); // 将stream流重定向到文件。常用：freopen(&quot;foo&quot;, &quot;w&quot;, stdout);</li>
</ul>
<hr>
<ul>
<li>int putc(int c, FILE *stream); // 向stream写入一个字符c，用int而非char是因为EOF是一个负的整数常量。</li>
<li>int fputc(int c, FILE *stream); // 功能同putc。但putc是宏，fputc是函数。通常putc更快。</li>
<li>int putchar(int c); // 将一个字符放入stdout</li>
<li>int fputs(const char *s, FILE *stream); // 向stream写入一行字符c。不会自动加换行符</li>
<li>int puts(const char *s); // 将一行字符放入stdout。会自动加换行符。</li>
</ul>
<hr>
<ul>
<li>int getc(FILE *stream); // 从stream读入一个字符。宏</li>
<li>int fgetc(FILE *stream); // 从stream读入一个字符。函数</li>
<li>int getchar(void) // 从stdin读入一个字符</li>
<li>int ungetc(int c, FILE *stream); // 将一个字符放回stream。只有第一次调用保证会成功。</li>
<li>char *fgets(char *s, int n, FILE *stream); // 从stream读入一行字符c。最多读取n-1个。不会丢弃换行符，但可能没读到。</li>
<li>char *gets(char *s); // 从stdin读入一行字符。自动丢弃换行符。
注意：以上get函数在遇到问题时行为一样。遇到文件末尾，返回EOF，并设置流的文件末尾指示器。遇到读错误，返回EOF，并设置流的错误指示器。可用<code>int feof(FILE *fp),int ferror(FILE *fp)</code>函数区分这两种情况。</li>
</ul>
<hr>
<p>主要用于二进制流</p>
<ul>
<li>size_t fwrite(const void *ptr, size_t size, size_t elnum, FILE *stream); // 把内存中的数组复制给流。ptr为数组地址，size为数组元素的大小(B)，elnum为数组元素数量。stream为写入的流。返回实际写入的<strong>元素</strong>数量</li>
<li>size_t fread(void *ptr, size_t size, size_t elnum, FILE *stream); // 读入。返回值为实际读入的元素数量，应等于elnum</li>
<li>不一定非得是数组，结构体也行。</li>
<li>示例1: fwrite(arr, sizeof(a[0]), sizeof(a)/sizeof(a[0]), fp); // 写数组</li>
<li>示例2: fwrite(&amp;s, sizeof(s), 1, fp); // 写结构体</li>
</ul>
<hr>
<p>文件定位(适合二进制流)</p>
<ul>
<li>
<p>int fseek(FILE *stream, long int offset, int whence);</p>
<ul>
<li>whence SEEK_SET, SEEK_CUR, SEEK_END 代表新位置的计算起点。</li>
<li>offset 可以为负。和whence共同确定pos。</li>
<li>移动到文件开头 fseek(fp, 0L, SEEK_SET)</li>
<li>移动到文件末尾 fseek(fp, 0L, SEEK_END)</li>
<li>往回移动10个字节 fseek(fp, -10L, SEEK_CUR)</li>
</ul>
</li>
<li>
<p>long int ftell(FILE *stream); // 返回当前pos。错误时，返回-1L，错误码在errno中。0表示文件起始，其他整数表示当前pos所在的字节数。</p>
</li>
<li>
<p>void rewind(FILE *stream); // 把pos设为0，且会清除fp的错误指示器。 类似fseek(fp, 0L, SEEK_SET)</p>
</li>
<li>
<p>int fgetpos(FILE *stream, fpos_t *pos); // 用于超大文件。fpos_t是一个结构，可储存超过long int可表示的数的位置。</p>
</li>
<li>
<p>int fsetpos(FILE *stream, const fpos_t *pos);</p>
</li>
</ul>
<h3 id="临时文件"> 临时文件</h3>
<ul>
<li>FILE *tmpfile(void); // &quot;wb+&quot;</li>
<li>char *tmpnam(char *s); // 写入内容后才生成
<ul>
<li>参数为NULL时，会自动生成一个文件名，将文件名存储在静态变量中，并返回其指针。</li>
<li>否则，会把文件名复制到程序员提供的字符数组中。L_tmpnam宏为临时文件名的字符数组长度。</li>
</ul>
</li>
</ul>
<h3 id="文件缓冲"> 文件缓冲</h3>
<ul>
<li>int fflush(FILE *stream); // 强制刷新</li>
<li>void setbuf(FILE *stream, char *buf); // 等价于(void) setvbuf(stream, NULL, _IONBF, 0) 或 (void) setvbuf(stream, buf, _IOFBF, BUFSIZ)</li>
<li>int setvbuf(FILE *stream, char *buf, int mode, size_t size);
<ul>
<li>缓冲mode有三种
<ul>
<li>_IOFBF 满缓冲 缓冲区满时刷新。默认设置</li>
<li>_IOLBF 行缓冲 没读/写一行就刷新</li>
<li>_IONBF 无缓冲 没有缓冲区</li>
</ul>
</li>
<li>buf 是缓冲区。为NULL时，setvbuf会创建一个size大小的缓冲区。</li>
<li>size 是缓冲区的大小(Byte)</li>
</ul>
</li>
</ul>
<p>通常，缓冲是后台发生的，向文件写数据时，数据先放入缓冲区。当缓冲区满或关闭文件时，缓冲区会自动flush(即将数据写入磁盘)。</p>
<h3 id="其他文件操作"> 其他文件操作</h3>
<ul>
<li>int remove(const char *filename);</li>
<li>int rename(const char *old, const char *new);</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>计算机概述</title>
      <link>https://kigane.github.io/note/cs/</link>
      <guid>https://kigane.github.io/note/cs/</guid>
      <source url="https://kigane.github.io/rss.xml">计算机概述</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
    </item>
    <item>
      <title>随机数</title>
      <link>https://kigane.github.io/note/cpp/cpp-random/</link>
      <guid>https://kigane.github.io/note/cpp/cpp-random/</guid>
      <source url="https://kigane.github.io/rss.xml">随机数</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="线性同余法"> 线性同余法</h2>
<div><pre><code><span>unsigned</span> <span>int</span> <span>PRNG</span><span>(</span><span>)</span> <span>// pseudo-random number generator</span>
<span>{</span>
    <span>static</span> <span>unsigned</span> <span>int</span> seed<span>{</span><span>5323</span><span>}</span><span>;</span>
    seed <span>=</span> <span>8253729</span> <span>*</span> seed <span>+</span> <span>2396403</span><span>;</span>
    <span>return</span> seed <span>%</span> <span>32768</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>原理大致如上。这样简单的随机数不够&quot;好&quot;。</p>
<h2 id="c-标准库中的随机数生成"> C 标准库中的随机数生成</h2>
<p>原理就是线性同余法，不同编译器实现略有不同，且大多有缺陷。仅供学习使用。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;cstdlib></span> <span>// for std::rand() and std::srand()</span></span>
<span><span>#</span><span>include</span> <span>&lt;ctime></span> <span>// for std::time()</span></span>

<span>void</span> <span>PrintNumbersWithRand</span><span>(</span><span>)</span>
<span>{</span>
    std<span>::</span><span>srand</span><span>(</span><span><span>static_cast</span><span><span>&lt;</span><span>unsigned</span> <span>int</span><span>></span></span></span><span>(</span>std<span>::</span><span>time</span><span>(</span><span>nullptr</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>// 因为某些编译器中rand算法的缺陷，导致第一个随机数大概率相同，所以这里先调用一次去掉第一个</span>
    std<span>::</span><span>rand</span><span>(</span><span>)</span><span>;</span>

    <span>// 打印 100 个随机数</span>
    <span>for</span> <span>(</span><span>int</span> count<span>{</span><span>1</span><span>}</span><span>;</span> count <span>&lt;=</span> <span>100</span><span>;</span> <span>++</span>count<span>)</span>
    <span>{</span>
        std<span>::</span>cout <span>&lt;&lt;</span> std<span>::</span><span>rand</span><span>(</span><span>)</span> <span>&lt;&lt;</span> <span>'\t'</span><span>;</span>

        <span>if</span> <span>(</span>count <span>%</span> <span>5</span> <span>==</span> <span>0</span><span>)</span>
            std<span>::</span>cout <span>&lt;&lt;</span> <span>'\n'</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="一个好的伪随机数生成器-prng-的标准"> 一个好的伪随机数生成器(PRNG)的标准</h2>
<ul>
<li>应该以大致相同的概率生成每个数字(生成六个数字5,6,7,8,9的概率大致相等)，即数字分布均匀性。</li>
<li>生成序列中的下一个数字应该是不可预测。(num = num + 1)</li>
<li>生成的数字序列应该有良好的空间分布(生成0-9之间的随机数，不能只生成5,6,7,8,9，生成的数落在大，中，小范围内的概率也应大致相当)，即空间分布均匀性。</li>
<li>所有的PRNG都有周期性。通常，周期越大越好。</li>
</ul>
<h2 id="更好的随机数生成器"> 更好的随机数生成器</h2>
<p>使用梅森旋转演算法(Mersenne Twister)。在C++11中引入。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>
<span><span>#</span><span>include</span> <span>&lt;random></span> <span>// for std::mt19937</span></span>
<span><span>#</span><span>include</span> <span>&lt;ctime></span> <span>// for std::time</span></span>
 
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	<span>// 初始化 mersenne twister，将时间作为 seed。</span>
	std<span>::</span>mt19937 mersenne<span>{</span> <span><span>static_cast</span><span><span>&lt;</span>std<span>::</span>mt19937<span>::</span>result_type<span>></span></span></span><span>(</span>std<span>::</span><span>time</span><span>(</span><span>nullptr</span><span>)</span><span>)</span> <span>}</span><span>;</span>
 
	<span>// 生成 1-6 之间随机整数的PRNG</span>
	std<span>::</span>uniform_int_distribution die<span>{</span> <span>1</span><span>,</span> <span>6</span> <span>}</span><span>;</span> <span>// C++17</span>
	<span>// std::uniform_int_distribution&lt;> die{ 1, 6 }; // C++11</span>
 
	<span>for</span> <span>(</span><span>int</span> count<span>{</span> <span>1</span> <span>}</span><span>;</span> count <span>&lt;=</span> <span>48</span><span>;</span> <span>++</span>count<span>)</span>
	<span>{</span>
		std<span>::</span>cout <span>&lt;&lt;</span> <span>die</span><span>(</span>mersenne<span>)</span> <span>&lt;&lt;</span> <span>'\t'</span><span>;</span>

		<span>if</span> <span>(</span>count <span>%</span> <span>6</span> <span>==</span> <span>0</span><span>)</span>
			std<span>::</span>cout <span>&lt;&lt;</span> <span>'\n'</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="effolkronium-s-random-library"> Effolkronium’s random library.</h2>
<p>一个随机数库(纯头文件)。提供了便于使用的API。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>
<span><span>#</span><span>include</span> <span>"random.hpp"</span></span>
 
<span>// get base random alias which is auto seeded and has static API and internal state</span>
<span>using</span> Random <span>=</span> effolkronium<span>::</span>random_static<span>;</span>
 
<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
	std<span>::</span>cout <span>&lt;&lt;</span> <span>Random</span><span>::</span><span>get</span><span>(</span><span>1</span><span>,</span> <span>6</span><span>)</span> <span>&lt;&lt;</span> <span>'\n'</span><span>;</span>
	std<span>::</span>cout <span>&lt;&lt;</span> <span>Random</span><span>::</span><span>get</span><span>(</span><span>1</span><span>,</span> <span>10</span><span>)</span> <span>&lt;&lt;</span> <span>'\n'</span><span>;</span>
    <span>// decltype(val) is long double</span>
	<span>auto</span> val <span>=</span> <span>Random</span><span>::</span><span>get</span><span>(</span><span>1.l</span><span>,</span> <span>-</span><span>1.l</span><span>)</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>异常控制流</title>
      <link>https://kigane.github.io/note/cs/ECF/</link>
      <guid>https://kigane.github.io/note/cs/ECF/</guid>
      <source url="https://kigane.github.io/rss.xml">异常控制流</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="异常"> 异常</h2>
<h3 id="异常和异常处理"> 异常和异常处理</h3>
<ul>
<li>异常(exception)：就是控制流中的突变，用来相应处理器状态中的某些变化。</li>
<li>事件(event)：即状态变化。在处理器中，状态被编码为不同的位和信号。</li>
<li>异常号(exception number)：系统为每种类型的异常分配的唯一的非负整数标识。</li>
<li>异常表(exception table)：当处理器检测到事件发生时，会通过该表调用相应的异常处理程序。其起始地址位于一个特殊的CPU寄存器--异常表基址寄存器。在系统启动时，由操作系统分配和初始化。</li>
<li>在异常处理程序完成后，根据事件的类型，处理程序的处理方式不同。</li>
</ul>
<h3 id="异常的类别"> 异常的类别</h3>
<ul>
<li>中断(interrupt):是由硬件造成的，即来自处理器外部的I/O设备的信号的结果。因此，是异步的。从中断返回时，总是返回到下一条指令。(过程：执行<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.07847em;">I</span><span><span><span><span style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>c</span><span>u</span><span style="margin-right:0.02778em;">rr</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，发生中断，执行完<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.07847em;">I</span><span><span><span><span style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>c</span><span>u</span><span style="margin-right:0.02778em;">rr</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，调用中断处理程序，处理程序返回到下一条指令<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.07847em;">I</span><span><span><span><span style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>n</span><span>e</span><span>x</span><span>t</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li>
<li>陷阱(trap)：是有意的异常。用于为用户程序和内核之间提供系统调用，让用户程序可以向内核请求服务。具体而言，用户执行<code>syscall n</code>指令，会触发一个trap，trap的处理程序解析参数，并调用适当的内核程序。另外：系统调用运行与内核模式。</li>
<li>故障(fault)：由可能能被错误处理程序修正的错误引起。如果故障处理程序能修正(如缺页异常)，则返回<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.07847em;">I</span><span><span><span><span style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>c</span><span>u</span><span style="margin-right:0.02778em;">rr</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并重新执行这个引起异常的指令，如果无法修正(如除零，段错误)，则调用内核的abort例程，终止该程序。</li>
<li>终止(abort)：由不可恢复的致命错误引起，通常是硬件错误。调用内核的abort例程，终止该程序。</li>
</ul>
<details><summary>Linux异常和系统调用</summary>
<ul>
<li>除法错误(0)：除零或除法溢出时发生。Unix不会从除法错误中恢复，而是会终止程序。Linux shell会报告&quot;Floating exception&quot;。</li>
<li>一般保护故障(13)：原因很多，通常是因为程序引用的未定义的虚拟内存区域或试图写一个只读的文本段。Linux不会恢复这类故障，会终止程序并报告&quot;Segmentation fault&quot;。</li>
<li>缺页异常：//TODO</li>
</ul>
<p>系统调用:syscall</p>
<ul>
<li>系统调用时，%rax保存系统调用号，%rdi,%rsi,%rdx,%r10,%r8,%r9顺序包含最多6个参数。系统调用返回时，%rcx,%r11会被破坏，%rax包含返回值。返回值为负(-4095~-1)，说明发生了错误，会设置相应的errno。</li>
<li>常用系统调用
<ul>
<li>0 read 读文件</li>
<li>1 write 写文件</li>
<li>2 open 打开文件</li>
<li>3 close 关闭文件</li>
<li>4 stat 获取文件信息</li>
<li>9 mmap 将内存页映射到文件</li>
<li>12 brk 重置堆顶</li>
<li>32 dup2 复制文件描述符</li>
<li>33 pause 挂起进程，直到有信号到达</li>
<li>37 alarm 设置定时器，时间到了发送一个alarm信号给进程，默认行为会终止进程</li>
<li>39 getpid 获取进程ID</li>
<li>57 fork 创建进程</li>
<li>59 execve 执行一个程序</li>
<li>60 _exit 终止进程</li>
<li>61 wait4 等待一个进程终止</li>
<li>62 kill 向一个进程发送一个信号</li>
</ul>
</li>
</ul>
</details>
<h2 id="进程"> 进程</h2>
<ul>
<li>经典定义：一个执行中的程序的实例。</li>
<li>上下文(context)：程序正确运行所需的状态。包括内存中程序的的代码和数据，栈，GPRs，PC，环境变量以及打开的文件描述符的集合。</li>
<li>进程为应用程序提供的关键抽象：
<ul>
<li>一个独立的逻辑控制流</li>
<li>一个私有的地址空间</li>
</ul>
</li>
</ul>
<h3 id="逻辑控制流"> 逻辑控制流</h3>
<p>即执行程序的PC值的序列。
<img src="/assets/img/csapp-ecf-01.png" alt="ECF01" /><br>
关键点：进程是轮流使用处理器的，每个进程执行其流的一部分，然后被preempted(暂时挂起)，然后轮到其他进程。</p>
<h3 id="并发"> 并发</h3>
<ul>
<li>一个逻辑流的执行在<strong>时间上</strong>与另一个流重叠，称为并发流(concurrent flow)，这两个流被称为并发的执行。</li>
<li>并发(concurrency)：多个流并发的执行。</li>
<li>多任务(multitask)：一个进程和其他进程轮流运行。</li>
<li>时间片(time slice)：一个进程执行其逻辑控制流的一部分的每一时间段。</li>
<li>并行流(parallel flow)：两个流并发地运行在不同的处理器或计算机上。并行流是并发流的真子集。</li>
</ul>
<h3 id="私有地址空间"> 私有地址空间</h3>
<p><img src="/assets/img/csapp-ecf-02.png" alt="ECF02" /><br>
进程为每个程序提供私有地址空间。通用结构如图。</p>
<h3 id="用户模式和内核模式"> 用户模式和内核模式</h3>
<p>用户模式是处理器提供的一种机制，限制应用可以执行的指令和可访问的地址空间范围，即不能使用特权指令和访问地址空间中的内核区。处理器通过某状态寄存器中的一个模式位(mode bit)确定进程处于用户模式还是内核模式。</p>
<ul>
<li>特权指令(privileged instruction)：如停止处理器，改变模式位，发起I/O操作。</li>
<li>用户只能通过系统调用接口间接访问内核的代码和数据。任何直接访问的尝试都会导致abort。</li>
<li>进程从用户模式切换到内核模式的唯一方式是使用interrupt,fault,trap的异常处理程序。异常发生时，会调用异常处理程序，异常处理程序运行于内核模式中。异常处理程序返回后，就切换回用户模式。</li>
<li>Linux中
<ul>
<li>/proc文件系统提供许多用户可以访问的内核数据结构。如/proc/cpuinfo,/proc/:pid/maps(进程使用的内存段)</li>
<li>/sys文件系统提供关于系统总线和设备的低层信息。</li>
</ul>
</li>
</ul>
<h3 id="上下文切换"> 上下文切换</h3>
<ul>
<li>进程上下文
<ul>
<li>用户级上下文：程序块，数据块，用户堆栈</li>
<li>系统级上下文：
<ul>
<li>进程标识信息 pid</li>
<li>进程现场信息：寄存器内容(GPRs，浮点寄存器，某些状态寄存器)</li>
<li>进程控制信息：PC，某些状态寄存器</li>
<li>内核：内核栈和内核数据结构，包括页表，进程表，文件表。</li>
</ul>
</li>
</ul>
</li>
<li>上下文切换
<ul>
<li>保存当前进程上下文</li>
<li>恢复被切换到的进程的上下文</li>
<li>将控制转移给新进程</li>
</ul>
</li>
<li>上下文切换时机
<ul>
<li>内核执行系统调用时。系统调用发起I/O请求，或使用sleep系统调用等等。</li>
<li>系统周期性中断。所有系统都有某种产生周期性定时器中断的机制，通常为1或10ms。每次发生定时器中断，内核就能判定出当前进程已经运行了足够长的时间，并切换到另一个进程。</li>
</ul>
</li>
</ul>
<h2 id="系统调用错误处理"> 系统调用错误处理</h2>
<p>Unix系统级函数出错时，会返回-1，并设置全局整数变量errno来表示什么出错了。<code>strerrno(errno)</code>返回错误的具体描述。</p>
<div><pre><code><span>void</span> <span>unix_error</span><span>(</span><span>char</span> <span>*</span>msg<span>)</span> <span>{</span>
    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>"%s, %s\n"</span><span>,</span> msg<span>,</span> <span>strerr</span><span>(</span>errno<span>)</span><span>)</span><span>;</span>
    <span>exit</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>// fork 的错误包装函数</span>
<span>pid_t</span> <span>Fork</span><span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>pid_t</span> pid<span>;</span>
    <span>if</span> <span>(</span>pid <span>=</span> <span>fork</span><span>(</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span>
        <span>unix_error</span><span>(</span><span>"Fork error"</span><span>)</span><span>;</span>
    <span>return</span> pid<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="进程控制"> 进程控制</h2>
<ul>
<li>每个进程都有一个唯一的正整数进程 ID(PID)。</li>
<li>每个进程都只属于一个进程组，进程组也是用一个正整数 ID 来标识的。默认的，子进程和父进程同属于一个进程组。</li>
<li>进程的三种状态
<ul>
<li>运行：进程正在 CPU 上执行，或在等待被执行且最终会被调度。</li>
<li>停止：进程被挂起(suspended)，不会被调度。
<ul>
<li>会导致停止的信号：SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU</li>
<li>进程再次运行信号：SIGCONT</li>
</ul>
</li>
<li>终止：进程永远停止。进程终止有三种原因
<ul>
<li>收到一个默认行为是终止进程的信号</li>
<li>从主程序返回</li>
<li>调用exit()函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;sys/types.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;unistd.h></span></span>
<span>pid_t</span> <span>getpid</span><span>(</span><span>void</span><span>)</span><span>;</span> <span>// 返回调用进程的PID</span>
<span>pid_t</span> <span>getppid</span><span>(</span><span>void</span><span>)</span><span>;</span> <span>// 返回调用进程的父进程的PID</span>
<span>pid_t</span> <span>getpgrp</span><span>(</span><span>void</span><span>)</span><span>;</span> <span>// 返回调用进程的进程组ID</span>
<span>int</span> <span>setpgid</span><span>(</span><span>pid_t</span> pid<span>,</span> <span>pid_t</span> pgid<span>)</span><span>;</span> <span>// 将pid进程的进程组改为pgid。成功返回0，否则返回-1。</span>
<span>// setpgid(0,0)表示用当前进程的pid为名创建进程组，并将当前进程加入该进程组。</span>
<span>pid_t</span> <span>fork</span><span>(</span><span>void</span><span>)</span><span>;</span> <span>// 创建子进程，子进程返回0，父进程返回子进程的PID。</span>
<span>pid_t</span> <span>waitpid</span><span>(</span><span>pid_t</span> pid<span>,</span> <span>int</span> <span>*</span>statusp<span>,</span> <span>int</span> options<span>)</span><span>;</span> <span>// 等待pid子进程停止或终止</span>
<span>pid_t</span> <span>wait</span><span>(</span><span>int</span> <span>*</span>status<span>)</span><span>;</span> <span>// 等价于 waitpid(-1, &amp;status, 0)</span>
<span>unsigned</span> <span>int</span> <span>sleep</span><span>(</span><span>unsigned</span> <span>int</span> secs<span>)</span><span>;</span> <span>// 将进程挂起(suspend)指定秒数</span>
<span>int</span> <span>pause</span><span>(</span><span>void</span><span>)</span><span>;</span> <span>// 将进程挂起，直到该进程收到一个信号</span>
<span>// 在当前进程的上下文中加载并运行一个新程序</span>
<span>int</span> <span>execve</span><span>(</span><span>const</span> <span>char</span> <span>*</span>filename<span>,</span> <span>const</span> <span>char</span> <span>*</span>argv<span>[</span><span>]</span><span>,</span> <span>const</span> <span>char</span> <span>*</span>envp<span>[</span><span>]</span><span>)</span><span>;</span> 

<span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span>void</span> <span>exit</span><span>(</span><span>int</span> status<span>)</span><span>;</span> <span>// 以status为退出状态终止进程</span>
<span>char</span> <span>*</span><span>getenv</span><span>(</span><span>const</span> <span>char</span> <span>*</span>name<span>)</span><span>;</span> <span>// 返回指定的环境变量</span>
<span>int</span> <span>setenv</span><span>(</span><span>const</span> <span>char</span> <span>*</span>name<span>,</span> <span>const</span> <span>char</span> <span>*</span>newvalue<span>,</span> <span>int</span> overwrite<span>)</span><span>;</span> <span>// 设置环境变量</span>
<span>void</span> <span>unsetenv</span><span>(</span><span>const</span> <span>char</span> <span>*</span>name<span>)</span><span>;</span> <span>// 删除环境变量</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="fork"> fork()</h3>
<ul>
<li>fork()函数调用一次，返回两次。在子进程中返回0，在父进程中返回子进程的 PID。</li>
<li>fork()函数创建的子进程和所在的进程是并发运行的独立进程。内核能以任意方式交替执行它们的逻辑控制流中的指令。</li>
<li>fork()函数创建的子进程拥有相同但独立的地址空间。</li>
<li>fork()函数创建的子进程和所在进程共享文件。</li>
<li>进程图：每个顶点对应一条程序语句，有向边 a-&gt;b 表示语句 a 在语句 b 之前执行。在 fork 处分为两支。</li>
</ul>
<details><summary>例题</summary>
<div><pre><code><span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> x <span>=</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>Fork</span><span>(</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
        <span>printf</span><span>(</span><span>"p1: x=%d\n"</span><span>,</span> <span>++</span>x<span>)</span><span>;</span>
    <span>printf</span><span>(</span><span>"p2: x=%d\n"</span><span>,</span> <span>--</span>x<span>)</span><span>;</span>
    <span>exit</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>
<span>// 其输出为:</span>
<span>// 子进程：p1: x=2  p2: x=1</span>
<span>// 父进程：p2: x=0 </span>
<span>// 012的出现顺序不定(除了2一定在1前)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>
<h3 id="waitpid-回收子进程"> waitpid()--回收子进程</h3>
<ul>
<li>进程的回收(reaped)：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。</li>
<li>僵死进程(zombie)：终止了，但还没被回收的进程。会消耗内存资源。</li>
<li>如果一个父进程终止了，内核会安排 init 进程成为它的子进程的养父。init 进程的 PID 为 1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收它们。</li>
</ul>
<p>waitpid函数</p>
<ul>
<li>通常行为：waitpid挂起调用进程的执行，直到它的等待集合(wait set)中的一个子进程终止。如果等待集合中的一个进程，在waitpid调用时就已经终止了，则立即返回。返回子进程的PID(此时子进程已被回收)。</li>
<li>参数 pid：指定等待集合
<ul>
<li>pid &gt; 0: 等待集合就是pid指定的单独的子进程。</li>
<li>pid = -1：等待集合就是父进程的所有子进程。</li>
<li>pid = 0：等待集合就是在父进程所在进程组的所有子进程。</li>
<li>pid &lt; 0: 等待集合就是在|pid|指定的进程组中的所有子进程。</li>
</ul>
</li>
<li>参数 options：修改 waitpid 的默认行为
<ul>
<li>0:默认值。通常行为。</li>
<li>WNOHANG:如果等待集合中的一个进程，在 waitpid 调用时就已经终止了，则立即返回。如果等待集合中任何子进程都没有终止，也立即返回，返回值为 0。</li>
<li>WUNTRACED:不仅在终止时返回，停止时也返回。(停止的进程不会被回收)</li>
<li>WCONTINUED:不仅在终止时返回，在一个停止的程序继续运行时也返回。</li>
<li>选项可以组合</li>
</ul>
</li>
<li>statusp参数指向子进程的退出状态信息status。
<ul>
<li><code>&lt;sys/wait.h&gt;</code>中定义了一些宏，用于解释status。</li>
<li>WIFEXITED(status)：如果于进程通过调用 exit 或者返回正常终止，就返回真。</li>
<li>WEXITSTATUS(status)：返回一个正常终止的子进程的退出状态。只有在 WIFEXITED() 返回为真时，才会定义这个状态。</li>
<li>WIFSIGNALED(status)：如果子进程是因为一个未被捕获的信号终止的，. 那么就返回真。</li>
<li>WTERMSIG(status)：返回导致子进程终止的信号的编号。只有在 WIFSIGNALED() 返回为真时，才定义这个状态。</li>
<li>WIFSTOPPED(status)：如果引起返回的子进程当前是停止的，那么就返回真。</li>
<li>WSTOPSIG(status)：返回引起子进程停止的信号的编号。只有在 WIFSTOPPED() 返回为真时，才定义这个状态。</li>
<li>WIFCONTINUED(status)：如果子进程收到 SIGCONT 信号重新启动，则返回真。</li>
</ul>
</li>
<li>错误条件
<ul>
<li>如果调用进程没有子进程(没创建或者已经回收完了)，则 waitpid 返回 -1，并设置 errno 为 ECHILD。</li>
<li>如果 waitpid 函数被一个信号中断，则返回 -1，并设置 errno 为 EINTR。</li>
</ul>
</li>
</ul>
<h3 id="execve函数"> execve函数</h3>
<ul>
<li>execve 函数在当前进程上下文中加载并运行一个新程序，并会<strong>覆盖</strong>当前进程的地址空间，不会创建新进程，而是继承原进程的PID和已打开文件列表。</li>
<li>execve 参数列表中，filename 为要加载的可执行目标文件， argv，envp 为传递给 main 函数的参数。</li>
<li>execve 加载 filename 后，调用_start()启动代码，启动代码设置栈，并将控制传递给新程序的 main 函数。</li>
<li>main 函数的原型 <code>int main(int argc, char *argv[], char *envp[]);</code>
<ul>
<li>argc 为 argv 数组中非空指针的数量</li>
<li>agrv 数组中 <code>argv[0]</code> 为可执行目标文件名，之后为执行时所带的参数列表。</li>
<li>envp 数组保存环境变量字符串(内容为&quot;name=value&quot;的键值对)。</li>
</ul>
</li>
</ul>
<h2 id="信号"> 信号</h2>
<ul>
<li>一种比硬件异常，上下文切换更高层的软件形式异常，它允许进程和内核中断其他进程。</li>
<li>一个信号就是一个消息，它通知进程系统中发生了一个某类型的事件。</li>
<li>某种信号类型对应每种系统事件。</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>默认行为</th>
<th>相应事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止</td>
<td>终端线挂断</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>来自键盘的中断</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>终止</td>
<td>来自键盘的退出</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>终止</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>终止并转储内存</td>
<td>跟踪陷阱</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>终止并转储内存</td>
<td>来自 abort 函数的终止信号</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>终止</td>
<td>总线错误</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>终止并转储内存</td>
<td>浮点异常</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止</td>
<td>杀死程序</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>终止</td>
<td>用户定义的信号 1</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>终止并转储内存</td>
<td>无效的内存引用（段故障）</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>终止</td>
<td>用户定义的信号 2</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止</td>
<td>向一个没有读用户的管道做写操作</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止</td>
<td>来自 alarm 函数的定时器信号</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止</td>
<td>软件终止信号</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>终止</td>
<td>协处理器上的栈故障</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略</td>
<td>一个子进程停止或者终止</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>忽略</td>
<td>继续进程如果该进程停止</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止直到下一个SIGCONT</td>
<td>不是来自终端的停止信号</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止直到下一个SIGCONT</td>
<td>来自终端的停止信号</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止直到下一个SIGCONT</td>
<td>后台进程从终端读</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>停止直到下一个SIGCONT</td>
<td>后台进程向终端写</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>忽略</td>
<td>套接字上的紧急情况</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>终止</td>
<td>CPU 时间限制超出</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>终止</td>
<td>文件大小限制超出</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>终止</td>
<td>虚拟定时器期满</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止</td>
<td>剖析定时器期满</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>忽略</td>
<td>窗口大小变化</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>终止</td>
<td>在某个描述符上可执行 I/O 操作</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>终止</td>
<td>电源故障</td>
</tr>
</tbody>
</table>
<h3 id="信号术语"> 信号术语</h3>
<ul>
<li>发送信号：内核通过<strong>更新目的进程上下文中的某个状态</strong>，发送一个信号给目的进程。需要发送信号的两种原因
<ul>
<li>内核检测到某个系统事件，如除零错误或子进程终止。</li>
<li>一个进程调用了 kill 函数。</li>
</ul>
</li>
<li>接收信号：当目的进程被内核强迫以某种方式对信号作出反应时，它就接收了信号。有三种反应
<ul>
<li>忽略信号</li>
<li>终止进程</li>
<li>捕获信号：即调用信号处理程序。</li>
</ul>
</li>
<li>待处理信号(pending signal)：发出了，但没被处理的信号。在任意时刻，对一个进程而言，每个信号类型最多有一个待处理信号，后续发到该进程的同类型信号会被丢弃。也就是说，一个进程，最多接收一个信号(正在处理)并有一个同类型的待处理信号。</li>
<li>阻塞：对于信号 k，进程 p 第一次收到信号 k 时，p 接收 k，并作出合理反应。在此期间，第二次收到信号 k 时，k 就处于待处理状态，此时就说信号 k 被隐式阻塞了。如果继续收到信号 k，直接丢弃。</li>
<li>内核为每个进程维护两个信号集合
<ul>
<li>在 pending 位向量中维护待处理信号集合(被隐式阻塞的信号集合)</li>
<li>在 blocked 位向量中维护被阻塞的信号集合(用sigprocmask()函数阻塞的)</li>
</ul>
</li>
</ul>
<h3 id="发送信号"> 发送信号</h3>
<ul>
<li>/bin/kill 程序：kill -sigid pid。具体见man kill。</li>
<li>键盘：shell 中使用 job 表示进程。
<ul>
<li>Ctrl+C：内核发送一个 SIGINTR 信号到前台进程组中的每个进程。默认结果为终止前台进程。</li>
<li>Ctrl+Z：内核发送一个 SIGTSTP 信号到前台进程组中的每个进程。默认结果为停止前台进程。</li>
</ul>
</li>
<li>kill() 函数</li>
<li>alarm() 函数，向进程自己发送 SIGALRM 信号。</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;sys/types.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;signal.h></span></span>
<span>int</span> <span>kill</span><span>(</span><span>pid_t</span> pid<span>,</span> <span>int</span> sig<span>)</span><span>;</span> <span>// 向pid进程发送sig信号</span>
<span>unsigned</span> <span>int</span> <span>alarm</span><span>(</span><span>unsigned</span> <span>int</span> secs<span>)</span><span>;</span> <span>// 在secs后发送一个 SIGALRM 信号给自己。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="接收信号"> 接收信号</h3>
<p>当内核将进程 p 从内核模式切换到用户模式时，它会检查进程 p 的为被阻塞的待处理信号的集合(pending &amp; ~blocked)。如果集合为空，内核将控制直接传给 p 的逻辑控制流中的下一条指令。如果集合非空，则选择某个信号 k (通常是最小的)，并且强制 p 接收信号 k。引起相应的行为(终止，终止+转储内存(Core dump)，停止，执行信号处理程序)。</p>
<p>进程可以通过 signal 函数修改和信号相关联的默认行为，除了 SIGSTOP 和 SIGKILL。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;signal.h></span></span>
<span>typedef</span> <span>void</span> <span>(</span><span>*</span><span>sighandler_t</span><span>)</span><span>(</span><span>int</span><span>)</span><span>;</span>
<span>sighandler_t</span> <span>signal</span><span>(</span><span>int</span> signum<span>,</span> <span>sighandler_t</span> handler<span>)</span><span>;</span> <span>// 设置 signum 信号的信号处理程序为 handler。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>其中 handler 可以是：</p>
<ul>
<li>SIG_IGN：忽略信号</li>
<li>SIG_DFL：信号的默认行为</li>
<li>用户自定义函数。这个函数称为信号处理程序。调用信号处理程序称为<strong>捕获信号</strong>，执行信号处理程序称为<strong>处理信号</strong>。</li>
<li>信号处理程序可以被其他信号处理程序中断。</li>
</ul>
<h3 id="信号的阻塞和解除"> 信号的阻塞和解除</h3>
<ul>
<li>隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理的信号类型的待处理信号。</li>
<li>显示阻塞机制：使用 sigprocmask 函数设置。</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;signal.h></span></span>
<span>int</span> <span>sigprocmask</span><span>(</span><span>int</span> how<span>,</span> <span>const</span> <span>sigset_t</span> <span>*</span>set<span>,</span> <span>sigset_t</span> <span>*</span>oldset<span>)</span><span>;</span> <span>// 设置blocked位向量，阻塞信号。</span>
<span>int</span> <span>sigempty</span><span>(</span><span>sigset_t</span> <span>*</span>set<span>)</span><span>;</span> <span>// 初始化 set 为空集合</span>
<span>int</span> <span>sigfillset</span><span>(</span><span>sigset_t</span> <span>*</span>set<span>)</span><span>;</span> <span>// 初始化 set 为选择所有信号的集合</span>
<span>int</span> <span>sigaddset</span><span>(</span><span>sigset_t</span> <span>*</span>set<span>,</span> <span>int</span> signum<span>)</span><span>;</span> <span>// 将 signum 添加到 set</span>
<span>int</span> <span>sigdelset</span><span>(</span><span>sigset_t</span> <span>*</span>set<span>,</span> <span>int</span> signum<span>)</span><span>;</span> <span>// 从 set 中删除 signum</span>
<span>int</span> <span>sigismember</span><span>(</span><span>sigset_t</span> <span>*</span>set<span>,</span> <span>int</span> signum<span>)</span><span>;</span> <span>// 判断 signum 是不是 set 的成员</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>其中，how</p>
<ul>
<li>SIG_BLOCK： 将 set 中的信号添加到 blocked 中(blocked = blocked | set)</li>
<li>SIG_UNBLOCK： blocked = blocked &amp; ~set</li>
<li>SIG_SETMASK：blocked = set</li>
</ul>
<h3 id="编写信号处理程序"> 编写信号处理程序</h3>
<p>信号处理是 Linux 系统编程最棘手的一个问题。因为</p>
<ul>
<li>处理程序和主程序并发运行，共享同样的全局变量</li>
<li>如何及何时接收信号的规则常常违反人的直觉</li>
<li>不同系统有不同的信号处理语义</li>
</ul>
<p>//TODO</p>
<ul>
<li>信号时不排队的，每种信号最多一个正在处理，一个待处理，其余都是直接丢弃。因此，关于信号的一个关键思想是：如果存在一个未处理的信号，就表明至少有一个信号到达了。</li>
<li>ps命令输出中的<code>&lt;defunct&gt;</code>表明进程为僵死进程。</li>
</ul>
<h2 id="非本地跳转"> 非本地跳转</h2>
<p>另一种用户级异常控制流形式。通过 setjump 和 longjump 函数提供。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;setjmp.h></span></span>
<span>int</span> <span>setjmp</span><span>(</span>jmp_buf env<span>)</span><span>;</span> <span>// 在 env 缓冲区中保存当前调用环境，供longjmp使用，返回0。</span>
<span>void</span> <span>longjmp</span><span>(</span>jmp_buf env<span>,</span> <span>int</span> retval<span>)</span><span>;</span> <span>// 从 env 缓冲区中恢复调用环境，然后触发一个最近一次初始化 env 的 setjmp 调用的返回。然后 setjmp 返回，返回值为非零的 retval。</span>
<span>// 下面这两个是可被信号处理函数使用的版本。(但都不是异步信号安全的函数)</span>
<span>int</span> <span>sigsetjump</span><span>(</span>sigjmp_buf env<span>,</span> <span>int</span> savesigs<span>)</span><span>;</span> 
<span>void</span> <span>siglongjmp</span><span>(</span>sigjmp_buf env<span>,</span> <span>int</span> retval<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>longjmp不返回，而是直接跳转到最近的setjmp，让setjmp再次返回。</p>
<p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。</p>
<details><summary>示例</summary>
<div><pre><code><span><span>#</span><span>include</span> <span>"csapp.h"</span></span>

jmp_buf buf<span>;</span>

<span>int</span> error1 <span>=</span> <span>0</span><span>;</span>
<span>int</span> error2 <span>=</span> <span>1</span><span>;</span>

<span>void</span> <span>foo</span><span>(</span><span>void</span><span>)</span><span>,</span> <span>bar</span><span>(</span><span>void</span><span>)</span><span>;</span>

<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>switch</span> <span>(</span><span>setjmp</span><span>(</span>buf<span>)</span><span>)</span> <span>{</span>
    <span>case</span> <span>0</span><span>:</span>
        <span>foo</span><span>(</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> <span>1</span><span>:</span>
        <span>printf</span><span>(</span><span>"Detected an error1 condition in foo\n"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> <span>2</span><span>:</span>
        <span>printf</span><span>(</span><span>"Detected an error2 condition in foo\n"</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
    <span>default</span><span>:</span>
        <span>printf</span><span>(</span><span>"Unknown error condition in foo\n"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>exit</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>/* Deeply nested function foo */</span>
<span>void</span> <span>foo</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span>error1<span>)</span>
        <span>longjmp</span><span>(</span>buf<span>,</span> <span>1</span><span>)</span><span>;</span>
    <span>bar</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>bar</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span>error2<span>)</span>
        <span>longjmp</span><span>(</span>buf<span>,</span> <span>2</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div></details>
<p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>
<details><summary>示例</summary>
<div><pre><code><span><span>#</span><span>include</span> <span>"csapp.h"</span></span>

sigjmp_buf buf<span>;</span>

<span>void</span> <span>handler</span><span>(</span><span>int</span> sig<span>)</span>
<span>{</span>
    <span>siglongjmp</span><span>(</span>buf<span>,</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>sigsetjmp</span><span>(</span>buf<span>,</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
        <span>Signal</span><span>(</span>SIGINT<span>,</span> handler<span>)</span><span>;</span>
        <span>Sio_puts</span><span>(</span><span>"starting\n"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>else</span>
        <span>Sio_puts</span><span>(</span><span>"restarting\n"</span><span>)</span><span>;</span>

    <span>while</span> <span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>Sleep</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>Sio_puts</span><span>(</span><span>"processing...\n"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>exit</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>/* Control never reaches here */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div></details>
<h2 id="操作进程的工具"> 操作进程的工具</h2>
<ul>
<li>STRACE</li>
<li>PS</li>
<li>TOP</li>
<li>PMAP</li>
</ul>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/csapp-ecf-01.png" type="image/png"/>
    </item>
    <item>
      <title>虚拟内存</title>
      <link>https://kigane.github.io/note/cs/VM/</link>
      <guid>https://kigane.github.io/note/cs/VM/</guid>
      <source url="https://kigane.github.io/rss.xml">虚拟内存</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>虚拟内存提供三个重要能力</p>
<ul>
<li>将主存看作磁盘的高速缓存，在主存中只保留活动区域，并根据需要在主存和磁盘间传送数据，高效地使用了主存</li>
<li>为每个进程提供了一致的地址空间，简化了内存管理</li>
<li>也保护了每个进程的地址空间不被其他进程破坏</li>
</ul>
<h2 id="物理和虚拟寻址"> 物理和虚拟寻址</h2>
<p>物理地址(Physical Address, PA)：计算机的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。<br>
虚拟寻址(Virtual Address, VA)：CPU生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前先转换为适当的物理地址。在CPU芯片上由叫内存管理单元(Memory Management Unit, MMU)的硬件负责地址翻译，即将VA转换为PA。MMU通过到主存中查询页表来动态翻译VA。</p>
<h2 id="地址空间"> 地址空间</h2>
<p>地址空间是一个非负整数地址的有序集合，为了简化讨论总是使用线性地址空间，即整数是连续的。<br>
虚拟地址空间的大小用位表示，n位地址空间，表示有<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>个地址。物理地址空间对应于物理内存的M个字节。M不要求是2的幂，但我们通常这样假设。<br>
虚拟内存的基本思想是：允许每个数据对象(字节)有多个独立的地址，其中每个地址来自不同的地址空间。</p>
<h2 id="虚拟内存的结构"> 虚拟内存的结构</h2>
<p>概念上，虚拟内存是一个由存放在磁盘上的N个连续字节组成的数组。磁盘上的数据被分割成块，作为在磁盘和主存之间的传送单元。VM系统将虚拟内存分割成的块称为虚拟页(Virtual Page, VP)，物理内存的块称为物理页(Physical Page, PP)或页帧(page frame)(大小为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.13889em;">P</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>p</span></span></span></span></span></span></span></span></span></span></span>字节)。</p>
<p><img src="/assets/csapp/VP-PP.png" alt="VP-PP" /></p>
<h3 id="dram缓存"> DRAM缓存</h3>
<ul>
<li>术语DRAM缓存表示VM系统的缓存，即用主存缓存VP。</li>
<li>相应的SRAM缓存表示CPU和主存之间的L1,L2,L3高速缓存。</li>
</ul>
<p>磁盘比DRAM慢大约100000多倍，不命中的开销巨大。从磁盘读取第一个字节的开销也很大。因此</p>
<ul>
<li>虚拟页往往很大，通常为4KB~2MB</li>
<li>DRAM缓存是全相联的</li>
<li>替换策略更复杂，精密</li>
<li>使用写回，而非直写</li>
</ul>
<h3 id="页表-page-table"> 页表(Page Table)</h3>
<p>建立虚拟页到物理页的映射</p>
<ul>
<li>页表是一个存放在物理内存中的数据结构，是一个页表条目(Page Table Entry, PTE)的数组，建立虚拟页到物理页的映射。虚拟地址空间中的每个页在页表中一个<strong>固定偏移量</strong>处都有一个PTE。</li>
<li>MMU中的地址翻译硬件每次将VA转换为PA时，都会去读页表。</li>
<li>OS负责维护页表的内容，以及在磁盘和DRAM之间来回传送页。
<img src="/assets/csapp/PageTable.png" alt="PageTable" />
PS：有效位为1表示对应的VP已经装入物理内存了，地址为内存地址。有效位为0表示要么VP还未分配，要么地址指向VP在磁盘上的位置。</li>
</ul>
<h2 id="命中与缺页"> 命中与缺页</h2>
<p>当CPU想要读取VM系统中的一个字节（如VP2）时，发送一个VA到MMU的地址翻译硬件，地址翻译硬件根据VA的前n-p位VPN(Virtual Page Number)定位页表中相应的PTE，然后查看PTE的有效位</p>
<ul>
<li>
<p>如果为1，说明VP2已缓存在内存中了。PTE中的地址就是PA的PPN(Physics Page Number)。取出来和VPO(Virtual Page Offset)构成实际物理地址。</p>
</li>
<li>
<p>如果为0，称为缺页(page fault)。引发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序选择一个牺牲页，设为VP4(如果VP4已经被修改了，则内核将VP4复制回磁盘)，内核修改相应PTE，以表示VP4已不再主存中。接下来，内核从磁盘复制VP2到原VP4所在的主存位置，更新相应PTE后返回。异常处理程序返回时，会重新启动导致缺页的指令，此时必定命中。</p>
</li>
<li>
<p>页面调度(Paging)：在磁盘和内存之间传送页的活动。从磁盘到DRAM称换入，反之称换出。</p>
</li>
<li>
<p>页面分配：分配一个新的VP，如调用malloc，使PTE中含null的空洞页实际占有物理空间。</p>
</li>
</ul>
<h2 id="内存管理"> 内存管理</h2>
<p>OS为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。</p>
<p>好处</p>
<ul>
<li>简化链接：每个进程的内存格式都类似。对于64位地址空间，代码段总是从VA=0x400000开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。链接时，一直使用VA，实际运行时再映射为PA。</li>
<li>简化加载：有了虚拟内存后，加载文件时，只需要为文件分配虚拟页，即将其PTE有效位设为0，并指向目标文件的适当位置。也就是说，实际没有任何复制动作，实际要用时再按需调度。</li>
<li>简化共享：OS可将不同进程的页表中适当的VP映射到相同的PP，从而实现多进程共享相应代码。</li>
<li>简化内存分配：用malloc要求额外的堆空间时，在VM中分配的连续的VP，实际PP可以不连续。</li>
</ul>
<h2 id="内存保护"> 内存保护</h2>
<p>OS需要某种手段来控制对内存系统的访问。如</p>
<ul>
<li>不允许用户进程修改其只读代码段</li>
<li>不允许用户进程修改内核中的代码和数据结构</li>
<li>不允许用户进程读或写其他进程的私有内存</li>
<li>不允许用户进程修改任何与其他进程共享的虚拟页面(除非所有共享者都允许它这么做)</li>
</ul>
<p>实现很容易，只需在PTE中添加几个许可位。例如</p>
<ul>
<li>SUP：进程需要在内核(超级用户)模式下才能访问该页</li>
<li>READ：读权限</li>
<li>WRITE：写权限</li>
<li>……</li>
</ul>
<p>保护违例：如果一条指令违反了这些许可条件，则CPU触发一个保护故障，将控制传递给一个内核中的异常处理程序。Linux shell 一般称这种异常为“段错误(segmentation fault)”</p>
<h2 id="地址翻译"> 地址翻译</h2>
<p>TLB， Translation Lookaside Buffer，简称快表</p>
<p>符号</p>
<ul>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">N</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>：虚拟地址空间中的地址数量</li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.10903em;">M</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>m</span></span></span></span></span></span></span></span></span></span></span>：物理地址空间中的地址数量</li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.13889em;">P</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>p</span></span></span></span></span></span></span></span></span></span></span>：页大小(字节)</li>
</ul>
<hr>
<ul>
<li>VPN：虚拟页号</li>
<li>VPO：虚拟页面偏移量</li>
<li>TLBT： TLB标记</li>
<li>TLBI：TLB索引</li>
</ul>
<hr>
<ul>
<li>PPO：物理页面偏移量，和VPO一样</li>
<li>PPN：物理页号</li>
<li>CO：缓存块内字节偏移量</li>
<li>CI： cache索引</li>
<li>CT： cache标记</li>
</ul>
<p><img src="/assets/csapp/AddrTranslate.png" alt="地址翻译" /></p>
<ul>
<li>CPU中的一个控制寄存器，页表基址寄存器(PTBR)指向当前页表基址。</li>
<li>虚拟地址=VPN(n-p位)+VPO(p位)</li>
<li>VPN和页表中的PTE一一对应。</li>
<li>物理地址=PPN+VPO</li>
</ul>
<p>页面命中时CPU执行步骤：</p>
<ol>
<li>处理器生成一个虚拟地址，并把它传送给 MMU。</li>
<li>MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。</li>
<li>高速缓存/主存向 MMU 返回 PTE。</li>
<li>MMU 构造物理地址，并把它传送给高速缓存/主存。</li>
<li>高速缓存/主存返回所请求的数据字给处理器。</li>
</ol>
<p><img src="/assets/csapp/FindAddr.png" alt="寻址" /></p>
<p>缺页时：</p>
<ul>
<li>第 1 步到第 3 步：和命中时的第 1 步到第 3 步相同。</li>
<li>第 4 步：PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>第 5 步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li>
<li>第 6 步：缺页处理程序页面调入新的页面，并更新内存中的 PTE。</li>
<li>第 7 步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU 执行了图 9-13b 中的步骤之后，主存就会将所请求字返回给处理器。</li>
</ul>
<h3 id="结合高速缓存和虚拟内存"> 结合高速缓存和虚拟内存</h3>
<p>因为MMU在CPU内，翻译地址时需要到主存中查页表，因此缓存可以发挥作用，缓存PTE就像其他数据字一样。</p>
<h3 id="使用tlb加速地址翻译"> 使用TLB加速地址翻译</h3>
<p>为了减少到主存或缓存中查询页表的次数，在MMU中包括了一个关于PTE的小的缓存，称为翻译后备缓冲器(TLB)，即快表。<br>
TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块。</p>
<p><img src="/assets/csapp/tlbpte.png" alt="TLB" /></p>
<p>CPU访存时，地址中虚页号被分成tag+index，tag用于和TLB页表项中的tag比较，index用于定位需要比较的表项。</p>
<ul>
<li>TLB全相联时，没有index，只有Tag，虚页号需与每个Tag比较；</li>
<li>TLB组相联时，则虚页号高位为Tag，低位为index，用作组索引</li>
</ul>
<p><img src="/assets/csapp/FindAddrTlb.png" alt="寻址-tlb" /></p>
<h3 id="多级页表"> 多级页表</h3>
<p>如果我们有一个 32 位的地址空间、4KB 的页面和 4B 的 PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。对于地址空间为 64 位的系统来说，问题更大。所以需要压缩页表，常用方法是使用层次结构的页表。<br>
假设 32 位虚拟地址空间被分为 4KB 的页，而每个页表条目都是 4 字节。还假设在这一时刻，虚拟地址空间有如下形式：内存的前 2K 个页面分配给了代码和数据，接下来的 6K 个页面还未分配，再接下来的 1023 个页面也未分配，接下来的 1 个页面分配给了用户栈。
<img src="/assets/csapp/MultiLayerPT.png" alt="多级页表" /></p>
<p>一级页表中的每个 PTE 负责映射虚拟地址空间中一个 4MB 的片（chunk），这里每一片都是由 1024 个连续的页面组成的。假设地址空间是 4GB，1024 个 PTE 已经足够覆盖整个空间了。如果片 i 中的每个页面都未被分配，那么一级 PTE i 就为空。如果在片 i 中至少有一个页是分配了的，那么一级 PTE i 就指向一个二级页表的基址。二级页表中的每个 PTE 都负责映射一个 4KB 的虚拟内存页面，就像我们查看只有一级的页表一样。<br>
注意，使用 4 字节的 PTE，每个一级和二级页表都是 4KB 字节，这刚好和一个页面的大小是一样的。</p>
<p>这种方法从两个方面减少了内存要求。</p>
<ol>
<li>如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在。这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB 的虚拟地址空间的大部分都会是未分配的。</li>
<li>只有一级页表才需要总是在主存中；虚拟内存系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中。</li>
</ol>
<p>使用 k 级页表层次结构的地址翻译。虚拟地址被划分成为 k 个 VPN 和 1 个 VPO。每个 VPN i 都是一个到第 i 级页表的索引。第 j 级页表中的每个 PTE都指向第 j+1 级的某个页表的基址。</p>
<p>为了确定PPN，MMU必须访问k个PTE。看上去消耗很大，实际上TLB可以将不同层次上页表的PTE缓存起来，代价并没有大很多。</p>
<p><img src="/assets/csapp/MultiPageTable.png" alt="多级页表" /></p>
<h2 id="linux虚拟内存系统"> Linux虚拟内存系统</h2>
<p>Linux为每个进程维护一个单独的虚拟地址空间。形式如图。
<img src="/assets/csapp/LinuxVMSystem.png" alt="Linux虚拟内存系统" /></p>
<h3 id="linux虚拟内存区域"> Linux虚拟内存区域</h3>
<p>Linux将虚拟内存组织成一些区域(area，也叫做段,segment)的集合。一个段就是已分配的虚拟内存的连续片(chunk)，并以某种形式相关联。每个虚拟页都保存在某个段中，如果引用的虚拟页不属于某个段，会引发段错误。<br>
以段的形式组织内存，好处是：允许虚拟地址空间有间隙，因此内存无需记录那些不存在的虚拟页。</p>
<h3 id="虚拟内存区域的内核数据结构"> 虚拟内存区域的内核数据结构</h3>
<ul>
<li>内核为每个进程维护一个单独的任务结构(task_struct)。</li>
<li>task_struct中一个条目指向一个描述虚拟内存当前状态的数据结构(mm_struct)。</li>
<li>mm_struct中有两个重要字段：
<ul>
<li>pgd：指向<strong>第一级页表的基址</strong>。当内核运行该程序是，将pdg放到<strong>CR3控制寄存器</strong>中。</li>
<li>mmap：指向一个区域结构(vm_area_structs)的链表。
<ul>
<li>每个vm_area_structs都描述了当前虚拟地址空间中的一个区域，包含：</li>
<li>vm_start：指向区域的起始地址。</li>
<li>vm_end：指向区域的结束地址。</li>
<li>vm_prot：描述该区域包含的所有页的读写许可权限。</li>
<li>vm_flags：描述一些其他信息，如该区域内的页面是与其他进程共享的，还是私有的。</li>
<li>vm_next：指向下一个区域结构。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/assets/csapp/LinuxSegment.png" alt="Linux虚拟内存段" /></p>
<h3 id="linux缺页处理异常"> Linux缺页处理异常</h3>
<p>设MMU在试图翻译某个VA时，触发了一个缺页。导致控制转到内核的缺页处理程序，随后执行：</p>
<ol>
<li>VA是否合法?也就是说，VA在某个区域结构定义的区域内吗？为了作出判断，需要将VA和链表中所有区域结构的vm_start,vm_end作比较。如果不合法，触发一个段错误，并终止进程。因为一个进程可以创建任意数量的新虚拟内存区域，所以这种顺序搜索效率不够。因而实际中，有优化。</li>
<li>试图进行的内存访问是否合法?即进程的访问权限对不对？如果访问不合法，那么缺页处理程序会触发一个保护异常，从而终止进程。</li>
<li>如果确实是对合法VA的合法操作。则选择牺牲页，如果有修改，则多一步换出操作，否则换入新的页面并更新页表。<br>
当缺页处理程序返回时，CPU重新启动引起缺页的指令，该指令就能正常执行了。</li>
</ol>
<h2 id="内存映射"> 内存映射</h2>
<p>Linux 通过将一个虚拟内存区域与一个磁盘上的<strong>对象</strong>（object）关联起来，以初始化这个虚拟内存区域的内容，这个过程称为<strong>内存映射</strong>（memory mapping），虚拟内存区域可以映射到两种类型的对象上：</p>
<ol>
<li>**Linux 文件系统中的普通文件：**一个段可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区（section）被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到 CPU 第一次引用到页面。如果段比文件区要大，那么就用零来填充这个段的余下部分。</li>
<li><strong>匿名文件：<strong>一个段也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU 第一次引用这样一个段内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的段中的页面也叫做</strong>demand-zero page</strong>。</li>
</ol>
<p>无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的<strong>交换文件</strong>（swap file）之间换来换去。交换文件也叫做<strong>交换空间</strong>（swap space）或者<strong>交换区域</strong>（swap area）。需要意识到的很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</p>
<h3 id="再看共享对象"> 再看共享对象</h3>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。</p>
<ul>
<li>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于其它也把这个共享对象映射到虚拟内存中的进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。</li>
<li>对一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟内存区域叫做<strong>共享区域</strong>。类似地，也有<strong>私有区域</strong>。</li>
</ul>
<p><img src="/assets/csapp/gsxd1.png" alt="共享" /></p>
<p>因为每个对象都有一个唯一的文件名，内核可以迅速地判定进程 1 已经映射了这个对象，而且可以使进程 2 中的页表条目指向相应的物理页面。关键点在于即使对象被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。为了方便，我们将物理页面显示为连续的，但是在一般情况下当然不是这样的。</p>
<p><img src="/assets/csapp/gsxd2.png" alt="私有" /></p>
<p>私有对象使用一种叫做写时复制（copy-on-write）的技术映射到虚拟内存中。一个私有对象开始时共享对象的一样，在物理内存中只有私有对象的一份副本，但相应私有区域的页表条目都被标记为只读，并且区域结构的标记(vm_flags)为私有的、写时复制。当没有进程试图写它自己的私有区域时，它们就共享物理内存中对象的一个单独副本。然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。当故障处理程序注意到保护异常是由于进程试图写一个标记为私有的、写时复制的区域中的一个页面而引起的时候，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限。当故障处理程序返回时，CPU 重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。</p>
<p>通过尽可能延迟私有对象的拷贝操作，copy-on-write充分地使用了稀有的物理内存。</p>
<h3 id="再看fork函数"> 再看fork函数</h3>
<p>当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟内存，它复制当前进程的 mm_struct、区域结构和页表。并将两个进程中的每个页面都标记为只读，每个区域结构都标记为私有的、写时复制。</p>
<p>当 fork 在新进程中返回时，新进程的虚拟内存和调用 fork 时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p>
<h3 id="再看-execve-函数"> 再看 execve 函数</h3>
<p><code>execve(&quot;a.out&quot;, NULL, NULL);</code><br>
execve 函数在当前进程中加载并运行包含在可执行目标文件 a.out 中的程序，用 a.out 程序替代当前程序。加载并运行 a.out 需要以下几个步骤：</p>
<ol>
<li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li>
<li>映射私有区域。为新程序的text、data、bss 和栈区域创建新的区域结构。所有这些新的区域标记为私有的、写时复制的。代码和data区域被映射为 a.out 文件中的.text 和.data 区。<strong>bss 区域映射到匿名文件，其大小包含在 a.out 中。栈和堆区域也映射到匿名文件，初始长度为零。</strong>(C/C++的未初始化static变量，全局变量都是在.bss节，因此都会初始化为0。堆栈虽然会初始化为零，但堆栈都是动态的，其地址可能被复用，导致下一次分配到的地址可能存在之前留下的脏数据，因此，未初始化的堆栈变量的值无法确定)</li>
<li>映射共享区域。如果 a.out 程序与共享对象链接，比如标准 C 库 libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li>
<li>设置程序计数器（PC）。execve 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</li>
</ol>
<p>下一次调度到这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。</p>
<p><img src="/assets/csapp/ExecveLoad.png" alt="execve加载" /></p>
<h3 id="使用mmap函数的用户级内存映射"> 使用mmap函数的用户级内存映射</h3>
<p>Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域。</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;unistd.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;sys/mman.h></span></span>

<span>void</span> <span>*</span><span>mmap</span><span>(</span><span>void</span> <span>*</span>start<span>,</span> <span>size_t</span> length<span>,</span> <span>int</span> prot<span>,</span> <span>int</span> flags<span>,</span>
           <span>int</span> fd<span>,</span> <span>off_t</span> offset<span>)</span><span>;</span>

<span>// 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(-1)。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>mmap 函数要求内核创建一个新的虚拟内存区域，最好是从地址 start 开始的一个区域，并将文件描述符 fd （用于打开文件的open函数的返回值）指定的对象的一个连续的片（chunk）映射到这个新的区域。连续的对象片大小为 length 字节，从距文件开始处偏移量为 offset 字节的地方开始。start 地址仅仅是一个暗示而不是命令，通常设为 NULL。
<img src="/assets/csapp/mmap.png" alt="mmap函数" /></p>
<p>参数 prot 包含描述新映射的虚拟内存区域的访问权限位（即在相应区域结构中的 vm_prot 位）。</p>
<ul>
<li>PROT_EXEC：这个区域内的页面由可以被 CPU 执行的指令组成。</li>
<li>PROT_READ：这个区域内的页面可读。</li>
<li>PROT_WRITE：这个区域内的页面可写。</li>
<li>PROT_NONE：这个区域内的页面不能被访问。</li>
</ul>
<p>参数 flags 由描述被映射对象类型的位组成。</p>
<ul>
<li>MAP_ANON 标记位，表示被映射的对象是一个匿名对象，而相应的虚拟页面是请求二进制零的</li>
<li>MAP_PRIVATE 表示是一个私有的、写时复制的对象</li>
<li>MAP_SHARED 表示是一个共享对象。</li>
</ul>
<p>munmap 函数删除虚拟内存的区域：</p>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;unistd.h></span></span>
<span><span>#</span><span>include</span> <span>&lt;sys/mman.h></span></span>

<span>int</span> <span>munmap</span><span>(</span><span>void</span> <span>*</span>start<span>,</span> <span>size_t</span> length<span>)</span><span>;</span>

<span>// 返回：若成功则为 0，若出错则为 -1。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>munmap 函数删除从虚拟地址 start 开始的，由接下来 length 字节组成的区域。接下来对已删除区域的引用会导致段错误。</p>
<details><summary>更多信息</summary>
<div><pre><code><span><span>#</span><span>include</span> <span>"csapp.h"</span></span>

<span>/*
* mmapcopy - uses mmap to copy file fd to stdout
*/</span>
<span>void</span> <span>mmapcopy</span><span>(</span><span>int</span> fd<span>,</span> <span>int</span> size<span>)</span>
<span>{</span>
    <span>char</span> <span>*</span>bufp<span>;</span> <span>/* ptr to memory-mapped VM area */</span>

    bufp <span>=</span> <span>mmap</span><span>(</span><span>NULL</span><span>,</span> size<span>,</span> PROT_READ<span>,</span> MAP_PRIVATE<span>,</span> fd<span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>Write</span><span>(</span><span>1</span><span>,</span> bufp<span>,</span> size<span>)</span><span>;</span>
    <span>return</span><span>;</span>
<span>}</span>

<span>/* mmapcopy driver */</span>
<span>int</span> <span>main</span><span>(</span><span>int</span> argc<span>,</span> <span>char</span> <span>*</span><span>*</span>argv<span>)</span>
<span>{</span>
    <span>struct</span> <span>stat</span> stat<span>;</span>
    <span>int</span> fd<span>;</span>

    <span>/* Check for required command-line argument */</span>
    <span>if</span> <span>(</span>argc <span>!=</span> <span>2</span><span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>"usage: %s &lt;filename>\n"</span><span>,</span> argv<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
        <span>exit</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/* Copy the input argument to stdout */</span>
    fd <span>=</span> <span>Open</span><span>(</span>argv<span>[</span><span>1</span><span>]</span><span>,</span> O_RDONLY<span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>fstat</span><span>(</span>fd<span>,</span> <span>&amp;</span>stat<span>)</span><span>;</span>
    <span>mmapcopy</span><span>(</span>fd<span>,</span> stat<span>.</span>st_size<span>)</span><span>;</span>
    <span>exit</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div></details>
<h2 id="动态内存分配"> 动态内存分配</h2>
<p>动态内存分配器维护着一个进程的虚拟内存区域--堆</p>
<ul>
<li>堆紧接在未初始化的数据区域(bss)后开始，并向高地址增长。</li>
<li>内核为每个进程维护一个变量 brk(读做 “break”)，指向堆的顶部。</li>
<li>分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk），要么是已分配的，要么是空闲的。</li>
</ul>
<p>分配器风格</p>
<ul>
<li>显式分配器（explicit allocator），要求应用显式地释放任何已分配的块。malloc/free, new/delete。</li>
<li>隐式分配器（implicit allocator），要求分配器检测一个已分配块何时不再被程序所使用，并负责释放这个块。隐式分配器也叫做垃圾收集器（garbage collector），而自动释放未使用的已分配的块的过程叫做垃圾收集（garbage collection）</li>
</ul>
<h3 id="malloc和free函数"> malloc和free函数</h3>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;stdlib.h></span></span>
<span>void</span> <span>*</span><span>malloc</span><span>(</span><span>size_t</span> size<span>)</span><span>;</span>
<span>void</span> <span>*</span><span>calloc</span><span>(</span><span>size_t</span> size<span>)</span><span>;</span>
<span>void</span> <span>free</span><span>(</span><span>void</span> <span>*</span>ptr<span>)</span><span>;</span>

<span><span>#</span><span>include</span> <span>&lt;unistd.h></span></span>
<span>void</span> <span>*</span><span>sbrk</span><span>(</span><span>intptr_t</span>  incr<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>malloc函数返回一个指针，指向大小至少为size字节的内存块。在32位模式中，malloc返回的块地址总是8的倍数。64位模式下，总是16的倍数。</li>
<li>如果malloc遇到问题则返回NULL并设置errno。</li>
<li>malloc不初始化它返回的内存。要初始化，使用calloc。</li>
<li>sbrk函数通过将内核的brk指针增加incr来扩展和收缩堆(incr为负值)。成功返回brk的旧值，否则返回-1,并设errno为ENOMEM。</li>
<li>sbrk(0)返回当前brk的值。</li>
<li>free的参数必须是已分配块的起始位置。否则free的行为未定义。</li>
</ul>
<div><p>峰值利用率</p>
<p>为程序的聚集有效载荷(每个块的有效载荷的和)占当前堆大小的比例，在分配器分配释放内存的序列中达到的峰值。</p>
</div>
<h3 id="碎片"> 碎片</h3>
<ul>
<li>内部碎片：已分配块比有效载荷大的部分。</li>
<li>外部碎片：是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。
<ul>
<li>外部碎片不仅取决于以前请求的模式和分配器的实现方式，还取决于将来请求的模式。例如，现在内存中只有6个字的空闲，但这六个字是分散的，有两个3字的空闲块组成的。那么，对于一个6字的请求，就存在两个碎片，对于一个3字的请求，就不存在碎片。</li>
<li>因为外部碎片难以量化且不可能预测，所以分配器通常釆用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。</li>
</ul>
</li>
</ul>
<h3 id="分配器的实现问题"> 分配器的实现问题</h3>
<p>最简单的分配器会把堆组织成一个大的字节数组，还有一个指针 p，初始指向这个数组的第一个字节。为了分配 size 个字节，malloc 将 p 的当前值保存在栈里，将 p 增加 size，并将 p 的旧值返回到调用函数。free 只是简单地返回到调用函数，而不做其他任何事情。</p>
<p>这个简单的分配器是设计中的一种极端情况。因为每个 malloc 和 free 只执行很少量的指令，吞吐率会极好。然而，因为分配器从不重复使用任何块，内存利用率将极差。一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题：</p>
<ul>
<li>空闲块组织：我们如何记录空闲块？(核心)</li>
<li>放置：我们如何选择一个合适的空闲块来放置一个新分配的块？</li>
<li>分割：在将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？</li>
<li>合并：我们如何处理一个刚刚被释放的块？</li>
</ul>
<h3 id="隐式空闲链表"> 隐式空闲链表</h3>
<p>任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。
<img src="/assets/csapp/StackBlock.png" alt="堆块的格式" /></p>
<ul>
<li>头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。</li>
<li>有效载荷的大小为malloc的参数。malloc返回的指针，指向的就是有效载荷的首地址。</li>
<li>填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。</li>
</ul>
<div><p>注意</p>
<p>因为对齐约束条件，块大小就总是 8 的倍数，也就是说块大小的最低 3 位总是零。因此，内存大小只要用到其 29 个高位，剩余的 3 位来编码其他信息。我们用其中的最低位（称已分配位）来指明这个块是已分配的还是空闲的。</p>
</div>
<p>将堆组织为一个连续的已分配块和空闲块的序列，称为隐式空闲链表，因为空闲块是通过头部中的大小字段隐含地连接着的。
<img src="/assets/csapp/ImplicitList.png" alt="隐式空闲列表" />
注意：结束块需要某种特殊标记，在这个示例中，就是一个设置了已分配位而大小为零的终止头部（terminating header）。</p>
<p>系统对齐要求和分配器对块格式的选择会对分配器上的最小块大小有强制的要求。</p>
<h4 id="放置"> 放置</h4>
<p>当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。搜索的方式由放置策略确定。</p>
<ul>
<li>首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。</li>
<li>下一次适配：从上一次查询结束的地方开始搜索空闲链表，选择第一个合适的空闲块。</li>
<li>最佳适配：检查每个空闲块，选择适合所需请求大小的最小空闲块。</li>
</ul>
<h4 id="分割"> 分割</h4>
<p>一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空闲块中多少空间。一个选择是用整个空闲块。虽然这种方式简单而快捷，但是主要的缺点就是它会造成内部碎片。分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。</p>
<div><p>注意</p>
<p>如果分配器不能为请求块找到合适的空闲块将发生什么呢？</p>
<ul>
<li>合并那些在内存中物理上相邻的空闲块来创建一些更大的空闲块</li>
<li>调用 sbrk 函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。</li>
</ul>
</div>
<h4 id="合并"> 合并</h4>
<p>当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些邻接的空闲块可能引起一种现象，叫做假碎片（fault fragmentation），就是有许多可用的空闲块被切割成为小的、无法使用的空闲块。为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并（coalescing）。</p>
<p>合并策略</p>
<ul>
<li>立即合并（immediate coalescing）：在每次一个块被释放时，就合并所有的相邻块。</li>
<li>推迟合并（deferred coalescing）：等到某个稍晚的时候再合并空闲块。例如，某个分配请求失败时，扫描整个堆，合并所有的空闲块。</li>
<li>立即合并简单明了，可以在常数时间内执行完成，但是对于某些请求模式，这种方式会产生一种形式的抖动，块会反复地合并，然后马上分割。快速的分配器通常会选择某种形式的推迟合并。</li>
</ul>
<h4 id="带边界标记的合并"> 带边界标记的合并</h4>
<p>设想要释放的块为当前块。那么，合并下一个空闲块很简单而且高效。<strong>当前块的头部指针+头部大小=下一块的头部指针</strong>，可以检查这个指针以判断下一个块是否是空闲的。如果是，就将它的大小简单地加到当前块头部的大小上，这两个块在常数时间内被合并。但是，对于前一块，因为不知道块大小，所以无法找到其头部指针，因而无法判断其是否空闲，也无从合并。</p>
<p>Knuth提出了一种解决方法，叫<strong>边界标记(boundary tag)</strong>。<br>
在每个块的结尾处添加一个脚部（footer，边界标记），实际上就是头部的一个副本。这样，因为头部指针大小是固定的，从当前块的头部指针上移一个指针就能找到上一块的脚步，从而确定其是否空闲，块大小为多少。</p>
<p>使用边界标记合并共有4种情况：</p>
<ol>
<li>前面的块和后面的块都是已分配的。</li>
<li>前面的块是已分配的，后面的块是空闲的。</li>
<li>前面的块是空闲的，而后面的块是已分配的。</li>
<li>前面的和后面的块都是空闲的。
<img src="/assets/csapp/BoundaryTag.png" alt="边界标记" /></li>
</ol>
<p>边界标记的概念是简单优雅的，它对许多不同类型的分配器和空闲链表组织都是通用的。然而，它也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。</p>
<div><p>边界标记的优化方法</p>
<p>考虑合并的四种情况，只有在前面的块是空闲时(情况3,4)，才会需要用到它的脚部。因此，可以将表明前面块是已分配还是空闲的标志位，放在当前块头部的3个低位中(最低位是当前块的标志，次低位是前一块的标志)，这样已分配的块就不要footer了。但注意，空闲块仍然需要footer。<br>
例如，如果当前块的次低位为1，即前一块是已分配的，那么合并时用不到前一块，自然不需要前一块的footer。如果次低位是0，即前一块是未分配的，可以通过空闲块的footer找到其头部，将前一块和当前块合并。至于后面的块，本来就用不到footer，用头部即可。</p>
</div>
<h3 id="显式空闲链表"> 显式空闲链表</h3>
<p>隐式空闲链表，块分配与堆块的总数呈线性关系(每次分配块，都要从头开始扫描整个堆)，所以对于通用的分配器，隐式空闲链表是不适合的。一种更好的方法是将空闲块组织为某种形式的显式数据结构。另外，根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。</p>
<p><img src="/assets/csapp/ExplicitList.png" alt="显示空闲链表" /></p>
<ul>
<li>使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。</li>
<li>释放时间取决于链表中块的排序策略。
<ul>
<li>用后进先出的顺序维护链表，将新释放的块放置在链表的开始处。释放与合并可以在常数时间内完成。</li>
<li>按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。但首次适配的内存利用率更高。</li>
</ul>
</li>
</ul>
<p>一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p>
<h3 id="分离的空闲链表"> 分离的空闲链表</h3>
<p>分离存储（segregated storage），就是维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做大小类（size class，例如{17~32}表示大小为17到32字之内的内存都属于这一类）。<br>
分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为 n 的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个链表，以此类推。</p>
<h4 id="简单分离存储"> 简单分离存储</h4>
<ul>
<li>每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。例如{17~32}中就只有大小为32字的块。</li>
<li>空闲块是不会分割以满足分配请求的。</li>
<li>如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片（通常是页大小的整数倍），将这个片<strong>分成大小相等的块，并将这些块链接起来形成新的空闲链表</strong>。</li>
<li>要释放一个块，分配器只要简单地将这个块插入到相应的空闲链表的前部。因为不分割，所以也不会有合并。</li>
</ul>
<hr>
<ul>
<li>优点：
<ul>
<li>分配和释放块都很快，常数时间。</li>
<li>每个片中都是大小相等的块，不分割，不合并，内存开销少(不需要头部，脚部，单向链表只要一个指针)。</li>
<li>最小块大小为一个字，即succ指针</li>
</ul>
</li>
<li>缺点：
<ul>
<li>非常容易造成内部和外部碎片。</li>
</ul>
</li>
</ul>
<h4 id="分离适配"> 分离适配</h4>
<p>每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。</p>
<ul>
<li>为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，査找一个合适的块。</li>
<li>如果找到了一个，那么就（可选地）分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到，就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。</li>
<li>如果空闲链表中没有合适的块，那么就向操作系统请求额外的堆内存，从这个新的堆内存中<strong>分配出一个块</strong>，将剩余部分放置在适当的大小类中。</li>
<li>要释放一个块，执行合并，并将结果放置到相应的空闲链表中。</li>
</ul>
<p>分离适配方法是一种常见的选择，C 标准库中提供的 GNU malloc 包就是釆用的这种方法，因为这种方法既快速，对内存的使用也很有效率。</p>
<h4 id="伙伴系统"> 伙伴系统</h4>
<p>伙伴系统（buddy system）是分离适配的一种特例，其中每个大小类都是 2 的幂。基本的思路是假设一个堆的大小为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>m</span></span></span></span></span></span></span></span></span></span></span>个字，我们为每个块大小<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8491em;"></span><span><span>2</span><span><span><span><span style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>维护一个分离空闲链表，其中<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7804em;vertical-align:-0.136em;"></span><span>0</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8304em;vertical-align:-0.136em;"></span><span style="margin-right:0.03148em;">k</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.4306em;"></span><span>m</span></span></span></span>。请求块大小向上舍入到最接近的 2 的幂。最开始时，只有一个大小为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6644em;"></span><span><span>2</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>m</span></span></span></span></span></span></span></span></span></span></span> 个字的空闲块。</p>
<p>为了分配一个大小为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8491em;"></span><span><span>2</span><span><span><span><span style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的块，先找到第一个可用的大小足够的块。如果大小正好，结束。如果找到的块大了，则递归地二分割这个块，直到大小正好，剩下的半块（也叫做伙伴）被放置在相应的空闲链表中。为了释放一个大小为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8491em;"></span><span><span>2</span><span><span><span><span style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的块，只需要合并空闲的伙伴。当遇到一个已分配的伙伴时，就停止合并。</p>
<ul>
<li>关键事实：给定地址和块的大小，很容易计算出它的伙伴的地址。</li>
<li>主要优点：快速搜索和快速合并。</li>
<li>主要缺点：要求块大小为 2 的幂可能导致显著的内部碎片。</li>
</ul>
<h2 id="垃圾收集"> 垃圾收集</h2>
<p>垃圾收集器（garbage collector）是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为垃圾（garbage）。自动回收堆存储的过程叫做垃圾收集（garbage collection）。</p>
<h3 id="基本知识"> 基本知识</h3>
<p>垃圾收集器将内存视为一张有向可达图（reachability graph），其形式如图所示。
<img src="/assets/csapp/GarbageCollection.png" alt="垃圾收集" /><br>
该图的节点被分成一组根节点（root node）和一组堆节点（heap node）。</p>
<ul>
<li>每个堆节点对应于堆中的一个已分配块。</li>
<li>有向边 p→q 意味着块 p 中的某个位置指向块 q 中的某个位置。</li>
<li>根节点对应于本身不再堆中，但包含指向堆的指针的变量。</li>
<li>p是可达的：存在一条从任意根节点出发并到达 p 的有向路径</li>
</ul>
<p>Java 的垃圾收集器，对应用如何创建和使用指针有很严格的控制，能够维护可达图的一种精确的表示，因此也就能够回收所有垃圾。然而，诸如 C 和 C++ 这样的语言的收集器通常不能维持可达图的精确表示。这样的收集器也叫做保守的垃圾收集器（conservative garbage collector）。即每个可达块都被正确地标记为可达了，而一些不可达节点却可能被错误地标记为可达。</p>
<p>向malloc包中加入保守的GC后，malloc的流程为</p>
<ol>
<li>向malloc请求空间，找到了，返回。</li>
<li>找不到合适的空闲块，则调用GC，希望回收一些垃圾到空闲链表。</li>
<li>GC返回，malloc重试。成功找到，返回。</li>
<li>还是失败，向OS要求额外的内存。成功，返回指针，否则返回NULL。</li>
</ol>
<h3 id="mark-sweep垃圾收集器"> Mark&amp;Sweep垃圾收集器</h3>
<p>Mark&amp;Sweep 垃圾收集器由标记（mark）阶段和清除（sweep）阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来表示这个块是否被标记了。</p>
<p>描述所需函数</p>
<ul>
<li>ptr 定义为 typedef void* ptr：</li>
<li>ptr isPtr (ptr p)。如果 p 指向一个已分配块中的某个字，那么就返回一个指向这个块的起始位置的指针 b。否则返回 NULL。</li>
<li>int blockMarked(ptr b)。如果块 b 是已标记的，那么就返回 true。</li>
<li>int blockAllocated (ptr b)。如果块 b 是已分配的，那么就返回 true。</li>
<li>void markBlock (ptr b)。标记块 b。</li>
<li>int length (b)。返回块 b 的以字为单位的长度(不包括头部)。</li>
<li>void unmarkBlock (ptr b)。将块 b 的状态由已标记的改为未标记的。</li>
<li>ptr nextBlock (ptr b)。返回堆中块 b 的后继。</li>
</ul>
<div><pre><code><span>void</span> <span>mark</span><span>(</span>ptr p<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>(</span>b <span>=</span> <span>isPtr</span><span>(</span>p<span>)</span><span>)</span> <span>==</span> <span>NULL</span><span>)</span>
        <span>return</span><span>;</span>
    <span>if</span> <span>(</span><span>blockMarked</span><span>(</span>b<span>)</span><span>)</span>
        <span>return</span><span>;</span>
    <span>markBlock</span><span>(</span>b<span>)</span><span>;</span>
    len <span>=</span> <span>length</span><span>(</span>b<span>)</span><span>;</span>
    <span>for</span> <span>(</span>i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span>
        <span>mark</span><span>(</span>b<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>return</span><span>;</span>
<span>}</span>

<span>void</span> <span>sweep</span><span>(</span>ptr b<span>,</span> ptr end<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>b <span>&lt;</span> end<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>blockMarked</span><span>(</span>b<span>)</span><span>)</span>
            <span>unmarkBlock</span><span>(</span>b<span>)</span><span>;</span>
        <span>else</span> <span>if</span> <span>(</span><span>blockAllocated</span><span>(</span>b<span>)</span><span>)</span>
            <span>free</span><span>(</span>b<span>)</span><span>;</span>
        b <span>=</span> <span>nextBlock</span><span>(</span>b<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>标记阶段为每个根节点调用一次 mark 函数。</li>
<li>清理阶段循环遍历堆上的每个块，为每个调用 sweep 函数。直到某次循环没有清理任何块。</li>
</ul>
<hr>
<p>c语言的isPtr函数存在的问题</p>
<ul>
<li>C 不会用任何类型信息来标记内存位置。因此，对 isPtr 没有一种明显的方式来判断它的输入参数 p 是不是一个指针。这导致了C程序的Mark&amp;Sweep收集器必须是保守的。</li>
<li>即使 p 是一个指针，isPtr 也没有明显的方式来判断 p 是否指向一个已分配块的有效载荷中的某个位置。解决方法是将已分配块集合维护成一棵平衡二叉树，这棵树保持着这样一个属性：左子树中的所有块都放在较小的地址处，而右子树中的所有块都放在较大的地址处。每个已分配块的头部里有两个附加字段（left 和 right）。每个字段指向某个已分配块的头部。isPtr(ptr p) 函数用树来执行对已分配块的二分查找。在每一步中，它依赖于块头部中的大小字段来判断 p 是否落在这个块的范围之内。
<img src="/assets/csapp/GCBST.png" alt="垃圾收集平衡二叉树" /></li>
</ul>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/csapp/VP-PP.png" type="image/png"/>
    </item>
    <item>
      <title>编译器相关</title>
      <link>https://kigane.github.io/note/cs/compiler/</link>
      <guid>https://kigane.github.io/note/cs/compiler/</guid>
      <source url="https://kigane.github.io/rss.xml">编译器相关</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="gcc"> gcc</h2>
<p>gcc在编译代码时可以做出优化，通过选项-On(n=0,1,2...)确定优化等级。优化后的代码在debug时，打印某些变量时会出现<code>&lt;optimized out&gt;</code>。解决方法就是关闭优化选项。或者，如果你只关心某个变量的话，可以将其用<code>volatile</code>关键字修饰。</p>
<ul>
<li>-E 预编译 .c-&gt;.i 对应cpp，即c预处理器，主要是在扩展include和宏。</li>
<li>-S 编译为汇编代码 .i|.c-&gt;.s 对应cc1，即编译器，产生汇编代码。</li>
<li>-c 汇编 .s-&gt;.o 对应as，即汇编器，产生可重定位目标文件，所有的指令都以二进制表示。</li>
<li>-Idir 头文件搜索路径</li>
<li>-Ldir 将dir指定为搜索库(-l指定的)的路径</li>
<li>-llib 链接时，搜索liblib.a|liblib.so。如果有同名的静态库和动态库，则无-static时取动态库，有则取静态库。</li>
<li>-O 开启优化选项。Og, O1, O2等开启了不同的优化选项，从性能考虑，O1,O2优化效果较好，但产生的代码变化会很大，很难理解源码和机器代码的关系，所以，学习时通常使用Og选项，有一定的优化，但源码的整体结构可以很好保存。</li>
<li>-fno-stack-protector 关闭栈溢出检测</li>
</ul>
<hr>
<ul>
<li>-Wall 启用对某些用户可能会认为有问题(通常容易避免)的结构的警告。</li>
<li>-Werror 让所有的warning变成error。</li>
<li>-ggdb 产生给gdb用的调试信息。这意味着使用最有表达性的格式。(DWARF,stabs，如果两个都不支持则使用本地格式)</li>
</ul>
<h2 id="attribute"> attribute</h2>
<ul>
<li>__attribute__((unused)) 如果变量声明了，但没有被引用过，也不弹出警告</li>
<li>__attribute__((used)) 用于static函数或变量，告诉编译器，即使没被引用过也要在obj文件中保留(链接器删除未使用的section时，不会删除有该声明的函数或变量)。</li>
</ul>
<h2 id="工具"> 工具</h2>
<h3 id="反汇编器-objdump"> 反汇编器 objdump</h3>
<ul>
<li>objdump -d main.o</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>gdb</title>
      <link>https://kigane.github.io/note/cs/gdb-cheatsheet/</link>
      <guid>https://kigane.github.io/note/cs/gdb-cheatsheet/</guid>
      <source url="https://kigane.github.io/rss.xml">gdb</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="gdb-cheatsheet"> gdb cheatsheet</h2>
<p><a href="https://sourceware.org/gdb/onlinedocs/gdb/index.html#SEC_Contents" target="_blank" rel="noopener noreferrer">gdb 文档</a></p>
<ul>
<li>-g: 生成debugging symbols，使得调试更高效。-ggdb，包含gdb规定的符号。</li>
</ul>
<p>gdb [--args] program [args]进入debug模式</p>
<ul>
<li>set args &lt;args&gt;</li>
<li>run: 执行程序</li>
<li>kill: 关闭执行的程序</li>
<li>help</li>
</ul>
<p>检查栈</p>
<ul>
<li>backtrace/where | bt: 查看调用栈</li>
<li>backtrace/where full: 查看调用栈，也打印栈帧中的变量</li>
<li>frame frame#: 查看指定帧(backtrace列出的信息开头的数字)</li>
</ul>
<p>变量和内存</p>
<ul>
<li>x/nfu addr: examine addr。查看指定地址的值
<ul>
<li>n: 要打印的unit数量</li>
<li>f: format</li>
<li>u: unit (b:Byte 1B, h:Half-word 2B, w:Word 4B, g:Giant word 8B)</li>
</ul>
</li>
<li>p &lt;what&gt;: 查看变量的值</li>
<li>p arr[n]@m: 查看数组arr从n开始数，共m个元素</li>
<li>print/format &lt;what&gt;: 查看变量的值</li>
<li>display/format &lt;what&gt;: 在每个step指令后打印变量的值</li>
<li>undisplay display#: 不再监视</li>
<li>enable/disable display#</li>
<li>&lt;what&gt;
<ul>
<li>expressions</li>
<li>filename::variable_name</li>
<li>function::variable_name</li>
<li>{type}address : 在address处的内容，解释为C的type类型。</li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.854em;vertical-align:-0.1944em;"></span><span>re</span><span style="margin-right:0.03588em;">g</span><span>i</span><span>s</span><span>t</span><span style="margin-right:0.02778em;">er</span><span style="margin-right:0.2778em;"></span><span>:</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6833em;"></span><span>有名字的寄存器，如</span></span></span></span>esp--栈指针，<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>e</span><span>b</span><span>p</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.7667em;vertical-align:-0.0833em;"></span><span>−</span><span>帧基址，</span></span></span></span>eip--指令指针</li>
</ul>
</li>
<li>format
<ul>
<li>a: 指针</li>
<li>c: 读为int，打印为char</li>
<li>d: 有符号int</li>
<li>f: 浮点数</li>
<li>o: 八进制int</li>
<li>s: Try to treat as C string</li>
<li>t: 二进制int</li>
<li>u: 无符号int</li>
<li>x: 十六进制int</li>
</ul>
</li>
</ul>
<p>查看源码</p>
<ul>
<li>list line_number: 查看101行附件10行</li>
<li>list from,to: 查看从from到to行</li>
<li>list -: 查看前10行</li>
<li>list &lt;where&gt;</li>
</ul>
<p>断点</p>
<ul>
<li>break where: 在指定位置设置一个断点(会输出断点所在具体位置，注意到断点有序号，Breakpoint 1 at 0x29fa0: file main.cc, line 52.)</li>
<li>where
<ul>
<li>function_name</li>
<li>line_number: 当前文件的某行</li>
<li>file:line_number</li>
</ul>
</li>
<li>delete breakpoint#: 删除指定断点</li>
<li>enable breakpoint</li>
<li>disable breakpoint</li>
<li>clear: 删除所有断点</li>
<li>condition 1 var==666: 仅当变量var的值为666时，才触发断点1。</li>
<li>break/watch &lt;where&gt; if &lt;condition&gt;</li>
<li>watch where // breakpoint 和 watchpoint 共用编号。</li>
<li>watchpoint 有两种实现方式，具体取决于你的系统。软件实现方式为在每一步执行后都测试一次expr的值，会很慢。硬件方式更快。</li>
<li>watch [-l|-location] expr [thread thread-id] [mask maskvalue]  为expr设置一个监视点。如果expr的值改变了，则停止执行。
<ul>
<li>thread thread-id 指定某个线程，只有该线程修改expr的值时才停止执行。(仅限硬件实现)</li>
<li>-l 告诉gdb，如果expr的结果是个地址，则查看该地址的内容。如果结果不是地址，则输出一个错误。</li>
<li>mask maskvalue 默认开启-l。maskvalue用于同时查看多数地址。 watch foo mask 0xffffff00？</li>
</ul>
</li>
<li>rwatch expr 在expr被程序读取时break</li>
<li>awatch expr 在expr被读取或被修改时都break</li>
<li>delete/enable/disable watchpoint#</li>
</ul>
<p>步进</p>
<ul>
<li>gdb的一个有用的特性：如果直接按回车，会重复执行上一个命令</li>
<li>step: 到下一行。如果有函数会进入函数</li>
<li>next: 到下一行。不会进入函数</li>
<li>finish: 将当前函数执行完</li>
<li>continue | cont: 继续正常执行</li>
<li>quit: 退出</li>
</ul>
<p>反向执行</p>
<ul>
<li>record 反向执行的前置条件</li>
<li>reverse-step</li>
<li>reverse-next</li>
<li>reverse-continue</li>
<li>reverse-finish 回到函数执行前</li>
<li>set exec-direction reverse 所有next,step...全变为逆向操作</li>
<li>set exec-direction forward 恢复正常</li>
</ul>
<p>信息</p>
<ul>
<li>info args: 当前栈帧的函数参数</li>
<li>info breakpoints/watchpoints</li>
<li>info locals: 当前栈帧的本地变量</li>
<li>info sharedlibrary: 列出已加载的动态库</li>
<li>info signals: 列出所有信号和他们当前是如何处理的</li>
<li>info threads</li>
<li>show directories: 列出GDB搜索涉及到的源文件</li>
<li>show listsize</li>
<li>whatis variable_name: 输出变量的类型</li>
</ul>
<h2 id="gdb-tui"> gdb-tui</h2>
<p>标志</p>
<ul>
<li>
<p><code>&gt;</code> 当前执行的行</p>
</li>
<li>
<p>断点表示 [b|B][+|-]</p>
<ul>
<li><code>b</code> 表示还没到的断点</li>
<li><code>B</code> 表示至少到过一次的断点</li>
<li><code>+</code> 表示 enabled</li>
<li><code>-</code> 表示 disabled</li>
</ul>
</li>
<li>
<p>C-x a/A/C-a: 进入或离开TUI模式</p>
</li>
<li>
<p>C-x 1: 保留一个窗口</p>
</li>
<li>
<p>C-x 2: 保留两个窗口</p>
</li>
<li>
<p>C-x o: 切换当前活动的窗口</p>
</li>
<li>
<p>C-x s: 切换到TUI的单键模式</p>
</li>
<li>
<p>PgUp,PgDn,上下左右可用于操作活动窗口。</p>
</li>
<li>
<p>当焦点不在cmd窗口时，C-p相当于Up,C-b相当于Left,C-f相当于Right,C-n相当于Down</p>
</li>
<li>
<p>C-l: 刷新窗口</p>
</li>
</ul>
<p>单键模式</p>
<ul>
<li>s: step</li>
<li>i: step Into</li>
<li>n: next</li>
<li>o: step Over</li>
<li>r: run</li>
<li>c: continue</li>
<li>f: finish</li>
<li>d: down 在frame stack中向下一层</li>
<li>u: up 在frame stack中向上一层</li>
<li>q: 退出单键模式</li>
<li>v: info local</li>
<li>w: where</li>
</ul>
<p>TUI命令</p>
<ul>
<li>
<p>tui enable: 进入上次使用的tui窗口模式，或默认窗口模式。</p>
</li>
<li>
<p>tui disable</p>
</li>
<li>
<p>tui new-layout name window weight [window weight ...]: 新建一个名为name的TUI窗口布局。</p>
<ul>
<li>可以使用layout name使用该布局</li>
<li>window 有四种 src,asm,regs,cmd</li>
<li>weight 是权重，用于确定每个窗口占屏幕的比例。status的权重应总是设为0</li>
<li>默认是从上到下分割。加-horizontal可改为从左到右分割。</li>
<li>示例1：(gdb) tui new-layout example src 1 regs 1 status 0 cmd 1</li>
<li>示例2：(gdb) tui new-layout example {-horizontal src 1 asm 1} 2 status 0 cmd 1</li>
<li>9.2版本还没有实装</li>
</ul>
</li>
<li>
<p>layout name：使用内置布局或新建的布局</p>
<ul>
<li>prev: 前一个</li>
<li>next: 后一个</li>
<li>src: 显示源码和命令窗口</li>
<li>asm：显示汇编和命令窗口</li>
<li>split：显示源码，汇编和命令窗口</li>
<li>regs：显示寄存器窗口。如果在src模式则上为寄存器，中为源码。如果在split和asm模式，则上为寄存器，中为汇编。</li>
</ul>
</li>
<li>
<p>focus name: 改变当前活动窗口。</p>
</li>
<li>
<p>refresh: 刷新窗口</p>
</li>
<li>
<p>winheight name +count： 改变窗口大小</p>
</li>
<li>
<p>winheight name -count： 改变窗口大小</p>
</li>
<li>
<p>tui reg group：显示不同的寄存器分组</p>
<ul>
<li>general: 通用寄存器</li>
<li>float: 浮点数寄存器</li>
<li>system: 系统寄存器</li>
<li>vector: 向量寄存器</li>
<li>all</li>
</ul>
</li>
<li>
<p>set tui compact-source [on|off]：设置源码的行号和代码间的距离。on-仅一个空格，off-一个tab。</p>
</li>
</ul>
<h2 id="小技巧"> 小技巧</h2>
<ul>
<li>对一个大数组，p arr[n]@m，查看数组arr从n开始数，共m个元素</li>
<li>gdb 命令输出在src模式下可见部分太小了。可以使用
<ul>
<li>set trace-commands on</li>
<li>set logging on</li>
<li>cd where/gdb/is/running</li>
<li>tail -f -n 30 gdb.txt</li>
<li>less +F gdb.txt 可以代替tail。 ctrl+c，退出等待输入模式，进入普通less模式，shift+f进入。</li>
<li>进入TUI模式后，日志会停止，这是个gdb bug。先set logging off，再set logging on即可正常显示。</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>git</title>
      <link>https://kigane.github.io/note/cs/git/</link>
      <guid>https://kigane.github.io/note/cs/git/</guid>
      <source url="https://kigane.github.io/rss.xml">git</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="资源"> 资源</h2>
<p><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener noreferrer">交互式Git入门网站 强烈推荐!!!</a><br>
<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener noreferrer">Pro Git 中文版</a><br>
<a href="https://ohshitgit.com/" target="_blank" rel="noopener noreferrer">Oh Shit, Git!?! 简短的介绍了如何从Git错误中恢复</a></p>
<p><a href="https://eagain.net/articles/git-for-computer-scientists/" target="_blank" rel="noopener noreferrer">Git 的数据模型</a><br>
<a href="https://jwiegley.github.io/git-from-the-bottom-up/1-Repository/1-directory-content-tracking.html" target="_blank" rel="noopener noreferrer">Git from the Bottom Up</a></p>
<h2 id="git-的数据模型"> Git 的数据模型</h2>
<h3 id="快照"> 快照</h3>
<p>在Git的术语里，文件被称作Blob对象，也就是一组数据。目录则被称之为“树”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。</p>
<div><pre><code>&amp;lt;root&gt; (tree)
|
+- foo (tree)
|  |
|  + bar.txt (blob, contents = &quot;hello world&quot;)
|
+- baz.txt (blob, contents = &quot;git is wonderful&quot;)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>这个顶层的树包含了两个元素，一个名为 “foo” 的树，以及一个 blob 对象 “baz.txt”。</p>
<h3 id="历史记录"> 历史记录</h3>
<p>在 Git 中，历史记录是一个由快照组成的有向无环图。这代表 Git 中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p>
<p>在 Git 中，这些快照被称为“提交”。</p>
<h3 id="数据模型的伪码表示"> 数据模型的伪码表示</h3>
<div><pre><code><span>//</span> 文件就是一组数据
<span>type</span> blob <span>=</span> array<span>&lt;</span>byte<span>></span>

<span>//</span> 一个包含文件和目录的目录
<span>type</span> tree <span>=</span> <span>map</span><span>&lt;</span>string<span>,</span> tree <span>|</span> blob<span>></span>

<span>//</span> 每个提交都包含一个父辈，元数据和顶层树
<span>type</span> commit <span>=</span> struct <span>{</span>
    parent<span>:</span> array<span>&lt;</span>commit<span>></span>
    author<span>:</span> string
    message<span>:</span> string
    snapshot<span>:</span> tree
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="对象和内存寻址"> 对象和内存寻址</h3>
<div><pre><code><span>//</span> git中的对象类型
<span>type</span> <span>object</span> <span>=</span> blob <span>|</span> tree <span>|</span> commit

objects <span>=</span> <span>map</span><span>&lt;</span>string<span>,</span> <span>object</span><span>></span>

<span>//</span> Git 在储存数据时，所有的对象都会基于它们的 SHA<span>-</span><span>1</span> 哈希 进行寻址
<span>def</span> <span>store</span><span>(</span><span>object</span><span>)</span><span>:</span>
    <span>id</span> <span>=</span> sha1<span>(</span><span>object</span><span>)</span>
    objects<span>[</span><span>id</span><span>]</span> <span>=</span> <span>object</span>

<span>def</span> <span>load</span><span>(</span><span>id</span><span>)</span><span>:</span>
    <span>return</span> objects<span>[</span><span>id</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="引用"> 引用</h3>
<p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。(Git对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。但还是很不方便)</p>
<p>针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。<strong>引用是指向提交的指针</strong>。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，master 引用通常会指向主分支的最新一次提交。</p>
<div><pre><code>references <span>=</span> <span>map</span><span>&lt;</span>string<span>,</span> string<span>></span>

<span>def</span> <span>update_reference</span><span>(</span>name<span>,</span> <span>id</span><span>)</span><span>:</span>
    references<span>[</span>name<span>]</span> <span>=</span> <span>id</span>

<span>def</span> <span>read_reference</span><span>(</span>name<span>)</span><span>:</span>
    <span>return</span> references<span>[</span>name<span>]</span>

<span>def</span> <span>load_reference</span><span>(</span>name_or_id<span>)</span><span>:</span>
    <span>if</span> name_or_id <span>in</span> references<span>:</span>
        <span>return</span> load<span>(</span>references<span>[</span>name_or_id<span>]</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> load<span>(</span>name_or_id<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p>
<p>如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向。</p>
<h3 id="仓库"> 仓库</h3>
<p>Git仓库就是对象(文件，目录，提交)和引用(分支，HEAD, hash, tag)。</p>
<p>在硬盘上，Git仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 git 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>
<h2 id="相对引用"> 相对引用</h2>
<ul>
<li>使用 ref^ 向上移动1个提交记录(ref^^,2个)</li>
<li>使用 ref~&lt;num&gt; 向上移动多个提交记录，如 ~3(1也可以省略)</li>
<li>应用：移动分支，使用-f选项让分支指向另一个提交。例如:<code>git branch -f main HEAD~3</code></li>
<li>^&lt;num&gt;: 如果父节点不止一个，ref<sup>就指向产生该节点(在这里merge的)的父节点，ref</sup>2就指向另一个节点</li>
<li>链式移动: <code>git checkout ~^2~3</code></li>
</ul>
<h2 id="暂存区"> 暂存区</h2>
<p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。允许您指定下次快照中要包括那些改动。</p>
<p>使用场景：您开发了两个独立的特性，然后希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。</p>
<h2 id="tag"> tag</h2>
<p><strong>永远指向某个提交记录的标识</strong>。通常软件发布新的大版本，或者是修正一些重要的Bug或是增加了某些新特性这种重要的修改可以添加一个tag。</p>
<p>tag可以(在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签)永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<div><pre><code><span>git</span> tag tagName refspec <span># 在refspec提交上建立一个标签tagName</span>
<span>git</span> tag tagName <span># 在HEAD指向的提交上建立一个标签</span>
<span>git</span> describe refspec <span># 结果格式为tagName_distance_ghash，tagName是离refspec最近的tag的名称，distance是refspec离tag的距离，hash是refspec hash值的前几位。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="cheatsheet"> cheatsheet</h2>
<p>Git中“refspec” 是一个自造的词，意思是Git能识别的位置(比如分支foo或者HEAD~1)。如果需要refspec参数缺省为HEAD。</p>
<p>基础</p>
<ul>
<li>git help &lt;command&gt;: 获取 git 命令的帮助信息</li>
<li>git init: 创建一个新的 git 仓库，其数据会存放在一个名为 .git 的目录下</li>
<li>git status: 显示当前的仓库状态</li>
<li>git add &lt;filename&gt;: 添加文件到暂存区</li>
<li>git commit: 创建一个新的提交</li>
<li>git commit --allow-empty: 创建一个新的提交，允许没有修改</li>
<li>git log: 显示历史日志</li>
<li>git log --author who: 显示who提交的历史日志</li>
<li>git log --all --graph --decorate: 可视化历史记录（有向无环图）</li>
<li>git diff &lt;filename&gt;: 显示与暂存区文件的差异</li>
<li>git diff &lt;revision&gt; &lt;filename&gt;: 显示某个文件两个版本之间的差异</li>
<li>git checkout &lt;revision&gt;: 更新 HEAD 和目前的分支</li>
</ul>
<p>分支和合并</p>
<ul>
<li>git branch: 显示分支</li>
<li>git branch &lt;name&gt;: 创建分支</li>
<li>git checkout -b &lt;name&gt;: 创建分支并切换到该分支</li>
<li>git merge refspec: 合并到当前分支</li>
<li>git mergetool: 使用工具来处理合并冲突</li>
<li>git rebase: 将一系列补丁变基（rebase）为新的基线</li>
</ul>
<p>远端操作</p>
<ul>
<li>git remote: 列出远端</li>
<li>git remote add &lt;name&gt; &lt;url&gt;: 添加一个远端</li>
<li>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;: 将对象传送至远端并更新远端引用</li>
<li>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;: 创建本地和远端分支的关联关系</li>
<li>git fetch: 从远端获取对象/索引</li>
<li>git pull: 相当于 git fetch; git merge</li>
<li>git clone: 从远端下载仓库</li>
</ul>
<p>撤销</p>
<ul>
<li>git commit --amend: 编辑提交的内容或信息。在提交树中HEAD所指节点的父节点下生成一个新的commit节点，并指向新的commit节点，原节点的子节点不会保留。所以最好只对叶节点使用 --amend.</li>
<li>git reset HEAD~1: 撤销最近一次commit，在reset后所做的变更还在，但是处于未加入暂存区状态。适合在本地修改。</li>
<li>git revert refspec: 会commit一次，将最近一次commit的修改撤销。适合多人协作时，撤销已push的修改。</li>
<li>git checkout -- &lt;file&gt;: 丢弃修改</li>
</ul>
<p>Git 高级操作</p>
<ul>
<li>git config: Git 是一个 高度可定制的 工具</li>
<li>git clone --depth=1: 浅克隆（shallow clone），不包括完整的版本历史信息</li>
<li>git add -p: 交互式暂存</li>
<li>git rebase to [from]: from不写默认为HEAD所指节点。将从from节点和to节点的最近公共父节点(不包括该父节点)到from结点本身的所有节点按顺序复制到to节点下，HEAD将指向被复制的from节点，另外from节点(路径上的其他节点的引用不会动)上的引用(分支，tag等)也会指向新的from节点。用于将from分支上的工作转移到to分支上。PS：如果from为to的祖先节点，则rebase只是将from的引用移动到to上。</li>
<li>git rebase -i ref~n: 交互式变基(经典左闭右开/下闭上开)</li>
<li>git cherry-pick refspec1 refspec2 ...:可以将提交树上任何其他地方的提交记录取过来追加到HEAD上（不能是HEAD上游的提交）</li>
<li>git blame: 查看最后修改某行的人</li>
<li>git stash: 暂时移除工作目录下的修改内容</li>
<li>git bisect: 通过二分查找搜索历史记录</li>
<li>git describe refspec: 结果格式为tagName_distance_ghash，tagName是离refspec最近的tag的名称，distance是refspec离tag的距离，hash是refspec hash值的前几位。</li>
<li>.gitignore: 指定 故意不追踪的文件</li>
</ul>
<h3 id="git-stash"> git stash</h3>
<p><code>git stash</code>命令会暂时缓存任何你未提交的修改，包括暂存区的和未暂存的(没有通过<code>git add</code>命令添加到暂存区的，包括新add的增删文件，修改add过的文件)，不包括未追踪的文件。stash就相当于将之前的修改都隐藏了起来，之后的操作不会受到之前修改的限制。
注意：stash只保留在本地库中，不会被推送到远程库。</p>
<div><pre><code><span># 做一些修改1</span>
<span>git</span> stash
<span># 再做一些修改2</span>
<span>git</span> stash
<span># 再再做一些修改3，并提交 假设三次修改的是不同的文件</span>
<span># some changes</span>
<span>git</span> commit
<span># 不想要修改2了</span>
<span>git</span> stash pop
<span># 继续从修改1开始</span>
<span>git</span> stash apply
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>注意：git stash apply会将修改应用到所有分支。比如，在test分支修改了一个文件，stash以后再apply回来，这样master分支中也会有一个未提交的修改。</p>
<h2 id="远程仓库"> 远程仓库</h2>
<h3 id="git-clone"> git clone</h3>
<p>git clone somerepo后，本地就有了somerepo的完整提交树，并且多了origin/master,origin/dev....等多了origin/前缀的远程分支(另有origin/HEAD-&gt;origin/main说明远程分支的HEAD指向哪里)。</p>
<p>远程分支反映了远程仓库(在你上次和它通信时)的状态。</p>
<p>远程分支有一个特别的属性，在你检出时自动进入分离HEAD状态(不是HEAD指向的分支上有*，而是HEAD独立显示出来)。Git这么做是因为不能直接在这些分支上进行操作, 你必须在本地完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>
<h3 id="git-fetch"> git fetch</h3>
<p>完成了仅有的但是很重要的两步:</p>
<ol>
<li>从远程仓库下载本地仓库中缺失的提交记录</li>
<li>更新远程分支指针(如 o/main)</li>
</ol>
<p>实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。但并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</p>
<p>要实际更新，需要使用git merge将远程和本地分支合并。(git cherry-pick, git rebase也可以)</p>
<h3 id="git-pull"> git pull</h3>
<p>实际等同于 git fetch + git merge。
用法参考<code>git push</code>/<code>git fetch</code></p>
<h3 id="git-push"> git push</h3>
<p><code>git push remoteRepo place</code> (remoteRepo 通常为 origin)<br>
<code>git push remoteRepo &lt;source&gt;:&lt;remote branch&gt;</code>  (source是refspec，如果remote branch是远程仓库中的分支名(没有origin/前缀)且不存在会自动创建新的)
<code>git push remoteRepo :foo</code> (会删除远程的foo分支)
将本地提交同步到远程，并将本地仓库的远程分支也更新好。</p>
<p>PS：git fetch 语法类似，只是方向相反罢了。</p>
<h3 id="最常见团队合作工作流"> 最常见团队合作工作流</h3>
<p>从某个commit之后，你和同事分别修改各自的代码，现在你的同事已经将他的代码同步到远程库了，你的代码该如何提交。(假设没有冲突)。</p>
<p>方案一：git fetch; git rebase origin/main; git push
方案二: git fetch; git merge origin/main; git push
方案一简化版：git pull --rebase; git push
方案二简化版: git pull; git push</p>
<h3 id="远程服务器拒绝-remote-rejected"> 远程服务器拒绝!(Remote Rejected)</h3>
<p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<blockquote>
<p>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</p>
</blockquote>
<p>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p>
<p>你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p>
<p>解决办法
新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>
<div><pre><code><span>git</span> reset --hard o/main <span># 重置索引和工作树。 自o/main以来的工作树中跟踪文件的任何更改都被丢弃。</span>
<span>git</span> checkout -b feature rawmainSHA <span># reset不会删除已有的commit。所以仍能checkout到你修改过commit，同时新建分支。</span>
<span>git</span> push origin feature <span># 将你的修改(现在在feature中)同步到远端的feature分支</span>

<span># 我认为更好的方法</span>
<span>git</span> branch feature
<span>git</span> push origin feature
<span>git</span> reset --hard origin/main
<span>git</span> checkout feature
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>然后再申请pull request。</p>
<h3 id="合并特性分支"> 合并特性分支</h3>
<p>有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p>
<p>这个工作流，分两个步骤：</p>
<ol>
<li>将特性分支集成到 main 上</li>
<li>推送并更新远程分支 git pull --rebase; git push</li>
</ol>
<h3 id="rebase-和-merge"> rebase 和 merge</h3>
<p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>
<ul>
<li>优点: Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li>
<li>缺点: Rebase 修改了提交树的历史。比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</li>
</ul>
<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人可能更喜欢干净的提交树，于是偏爱 rebase。</p>
<h3 id="远程跟踪"> 远程跟踪</h3>
<p>直接了当地讲，main 和 o/main 的关联关系就是由分支的“remote tracking”属性决定的。main 被设定为跟踪 o/main —— 这意味着为 main 分支指定了推送的目的地以及拉取后合并的目标。</p>
<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 o/main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 main。
这也解释了为什么会在克隆的时候会看到下面的输出：</p>
<blockquote>
<p>local branch &quot;main&quot; set to track remote branch &quot;o/main&quot;</p>
</blockquote>
<p>自己指定本地分支和远程分支的映射</p>
<ol>
<li>git checkout -b notmain origin/main</li>
<li>git branch -u origin/main foo # foo不写就默认使用当前分支</li>
</ol>
<p>之后commit,push这个notmain分支到远程库，实际就会更新远程库的main分支。</p>
]]></content:encoded>
    </item>
    <item>
      <title>ICS-PA心得</title>
      <link>https://kigane.github.io/note/cs/ics-pa/</link>
      <guid>https://kigane.github.io/note/cs/ics-pa/</guid>
      <source url="https://kigane.github.io/rss.xml">ICS-PA心得</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="pa1"> PA1</h2>
<h3 id="nemu准备"> NEMU准备</h3>
<div><pre><code>nemu
├── include                    # 存放全局使用的头文件
│   ├── common<span>.</span>h               # 公用的头文件
│   ├── cpu
│   │   ├── decode<span>.</span>h           # 译码相关
│   │   └── exec<span>.</span>h             # 执行相关
│   ├── debug<span>.</span>h                # 一些方便调试用的宏
│   ├── device                 # 设备相关
│   ├── isa                    # <span>ISA</span>相关
│   ├── isa<span>.</span>h                  # <span>ISA</span>相关
│   ├── macro<span>.</span>h                # 一些方便的宏定义
│   ├── memory                 # 访问内存相关
│   ├── monitor
│   │   ├── log<span>.</span>h              # 日志文件相关
│   │   └── monitor<span>.</span>h
│   └── rtl
│       ├── pesudo<span>.</span>h           # <span>RTL</span>伪指令
│       └── rtl<span>.</span>h              # <span>RTL</span>指令相关定义
├── Makefile                   # 指示<span>NEMU</span>的编译和链接
├── Makefile<span>.</span>git               # git版本控制相关
├── runall<span>.</span>sh                  # 一键测试脚本
└── src                        # 源文件
    ├── device                 # 设备相关
    ├── engine
    │   └── interpreter        # 解释器的实现
    ├── isa                    # <span>ISA</span>相关的实现
    │   ├── mips32
    │   ├── riscv32
    │   ├── riscv64
    │   └── x86
    ├── main<span>.</span>c                 # 你知道的<span>...</span>
    ├── memory
    │   └── paddr<span>.</span>c            # 物理内存访问
    └── monitor
        ├── cpu<span>-</span>exec<span>.</span>c         # 指令执行的主循环
        ├── debug              # 简易调试器相关
        │   ├── expr<span>.</span>c         # 表达式求值的实现
        │   ├── log<span>.</span>c          # 日志文件相关
        │   ├── ui<span>.</span>c           # 用户界面相关
        │   └── watchpoint<span>.</span>c   # 监视点的实现
        └── monitor<span>.</span>c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><ul>
<li>make ISA=$ISA run</li>
<li>在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1，但参数类型是uint64_t,因此实际的值为<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>64</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>，即0xffffffffffffffff。</li>
<li>三个对调试有用的宏(在nemu/include/debug.h中定义)
<ul>
<li>Log()是printf()的升级版, 专门用来输出调试信息, 同时还会输出使用Log()所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置</li>
<li>Assert()是assert()的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息</li>
<li>panic()用于输出信息并结束程序, 相当于无条件的assertion fail</li>
</ul>
</li>
<li>内存通过在nemu/src/memory/paddr.c中定义的大数组pmem来模拟. 在客户程序运行的过程中, 总是使用vaddr_read()和vaddr_write() (在nemu/include/memory/vaddr.h中定义)来访问模拟的内存. vaddr, paddr分别代表虚拟地址和物理地址.</li>
<li>&quot;单元&quot;是指有独立含义的子串, 它们正式的称呼叫token.</li>
<li>\33 即 ESC。</li>
<li>makefile中使用awk，因为makefile中<code>$</code>会被特殊对待，所以awk的program text中的<code>$</code>要用<code>$$</code>表示。注意awk的action要写在<code>{}</code>中。</li>
<li>fopen文件路径，在nemu目录下make run时，当前目录就是nemu。</li>
<li>超级经典错误，if (tokens[p].type = '*')。。。。少写个等号</li>
<li>strncpy(dest, src, n) 如果n个字符中没有'\0'，dest中不会主动加。如果dest中原来字符数大于n,则复制后要使src==dest，需要手动添加'\0'(dest[n] = '\0')</li>
</ul>
<div><pre><code><span>&lt;</span>expr<span>></span> <span>:</span><span>:</span><span>=</span> <span>&lt;</span>number<span>></span>    # 一个数是表达式
  <span>|</span> <span>"("</span> <span>&lt;</span>expr<span>></span> <span>")"</span>     # 在表达式两边加个括号也是表达式
  <span>|</span> <span>&lt;</span>expr<span>></span> <span>"+"</span> <span>&lt;</span>expr<span>></span>  # 两个表达式相加也是表达式
  <span>|</span> <span>&lt;</span>expr<span>></span> <span>"-"</span> <span>&lt;</span>expr<span>></span>  # 接下来你全懂了
  <span>|</span> <span>&lt;</span>expr<span>></span> <span>"*"</span> <span>&lt;</span>expr<span>></span>
  <span>|</span> <span>&lt;</span>expr<span>></span> <span>"/"</span> <span>&lt;</span>expr<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="如何调试"> 如何调试</h3>
<p>一些软件工程相关的概念:</p>
<ul>
<li>Fault: 实现错误的代码, 例如if (p = NULL)</li>
<li>Error: 程序执行时不符合预期的状态, 例如p被错误地赋值成NULL</li>
<li>Failure: 能直接观测到的错误, 例如程序触发了段错误</li>
</ul>
<p>调试其实就是从观测到的failure一步一步回溯寻找fault的过程, 找到了fault之后, 我们就很快知道应该如何修改错误的代码了. 但从上面的例子也可以看出, 调试之所以不容易, 恰恰是因为:</p>
<ul>
<li>fault不一定马上触发error</li>
<li>触发了error也不一定马上转变成可观测的failure</li>
<li>error会像滚雪球一般越积越多, 当我们观测到failure的时候, 其实已经距离fault非常遥远了</li>
</ul>
<p>理解了这些原因之后, 我们就可以制定相应的策略了:</p>
<ul>
<li>尽可能把fault转变成error. 这其实就是测试做的事情, 所以我们在上一节中加入了表达式生成器的内容, 来帮助大家进行测试, 后面的实验内容也会提供丰富的测试用例. 但并不是有了测试用例就能把所有fault都转变成error了, 因为这取决于测试的覆盖度. 要设计出一套全覆盖的测试并不是一件简单的事情, 越是复杂的系统, 全覆盖的测试就越难设计. 但是, 如何提高测试的覆盖度, 是学术界一直以来都在关注的问题.</li>
<li>尽早观测到error的存在. 观测到error的时机直接决定了调试的难度: 如果等到触发failure的时候才发现error的存在, 调试就会比较困难; 但如果能在error刚刚触发的时候就观测到它, 调试难度也就大大降低了. 事实上, 你已经见识过一些有用的工具了:
<ul>
<li>-Wall, -Werror: 在编译时刻把潜在的fault直接转变成failure. 这种工具的作用很有限, 只能寻找一些在编译时刻也觉得可疑的fault, 例如if (p = NULL). 不过随着编译器版本的增强, 编译器也能发现代码中的一些未定义行为. 这些都是免费的午餐, 不吃就真的白白浪费了.</li>
<li>assert(): 在运行时刻把error直接转变成failure. assert()是一个很简单却又非常强大的工具, 只要在代码中定义好程序应该满足的特征, 就一定能在运行时刻将不满足这些特征的error拦截下来. 例如链表的实现, 我们只需要在代码中插入一些很简单的assert()(例如指针解引用时不为空), 就能够几乎告别段错误. 但是, 编写这些assert()其实需要我们对程序的行为有一定的了解, 同时在程序特征不易表达的时候, assert()的作用也较为有限.</li>
<li>printf(): 通过输出的方式观察潜在的error. 这是用于回溯fault时最常用的工具, 用于观测程序中的变量是否进入了错误的状态. 在NEMU中我们提供了输出更多调试信息的宏Log(), 它实际上封装了printf()的功能. 但由于printf()需要根据输出的结果人工判断是否正确, 在便利程度上相对于assert()的自动判断就逊色了不少.</li>
<li>GDB: 随时随地观测程序的任何状态. 调试器是最强大的工具, 但你需要在程序行为的茫茫大海中观测那些可疑的状态, 因此使用起来的代价也是最大的.</li>
</ul>
</li>
</ul>
<p>建议:</p>
<ul>
<li>总是使用-Wall和-Werror</li>
<li>尽可能多地在代码中插入assert()</li>
<li>assert()无法捕捉到error时, 通过printf()输出可疑的变量, 期望能观测到error</li>
<li>printf()不易观测error时, 通过GDB理解程序的精确行为</li>
</ul>
<h3 id="一条指令在nemu中的执行过程"> 一条指令在NEMU中的执行过程</h3>
<p>事实上, 一个字节最多只能区分256种不同的指令形式. 当指令形式的数目大于256时, 我们需要使用另外的方法来识别它们. x86中有主要有两种方法来解决这个问题(在PA2中你都会遇到这两种情况):</p>
<ul>
<li>一种方法是使用转义码(escape code), x86中有一个2字节转义码 0x0f, 当指令opcode的第一个字节是0x0f时, 表示需要再读入一个字节才能决定具体的指令形式(部分条件跳转指令就属于这种情况). 后来随着各种SSE指令集的加入, 使用2字节转义码也不足以表示所有的指令形式了, x86在2字节转义码的基础上又引入了3字节转义码, 当指令opcode的前两个字节是0x0f和0x38时, 表示需要再读入一个字节才能决定具体的指令形式.</li>
<li>另一种方法是使用ModR/M字节中的扩展opcode域来对opcode的长度进行扩充. 有些时候, 读入一个字节也还不能完全确定具体的指令形式, 这时候需要读入紧跟在opcode后面的ModR/M字节, 把其中的reg/opcode域当做opcode的一部分来解释, 才能决定具体的指令形式. x86把这些指令划分成不同的指令组(instruction group), 在同一个指令组中的指令需要通过ModR/M字节中的扩展opcode域来区分.</li>
</ul>
<p>最一般的寻址格式是<br>
displacement(R[base_reg], R[index_reg], scale_factor)<br>
相应内存地址的计算方式为<br>
addr = R[base_reg] + R[index_reg] * scale_factor + displacement<br>
其它寻址格式都可以看作这种一般格式的特例</p>
<p>在NEMU中, RTL寄存器只有以下这些</p>
<ul>
<li>不同ISA的通用寄存器(在nemu/include/isa/$ISA.h中定义)</li>
<li>id_src, id_src2和id_dest中的操作数内容val(在nemu/include/cpu/decode.h中定义).</li>
<li>临时寄存器s0, s1, s2和t0(在nemu/include/rtl/rtl.h中定义)</li>
<li>零寄存器rz(在nemu/src/monitor/cpu-exec.c中定义), 它的值总是0</li>
<li>x86的ISA相关译码信息中的内存基地址mbr</li>
</ul>
<p>RTL基本指令包括(我们使用了一些简单的正则表达式记号):</p>
<ul>
<li>寄存器-寄存器类型和寄存器-立即数类型的基本算术/逻辑运算, 包括rtl_(add|sub|and|or|xor|shl|shr|sar|setrelop)i?, 它们的定义用到了nemu/src/engine/interpreter/c_op.h中的C语言运算和interpret_relop()函数</li>
<li>寄存器-寄存器类型的乘除法运算, 包括rtl_i?(mul_[lo|hi]|div_[q|r]),</li>
<li>被除数为64位的除法运算rtl_i?div64_[q|r]</li>
<li>guest内存访问rtl_lm, rtl_lms和rtl_sm</li>
<li>host内存访问rtl_host_lm和rtl_host_sm</li>
<li>跳转, 包括直接跳转rtl_j, 间接跳转rtl_jr和条件跳转rtl_jrelop</li>
<li>终止程序rtl_exit(在nemu/src/monitor/cpu-exec.c中定义)</li>
</ul>
<p>小型调用约定:</p>
<ul>
<li>实现RTL伪指令的时候, 尽可能不使用dest之外的寄存器存放中间结果. 由于dest最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.</li>
<li>实在需要使用临时寄存器的时候, 按照以下约定来使用:</li>
<li>t0, t1, ... - 只能在RTL伪指令的实现过程中存放中间结果</li>
<li>s0, s1, ... - 只能在译码辅助函数和执行辅助函数的实现过程中存放中间结果</li>
</ul>
<p>RTL寄存器的生存期</p>
<p>任何指令都可以分解为以下4中操作</p>
<ul>
<li>读取某一主存单元的内容，并将其装入某个寄存器（取指， 取数）</li>
<li>把一个数据从某个寄存器存入给定的主存单元中（存结果）</li>
<li>把一个数据从某寄存器送到另一寄存器或者ALU（取数，存结果）</li>
<li>进行算术或逻辑运算（PC+”1”，计算地址，运算）</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>i386</title>
      <link>https://kigane.github.io/note/cs/isa-i386/</link>
      <guid>https://kigane.github.io/note/cs/isa-i386/</guid>
      <source url="https://kigane.github.io/rss.xml">i386</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基本编程模型"> 基本编程模型</h2>
<h3 id="内存组织和分段-segmentation"> 内存组织和分段(Segmentation)</h3>
<p>物理内存由8-bit的字节组成的序列构成。每个字节有一个唯一的地址，范围<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span>[</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>32</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>]</span></span></span></span>，共4GB。</p>
<p>内存组织模型有两种</p>
<ul>
<li>flat address space 由大小为4GB的单个数组组成</li>
<li>segmented address space 由16383(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>14</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>)个线性地址空间集合组成，每个地址空间最多4GB。
<ul>
<li>内存空间最大为64TB(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>46</span></span></span></span></span></span></span></span></span></span></span></span>B)。称为逻辑地址空间</li>
<li>可以看作最多16383个一维子空间的集合，每个子空间就是一个Segment。子空间的地址是连续的。</li>
<li>逻辑地址空间的指针由两个部分组成
<ul>
<li>16bits的segment selector，用于确定Segment</li>
<li>32bits的offset，用于确定Segment内的字节。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>详见第5章。</p>
<h3 id="数据类型"> 数据类型</h3>
<p>操作数(Operand)的基础数据类型</p>
<ul>
<li>Byte 8bits</li>
<li>Word 16bits</li>
<li>DoubleWord 32bits</li>
</ul>
<p>注意：Word的地址不必对齐到偶数地址，DoubleWord的地址不必对齐到能被4整除的地址。这样数据结构的弹性最大，内存利用率最高。但使用32-bits的总线传输效率会较低。为了更好的传输性能，数据结构应该要设计为尽量对齐。</p>
<hr>
<p>操作数(Operand)的基础数据类型只有三种，但根据使用指令的不同，可以识别出额外的基础数据类型</p>
<ul>
<li>Integer: 用二进制补码表示。最高有效位(MSB)为符号位。</li>
<li>Ordinal: 用二进制原码表示。无符号位。</li>
<li>Near Pointer: 32-bit 逻辑地址。用于flat model或Segment内部。</li>
<li>Far Pointer: 48-bit 逻辑地址。仅用于segmented model。</li>
<li>String: Byte,Word,DoubleWord的连续序列。</li>
<li>Bit field: bit的连续序列。最大32位。起始bit任意。</li>
<li>Bit string: bit的连续序列。起始bit任意。最大<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8974em;vertical-align:-0.0833em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>32</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6444em;"></span><span>1</span></span></span></span>bits。</li>
<li>BCD: 每个字节表示一个十进制数字，0-3这4个bit表示一个数字(只有0-9有意义)。4-7个4个bit在乘除中必须为0，在加减中可以是任意值。</li>
<li>Packed BCD:每个字节表示两个十进制数字。每半个字节表示一个数字。</li>
</ul>
<h2 id="寄存器"> 寄存器</h2>
<p>80386共有16个寄存器，可分为3类</p>
<ul>
<li>通用寄存器(General registers) 8个32-bit寄存器，主要用于保存操作数</li>
<li>段寄存器(Segment registers) 这6个寄存器决定了在任一时刻，那个segment是可寻址的。</li>
<li>状态和指令寄存器(Status and instruction registers) 用于记录和改变处理器的状态。</li>
</ul>
<h3 id="通用寄存器"> 通用寄存器</h3>
<p><img src="/assets/img/general-registers.png" alt="通用寄存器" /></p>
<p>其中</p>
<ul>
<li>EAX, EDX, ECX, EBX, EBP, ESI, EDI, ESP是32位寄存器;</li>
<li>AX, DX, CX, BX, BP, SI, DI, SP是16位寄存器;</li>
<li>AL, DL, CL, BL, AH, DH, CH, BH是8位寄存器.</li>
</ul>
<p>某些指令会使用特定的寄存器，如：双精度浮点乘除运算，I/O，字符串指令，循环，栈操作等等。</p>
<h3 id="段寄存器"> 段寄存器</h3>
<p><img src="/assets/img/other-registers.png" alt="其他寄存器" />
完整的程序通常由许多不同的模块组成，每个模块包括指令和数据。 但是，在程序执行期间的任一时刻，实际使用到的仅为程序模块的小子集。 80386架构通过提供直接访问当前模块环境的指令和数据的机制来利用这一点，必要时可以访问额外的段。</p>
<p>执行中的程序可以在任一时刻立即访问六个内存段。这六个内存段分别用寄存器CS,SS,DS,ES,FS,GS标识，每个段寄存器唯一确定一个特定的程序段，并可以高速访问。</p>
<ul>
<li>CS(Code Segment) 对应保存当前执行的指令序列所在的段。CS的值只能通过控制转移指令(e.g JMP,CALL)，中断或异常隐式改变。</li>
<li>SS(Stack Segment) 子程序调用，参数，过程激活记录通常会在栈上分配内存。所有的栈操作都会使用SS来定位栈。不像CS, SS寄存器可以显式加载，因此程序员可以动态定义栈。</li>
<li>DS，ES，FS和GS寄存器指定四个数据段，每个数据段都可由当前执行的程序寻址。对四个单独的数据区域的可访问性有助于程序有效地访问不同类型的数据结构。有些程序可能需要访问不止4个数据段，此时需要在程序执行期间改变这4个寄存器的值。这需要程序在访问特定数据时，需要先加载正确的段寄存器。</li>
</ul>
<p>处理器将基址与由段寄存器选择的段地址相关联。即先通过段寄存器找到相应的段，再用32-bit基址在段内寻址。</p>
<h4 id="栈的实现"> 栈的实现</h4>
<p>栈操作相关寄存器</p>
<ul>
<li>SS 一个系统可以有多个栈，每个栈大小最多可达4GB。由SS直接寻址的栈，通常被称为“当前”栈。SS自动用于所有栈操作，由处理器处理。</li>
<li>ESP ESP始终指向栈的栈顶(栈是从高地址向低地址扩展的，所以栈顶的地址最小)。ESP被PUSH,POP,子程序调用和返回，中断隐式引用。</li>
<li>EBP EBP指向当前过程确定的栈帧的基址(栈帧的最高地址，不会随栈的变换而改变)。因此适用于访问栈中的元素。</li>
</ul>
<h4 id="标志寄存器-eflags"> 标志寄存器--EFLAGS</h4>
<p><img src="/assets/img/EFLAGS.png" alt="EFLAGS" />
标志可以分为3组</p>
<ul>
<li>Status flags：用于让某个指令的结果影响下一个指令。算数指令使用前6个
<ul>
<li>CF(Carry Flag): 有进位或借位发生是设置，否则清除。</li>
<li>PF(Parity Flag): 如果结果的低8bit有偶数个1，则设置，否则清除。</li>
<li>AF(Adjust Flag): 用于BCD数据运算。如果AL的低4位有进位或借位则设置，否则清除。</li>
<li>ZF(Zoro Flag): 如果结果为0则设置，否则清除。</li>
<li>SF(Sign Flag): 结果的最高有效位。</li>
<li>OF(Overflow Flag): 溢出标志。(<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.07153em;">C</span><span><span><span><span style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>⊕</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8917em;vertical-align:-0.2083em;"></span><span><span style="margin-right:0.07153em;">C</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>n</span><span>−</span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.2083em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span><span style="margin-right:0.07153em;">C</span><span><span><span><span style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是最高位是否溢出，<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8917em;vertical-align:-0.2083em;"></span><span><span style="margin-right:0.07153em;">C</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>n</span><span>−</span><span>1</span></span></span></span></span><span>​</span></span><span><span style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>是次高位是否溢出)</li>
<li>TF(Trap Flag): 陷阱标志。Debug时用到。</li>
</ul>
</li>
<li>Control flags：
<ul>
<li>DF(Direction Flag): 当字符串指令自减时设置(即从高地址向低地址处理字符串时)，反之清除。</li>
</ul>
</li>
<li>System flags：</li>
</ul>
<hr>
<h4 id="指令指针"> 指令指针</h4>
<p>程序计数器(PC) -- EIP (Extended Instruction Pointer) 指向要执行的指令</p>
<h3 id="指令格式"> 指令格式</h3>
<p>指令=操作+操作数类型&amp;操作数位置</p>
<p><strong>指令中常见元素</strong></p>
<ul>
<li>Prefix 在指令之前的1-2个字节，修改指令的操作。
<ul>
<li>Segment override 显式指定指定应该使用的段寄存器，覆盖默认的。</li>
<li>Address size 产生16或32位地址</li>
<li>Operand size 产生16或32位操作数</li>
<li>Repeat 字符串指令使用该前缀，让该指令作用于string的每个元素。</li>
</ul>
</li>
<li>Opcode 操作码。确定指令的操作</li>
<li>Register specifier 一条指令可以指定1-2个寄存器操作数。寄存器指示符要么和Opcode在一个字节(+rb,+rw...)，要么和Address mode在一个字节。</li>
<li>Addressing-mode specifier 决定操作数是寄存器还是内存位置。如果是内存位置，决定是否使用位移，基址寄存器，索引寄存器和缩放因子。</li>
<li>SIB byte (scale, index, base) 当addressing-mode specifier暗示要使用索引寄存器来计算操作数的地址时，指令中会包含一个SIB字节来编码基址寄存器，索引寄存器和缩放因子。</li>
<li>Displacement 当addressing-mode specifier暗示要使用位移来计算操作数的地址时，位移会编码在指令中。位移是一个<strong>有符号整数</strong>，通常8-bit就足够，按需要可以扩展到16-bit，32-bit。</li>
<li>Immediate operand 立即数，就是指令的直接操作数。可以是8,16,32位。为了以防万一有8bit操作数和32/16-bit操作数合并的操作，通常会自动扩展。</li>
</ul>
<h3 id="操作数选择-operand-selection"> 操作数选择 Operand Selection</h3>
<p>操作数是指令操纵的数据，一个指令可以有0或多个操作数。操作数可以位于</p>
<ul>
<li>指令本身(立即数)</li>
<li>寄存器</li>
<li>内存</li>
<li>I/O端口</li>
</ul>
<p>对于有操作数的指令，操作数可以是隐式的，显式的，或者既有隐式操作数又有显式操作数。例如</p>
<ul>
<li>AAM(Ascii Adjust for mutiplication) 作用于AX寄存器。隐式，</li>
<li>XCHG EAX,EBX 显式</li>
<li>PUSH COUNTER 显式+隐式 内存变量COUNTER拷贝到栈中</li>
</ul>
<hr>
<p><strong>大多数指令有隐式操作数。所有的算数操作数都会更新EFLAGS。</strong></p>
<hr>
<p>指令可以显示引用1-2个操作数。有两个操作数的指令，其结果一定会覆盖其中一个操作数，称为目标操作数(dest)，另一个则称源操作数(src)。有两个显式操作数的指令，一个操作数为内存(M)或寄存器(R),另一个操作数一定是寄存器或立即数(Immediate)允许的操作有</p>
<ul>
<li>R-to-R</li>
<li>R-to-M</li>
<li>M-to-R</li>
<li>I-to-R</li>
<li>I-to-M</li>
</ul>
<p>M-M模式在字符串处理指令中存在，但两个操作数都是隐式表示的。Push,Pop也有点特殊。</p>
<p>I: 指令中的有符号数字字面量
R: 对应各个寄存器</p>
<p>Memory Operand<br>
数据操纵指令在处理内存操作数时，必须指明包含该操作数的段(segment)和操作数在段中的位置(offset)。然而，为了速度和指令编码的简练，将段选择器(segment selector)放在高速的段寄存器中。因此数据操纵指令只需要指明offset即可。<br>
内存寻址</p>
<ul>
<li>大多数数据操纵指令访问内存时都显式包含一个指示寻址方法的字节modR/M字节。通常跟在opcode后。如果操作数为内存地址，则最终地址LA = SR + (B,I,s,D的各种组合)，其中(B:基址寄存器，I:索引寄存器，s:缩放因子，D:位移)。当用到索引寄存器的时候，modR/M字节后会跟着一个字节，指示使用的索引寄存器和缩放因子。</li>
<li>某些特殊的寻址
<ul>
<li>LA = SR + D 某些MOV指令，隐式使用EAX，offset写在指令中。</li>
<li>字符串操作
<ul>
<li>使用 DS:ESI 寻址，如MOVS, CMPS, OUTS, LODS, SCAS</li>
<li>使用 ES:EDI 寻址，如MOVS, CMPS, INS, STOS</li>
</ul>
</li>
<li>栈操作，使用 SS:ESP 寻址。 如PUSH, POP, PUSHA, PUSHAD, POPA, POPAD, PUSHF, PUSHFD, POPF, POPFD, CALL, RET, IRET, IRETD以及异常和中断。</li>
</ul>
</li>
</ul>
<h4 id="默认的段寄存器选择规则"> 默认的段寄存器选择规则</h4>
<table>
<thead>
<tr>
<th>内存引用</th>
<th>段寄存器</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>指令</td>
<td>CS</td>
<td>在预取(prefetch)指令时自动选择</td>
</tr>
<tr>
<td>栈</td>
<td>SS</td>
<td>任何栈push,pop操作。以EBP/ESP为基址的寻址</td>
</tr>
<tr>
<td>Local Data</td>
<td>DS</td>
<td>其他</td>
</tr>
<tr>
<td>Dest Strings</td>
<td>ES</td>
<td>字符串指令的 dest</td>
</tr>
</tbody>
</table>
<h4 id="有效地址计算"> 有效地址计算</h4>
<p><img src="/assets/img/effective-address.png" alt="有效地址计算" /></p>
<p>对以modR/M定义的内存操作数，在目标段内的有效地址由3个部分组成</p>
<ul>
<li>指令中的位移元素。因为是编码在指令中，所以适合地址的固定部分
<ul>
<li>简单标量操作数的位置</li>
<li>静态(static)分配的数组的开头</li>
<li>record中某个item的offset</li>
</ul>
</li>
<li>基址寄存器</li>
<li>变址寄存器(可能会乘以缩放因子2, 4, 或 8，上图错了)
<ul>
<li>基址+变址适合动态决定的地址</li>
<li>栈中的局部变量和过程参数</li>
<li>records[i]</li>
<li>二维数组中的一维数组的起始</li>
<li>动态分配的数组地址</li>
</ul>
</li>
<li>注意，ESP不能作为变址寄存器。EBP，ESP作为基址寄存器时，默认的段寄存器为SS。</li>
<li>当数组元素大小为2,4,8时，由于scaling的存在，索引比较高效(不用分开移动或多次使用指令)。</li>
</ul>
<p>常用的寻址组合，段寄存器省略</p>
<ul>
<li>A = D 位移本身就是地址。通常用于static分配内存的操作数。</li>
<li>A = B 寄存器中的值就是地址。某些变量。</li>
<li>A = B + D
<ul>
<li>当索引的static array元素大小不是2,4,8B时。D为目标元素的offset。</li>
<li>访问records数组中的某个item。B为某个record，D为item的offset</li>
</ul>
</li>
<li>A = Ixs + D 当索引的static array元素大小是2,4,8B时。D为数组首地址。</li>
<li>A = B + I + D
<ul>
<li>二维数组，D为m[0][0]，</li>
<li>访问records数组中的某个item。B为records[0]，D为item的offset</li>
</ul>
</li>
<li>A = B + Ixs+ D 最一般的寻址格式
<ul>
<li>在汇编代码中写作 displacement(R[base_reg], R[index_reg], scale_factor)</li>
<li>其它寻址格式都可以看作这种一般格式的特例</li>
</ul>
</li>
</ul>
<h3 id="中断和异常-interrupts-and-exceptions"> 中断和异常(Interrupts and Exceptions)</h3>
<p>80386有两个机制来打断程序执行</p>
<ul>
<li>异常：是对在程序执行期间CPU检测到的特定条件作出回应的同步事件(synchronous event)。</li>
<li>中断：是外部设备需要注意时触发的异步事件(asynchronous event)</li>
</ul>
<p>异常和中断很类似，都会引起处理器暂时暂停(suspend)当前程序的执行，并执行另一个优先级更高的程序。它们的主要区别在于引发原因。异常总是可重现的，只要以同样的程序和数据再次执行。而中断通常独立于当前执行的程序。</p>
<p>中断详见第9章。应用程序员通常不处理中断，只处理异常。系统程序员需要定义应用程序和异常机制之间的接口，并提供给应用程序员。</p>
<p>//TODO</p>
<p>Reserved Exceptions and Interrupts</p>
<table>
<thead>
<tr>
<th>Vector Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Divide Error</td>
</tr>
<tr>
<td>1</td>
<td>Debug Exceptions</td>
</tr>
<tr>
<td>2</td>
<td>NMI Interrupt</td>
</tr>
<tr>
<td>3</td>
<td>Breakpoint</td>
</tr>
<tr>
<td>4</td>
<td>INTO Detected Overflow</td>
</tr>
<tr>
<td>5</td>
<td>BOUND Range Exceeded</td>
</tr>
<tr>
<td>6</td>
<td>Invalid Opcode</td>
</tr>
<tr>
<td>7</td>
<td>Coprocessor Not Available</td>
</tr>
<tr>
<td>8</td>
<td>Double Exception</td>
</tr>
<tr>
<td>9</td>
<td>Coprocessor Segment Overrun</td>
</tr>
<tr>
<td>10</td>
<td>Invalid Task State Segment</td>
</tr>
<tr>
<td>11</td>
<td>Segment Not Present</td>
</tr>
<tr>
<td>12</td>
<td>Stack Fault</td>
</tr>
<tr>
<td>13</td>
<td>General Protection</td>
</tr>
<tr>
<td>14</td>
<td>Page Fault</td>
</tr>
<tr>
<td>15</td>
<td>(reserved)</td>
</tr>
<tr>
<td>16</td>
<td>Coprocessor Error</td>
</tr>
<tr>
<td>17-32</td>
<td>(reserved)</td>
</tr>
</tbody>
</table>
<h2 id="应用指令集"> 应用指令集</h2>
<h3 id="数据移动指令"> 数据移动指令</h3>
<h4 id="通用数据移动指令"> 通用数据移动指令</h4>
<ul>
<li>MOV (move)</li>
<li>XCHG (exchange) 交换两个操作数。不需要临时变量，可代替3条MOV指令。在实现semaphores(信号量)及类似的进程同步数据结构时很有用。如果有一个操作数是M，则XCHG自动激活LOCK信号。</li>
</ul>
<h4 id="栈操作指令"> 栈操作指令</h4>
<ul>
<li>PUSH 降低ESP，再将源操作数放到ESP指的位置。通常用于过程调用时保存参数或在栈上保存临时变量。</li>
<li>PUSHA (Push All Registers) 将八个通用寄存器的值存到栈中。顺序为EAX,EDX,ECX,EBX,OLD ESP,EBP,ESI,EDI。可以简化过程调用时保存寄存器的值操作。</li>
<li>POP 将栈中保存的值放到目标操作数，再提高ESP。</li>
<li>POPA 将栈中的个通用寄存器的值取出，并用这些值重设寄存器。但忽略OLD ESP。</li>
</ul>
<h4 id="类型转换指令"> 类型转换指令</h4>
<ul>
<li>CWD (Convert Word to Doubleword)</li>
<li>CDQ (Convert Doubleword to Quad-Word)</li>
<li>CBW (Convert Byte to Word)</li>
<li>CWDE (Convert Word to Doubleword Extended)</li>
<li>只能操作EAX中的数据。可用于被除之前被除数的扩展。都是有符号扩展。</li>
</ul>
<hr>
<ul>
<li>MOVSX (Move with Sign Extension)</li>
<li>MOVZX (Move with Zero Extension)</li>
<li>可使用任何寄存器。另一个操作可以为M或R。</li>
</ul>
<h3 id="二元算术指令"> 二元算术指令</h3>
<p>会影响CF,SF,OF,ZF四个flag。</p>
<h4 id="加减指令"> 加减指令</h4>
<ul>
<li>ADD (Add Integers) 如果溢出，设置CF=1</li>
<li>ADC (Add Integers with Carry)  如果CF=1，再+1。否则同ADD</li>
<li>INC (Increment) +1。不影响CF</li>
<li>SUB (Subtract Integers) 如果借位(borrow)，设置CF=1</li>
<li>SBB (Subtract Integers with Borrow) 如果CF=1，再-1。否则同SUB</li>
<li>DEC (Decrement) -1。不影响CF</li>
</ul>
<h4 id="比较和取负指令"> 比较和取负指令</h4>
<ul>
<li>CMP (Compare)  用dest-src，更新OF, SF, ZF, AF, PF, 和 CF 标志，但不会改变dest和src的值。</li>
<li>NEG (Negate)  0-dest</li>
</ul>
<h4 id="乘法指令"> 乘法指令</h4>
<ul>
<li>MUL (Unsigned Integer Multiply) 源操作数和累加器(EAX/AX/AL)相乘，结果大小为操作数的两倍。如果结果的上半部分不为0，则将CF,OF设为1，否则设为0。</li>
<li>IMUL (Signed Integer Multiply)
<ul>
<li>单操作数 和MUL一样，另一个乘数隐式为EAX/AX/AL。取决于操作数的大小。</li>
<li>双操作数 其中一个操作数一定在通用寄存器中，结果也放在通用寄存器中。</li>
<li>三操作数 一个必定是有符号立即数，一个在寄存器或内存中，剩下一个通常是通用寄存器，存储乘积。</li>
<li>结果大小为操作数的两倍。如果结果的上半部分不为0，则将CF,OF设为1，否则设为0。</li>
<li>双，三操作数的形式结果会被截断(truncate)到源操作数的长度。也因此兼容无符号数的乘，因为乘积的低半部分是相同的。</li>
</ul>
</li>
</ul>
<h4 id="除法指令"> 除法指令</h4>
<p>如果除数为0或商超过EAX/AX/AL的表示范围，则触发一个异常(interrupt zero)<br>
DIV (Unsigned Integer Divide) 被除数隐式存储在EAX中。商不为整数时向0舍入。
IDIV (Signed Integer Divide) 同DIV。余数的符号同被除数。</p>
<table>
<thead>
<tr>
<th>Divisor(SRC 除数)</th>
<th>Dividend(被除数)</th>
<th>Quotient(商)</th>
<th>Remainder (余数)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>AX</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>Word</td>
<td>DX:AX</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>Doubleword</td>
<td>EDX:EAX</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody>
</table>
<h3 id="十进制算数指令"> 十进制算数指令</h3>
<h4 id="packed-bcd指令"> packed BCD指令</h4>
<ul>
<li>DAA (Decimal Adjust after Addition)</li>
<li>DAS (Decimal Adjust after Subtraction)</li>
</ul>
<h4 id="unpacked-bcd指令"> unpacked BCD指令</h4>
<ul>
<li>AAA (ASCII Adjust after Addition)</li>
<li>AAS (ASCII Adjust after Subtraction)</li>
<li>AAM (ASCII Adjust after Multiplication)</li>
<li>AAD (ASCII Adjust before Division)</li>
</ul>
<h3 id="逻辑指令"> 逻辑指令</h3>
<h4 id="布尔操作指令"> 布尔操作指令</h4>
<ul>
<li>NOT 对一个R或M中的操作数取反码。不影响flags。</li>
<li>AND/OR/XOR 操作数可以是R-R,R-M,I-R/M。会将OF，CF置零，AF的行为未定义，更新SF，ZF，PF。</li>
</ul>
<h4 id="位测试和修改指令"> 位测试和修改指令</h4>
<p>首先将选中的bit的值符给CF，再将新值放到该bit上。</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Effect on CF</th>
<th>Effect on Selected Bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit (Bit Test)</td>
<td>CF ← BIT</td>
<td>(none)</td>
</tr>
<tr>
<td>BTS (Bit Test and Set)</td>
<td>CF ← BIT</td>
<td>BIT ← 1</td>
</tr>
<tr>
<td>BTR (Bit Test and Reset)</td>
<td>CF ← BIT</td>
<td>BIT ← 0</td>
</tr>
<tr>
<td>BTC (Bit Test and Complement)</td>
<td>CF ← BIT</td>
<td>BIT ← NOT(BIT)</td>
</tr>
</tbody>
</table>
<h4 id="位扫描指令"> 位扫描指令</h4>
<ul>
<li>BSF (Bit Scan Forward) 从0-7/15/31扫描。保存第一个set bit(即1，unset bit就是0)的索引位置。如果全为0，则set ZF。反之清除。另外，如果被扫描的操作数全为0，则结果未定义。</li>
<li>BSR (Bit Scan Reverse) 反过来扫描。</li>
</ul>
<h4 id="shift-rotate指令"> shift&amp;rotate指令</h4>
<h3 id="控制转移指令"> 控制转移指令</h3>
<h4 id="无条件转移指令"> 无条件转移指令</h4>
<ul>
<li>JMP (Jump)
<ul>
<li>直接跳转 操作数写在指令中，且为有符号的立即数，表示相对位移(单位为Byte,Word,或DoubleWord)。计算的结果更新EIP。</li>
<li>间接跳转 通过R或M指定应该执行的下一条指令的绝对地址。</li>
</ul>
</li>
<li>CALL 激活另一个过程(其地址可以在某个通用寄存器中，也可以是编码在指令中的内存地址)，在栈中保存CALL指令的下一条指令的地址(即当前EIP的值)，供RET使用。</li>
<li>RET (Return From Procedure) 从栈中恢复CALL保存的EIP的值。</li>
<li>IRET (Return From Interrupt) 将控制返回到被中断过程。在恢复EIP之外，还会恢复中断机制存储在栈中的flags。</li>
</ul>
<h4 id="条件转移指令"> 条件转移指令</h4>
<p>Unsigned Conditional Transfers</p>
<table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Condition Tested</th>
<th>&quot;Jump If...&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>JA/JNBE</td>
<td>(CF or ZF) = 0</td>
<td>above/not below nor equal</td>
</tr>
<tr>
<td>JAE/JNB</td>
<td>CF = 0 above or</td>
<td>equal/not below</td>
</tr>
<tr>
<td>JB/JNAE</td>
<td>CF = 1 below/not</td>
<td>above nor equal</td>
</tr>
<tr>
<td>JBE/JNA</td>
<td>(CF or ZF) = 1</td>
<td>below or equal/not above</td>
</tr>
<tr>
<td>JC</td>
<td>CF = 1</td>
<td>carry</td>
</tr>
<tr>
<td>JE/JZ</td>
<td>ZF = 1</td>
<td>equal/zero</td>
</tr>
<tr>
<td>JNC</td>
<td>CF = 0</td>
<td>not carry</td>
</tr>
<tr>
<td>JNE/JNZ</td>
<td>ZF = 0</td>
<td>not equal/not zero</td>
</tr>
<tr>
<td>JNP/JPO</td>
<td>PF = 0</td>
<td>not parity/parity odd</td>
</tr>
<tr>
<td>JP/JPE</td>
<td>PF = 1</td>
<td>parity/parity even</td>
</tr>
</tbody>
</table>
<hr>
<p>Signed Conditional Transfers</p>
<table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Condition Tested</th>
<th>&quot;Jump If...&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>JG/JNLE</td>
<td>((SF xor OF) or ZF) = 0</td>
<td>greater/not less nor equal</td>
</tr>
<tr>
<td>JGE/JNL</td>
<td>(SF xor OF) = 0</td>
<td>greater or equal/not less</td>
</tr>
<tr>
<td>JL/JNGE</td>
<td>(SF xor OF) = 1</td>
<td>less/not greater nor equal</td>
</tr>
<tr>
<td>JLE/JNG</td>
<td>((SF xor OF) or ZF) = 1</td>
<td>less or equal/not greater</td>
</tr>
<tr>
<td>JNO</td>
<td>OF = 0 not</td>
<td>overflow</td>
</tr>
<tr>
<td>JNS</td>
<td>SF = 0 not</td>
<td>sign (positive, including 0)</td>
</tr>
<tr>
<td>JO</td>
<td>OF = 1</td>
<td>overflow</td>
</tr>
<tr>
<td>JS</td>
<td>SF = 1</td>
<td>sign (negative)</td>
</tr>
</tbody>
</table>
<h3 id="杂项指令"> 杂项指令</h3>
<ul>
<li>LEA (Load Effective Address) LEA DEST SRC。将SRC(一定是M)的地址存放到DEST(一定是R)中。例如，LEA EBX, EBCDIC_TABLE意为将EBCDIC_TABLE的首地址存放到EBX中。</li>
<li>NOP (No Operation) 用于内存对齐。</li>
<li>XLAT (Translate) 将AL中的一个字节替换成用户指定的表中的一个字节。当执行XLAT时，EBX是表的首地址，AL中的值为表的索引。执行XLAT后，AL的内容变为表中指定位置的内容，EBX的值不变。因为AL只有8-bit，所以表最多256B。</li>
</ul>
<h2 id="_80386指令集说明"> 80386指令集说明</h2>
<h3 id="操作数和地址的大小-operand-size-address-size"> 操作数和地址的大小(Operand-Size, Address-Size)</h3>
<ul>
<li>default: 指令中的D-bit，为0表示16-bit，为1表示32-bit。</li>
<li>指令前缀: Operand-Size对应66H,Address-Size对应67H。其效果为对当前D-bit取反。(例如，有66H，D为0，则有效操作数大小为32-bit)</li>
<li>栈的Address-Size: 在SS中的数据段的B-bit。为0表示16-bit，即使用SP，为1表示32-bit，即使用ESP。</li>
<li>通常32-bit机器默认D-bit为1，指令如果出现66H前缀，表示要改变操作数大小为16-bit。</li>
</ul>
<h3 id="指令格式-2"> 指令格式</h3>
<p><img src="/assets/img/80386-instruction-format.png" alt="指令格式" /></p>
<p>可用的指令前缀(H表示该数为16进制)</p>
<ul>
<li>F3H REP prefix (used only with string instructions)</li>
<li>F3H REPE/REPZ prefix (used only with string instructions)</li>
<li>F2H REPNE/REPNZ prefix (used only with string instructions)</li>
<li>F0H LOCK prefix</li>
</ul>
<hr>
<p>段覆盖指令前缀</p>
<ul>
<li>2EH CS segment override prefix</li>
<li>36H SS segment override prefix</li>
<li>3EH DS segment override prefix</li>
<li>26H ES segment override prefix</li>
<li>64H FS segment override prefix</li>
<li>65H GS segment override prefix</li>
<li>66H Operand-size override</li>
<li>67H Address-size override</li>
</ul>
<h4 id="modr-m-and-sib-bytes"> ModR/M and SIB Bytes</h4>
<p><img src="/assets/img/modrm-sib.png" alt="ModR/M&amp;SIB" />
x86通过ModR/M字节来指示内存操作数</p>
<ul>
<li>mod(MSB的两位) 和r/m组合为32种可能的值，包括8个寄存器，24种寻址模式(indexing mode)
<ul>
<li>32位寻址</li>
<li>00 通常代表地址值在寄存器内</li>
<li>01 通常代表地址值在寄存器内，还要加上modR/M字节后跟的8-bit位移</li>
<li>10 通常代表地址值在寄存器内，还要加上modR/M字节后跟的32-bit位移</li>
<li>11 取寄存器内的值</li>
</ul>
</li>
<li>reg/op(mod后三位) 取决于指令的opcode，通常代表寄存器编号，在某些指令中代表opcode信息。</li>
<li>r/m(LSB的三位) 可能代表操作数使用的寄存器，看和mod的组合。</li>
</ul>
<p>SIB字节在r/m为100时使用。加不加位移，位移几位看mod字段。</p>
<ul>
<li>ss 比例因子。00:1B, 01:2B, 10:4B, 11:8B。</li>
<li>index 索引寄存器使用的通用寄存器编号</li>
<li>base 基址寄存器使用的通用寄存器编号</li>
</ul>
<h4 id="如何阅读指令格式说明页"> 如何阅读指令格式说明页</h4>
<ul>
<li>i386手册中的汇编语言格式都是Intel格式, 而objdump的默认格式是AT&amp;T格式, 两者的源操作数和目的操作数位置不一样, 千万不要把它们混淆了! 否则你将会陷入难以理解的bug中.</li>
<li>opcode
<ul>
<li>/digit(0-7) ModR/M字节只使用r/m域，reg/opcode字段包含的数字为指令操作码的扩展。对于含有/digit记号的指令形式, 需要通过指令本身的opcode和ModR/M中的扩展opcode共同决定指令的形式, 例如80 /0表示add指令的一种形式, 而80 /5则表示sub指令的一种形式, 只看opcode的首字节80不能区分它们.</li>
<li>/r 表示opcode后跟一个ModR/M字节，reg/opcode字段包含的数字为通用寄存器的编码。</li>
<li>cb, cw, cd, cp 操作码后的1-byte(cb),2-byte(cw),4-byte(cd),6-byte(cp)用于指定code offset(相对段寄存器的偏移)或是段寄存器的新值。例如CALL指令的一种</li>
<li>ib, iw, id 操作码，modR/M或SIB后的1-byte(ib),2-byte(iw),4-byte(id)是指令的立即数。是否有符号有操作码决定</li>
<li>+rb, +rw, +rd分别表示8位, 16位, 32位通用寄存器的编码. 和ModR/M中的reg域不一样的是, 这三种记号表示直接将通用寄存器的编号按数值加到opcode中 (也可以看成通用寄存器的编码嵌在opcode的低三位), 因此识别指令的时候可以通过opcode的低三位确定一个寄存器操作数.</li>
</ul>
</li>
<li>instruction
<ul>
<li>以下表示操作数的类型</li>
<li>rel8 相对地址，范围从包含指令末尾的之前的128个字符到指令结束后的127个字符</li>
<li>rel16,rel32 在同一个Segment内的相对地址。operand-size分别为16-bit和32-bit</li>
<li>ptr16:16, ptr16:32 FARPOINTER。略。</li>
<li>r8 AL, CL, DL, BL, AH, CH, DH, BH中的一个</li>
<li>r16 AX, CX, DX, BX, SP, BP, SI, DI中的一个</li>
<li>r32 EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI中的一个</li>
<li>imm8 8位有符号立即数。和word，DoubleWord的操作数同时使用时，会进行有符号扩展。</li>
<li>imm16 16位有符号立即数。</li>
<li>imm32 32位有符号立即数。</li>
<li>r/m8|16|32 存储在寄存器或内存中的1B|2B|4B操作数</li>
<li>m8|16|32 内存中的操作数</li>
<li>m16:16, M16:32 FARPOINTER内存操作数。略。</li>
<li>m16 &amp; 32, m16 &amp; 16, m32 &amp; 32 内存数据对</li>
<li>moffs8, moffs16, moffs32 某些MOV变体使用的内存偏移(相对于当前Segment的基)，这些变体不会用到modR/M字节</li>
<li>Sreg 段寄存器。ES=0, CS=1, SS=2, DS=3, FS=4, and GS=5.</li>
</ul>
</li>
<li>clock 指令执行需要的时钟周期数
<ul>
<li>n 重复次数</li>
<li>m 执行的下一个指令中的组件数量</li>
<li>pm 保护模式</li>
</ul>
</li>
<li>description
<ul>
<li>有两个操作数时，通常SRC在右，DEST在左。</li>
<li><code>&quot;(*&quot;和&quot;*)&quot;</code>之间是注释</li>
<li>寄存器的名字代表寄存器的内容。加了<code>[]</code>后，表示寄存器中内容是地址，该地址的内容为<code>[register]</code>代表的内容。</li>
<li><code>[]</code> 就是取地址的内容。地址是相对于段基址的地址。</li>
<li>A := B 将B的值赋予A</li>
<li>OperandSize 代表指令中的 operand-size attribute。AddressSize，StackAddrSize类似</li>
<li>eSP 代表ESP或SP，取决于当前栈中的B-bit。</li>
</ul>
</li>
<li>opcode map
<ul>
<li>操作数类型可以用Zz表示，Z表示寻址方式，z表示操作数长度</li>
<li>A 直接寻址。没有modR/M字节，操作数直接编码在指令中</li>
<li>E opcode后面紧接着一个modR/M字节，指定了操作数。操作数要么是通用寄存器，要么是内存地址。如果是内存地址</li>
<li>G modR/M字节的reg字段选择一个通用寄存器</li>
<li>F EFLAGS</li>
<li>I 立即数。其值编码在指令的下一个字节</li>
<li>J 指令包含一个相对EIP的相对位移(relative offset)</li>
<li>O 指令没有modR/M字节，操作数的偏移量被编码为单词或双字</li>
<li>以下为操作数类型标识符，和operand size attribute无关的前面加-。</li>
<li>a 两个单字/双字操作数，在内存中</li>
<li>c byte/word</li>
<li>p 32/48位指针</li>
<li>s Six-byte pseudo-descriptor</li>
<li>v 单字/双字</li>
<li>-b byte</li>
<li>-w word</li>
<li>-d double-word</li>
</ul>
</li>
</ul>
<h3 id="指令"> 指令</h3>
<div><pre><code><span>// PUSH</span>
<span>IF</span> StackAddrSize <span>=</span> <span>16</span>
<span>THEN</span>
 <span>IF</span> OperandSize <span>=</span> <span>16</span> <span>THEN</span>
 <span>SP</span> ← <span>SP</span> <span>-</span> <span>2</span><span>;</span>
 <span>(</span><span>SS</span><span>:</span><span>SP</span><span>)</span> <span>←</span> <span>(</span><span>SOURCE</span><span>)</span><span>;</span> 
 <span>ELSE</span>
 <span>SP</span> ← <span>SP</span> <span>-</span> <span>4</span><span>;</span>
 <span>(</span><span>SS</span><span>:</span><span>SP</span><span>)</span> <span>←</span> <span>(</span><span>SOURCE</span><span>)</span><span>;</span>
 <span>FI</span><span>;</span>
<span>ELSE</span>
 <span>IF</span> OperandSize <span>=</span> <span>16</span>
 <span>THEN</span>
 <span>ESP</span> ← <span>ESP</span> <span>-</span> <span>2</span><span>;</span>
 <span>(</span><span>SS</span><span>:</span><span>ESP</span><span>)</span> <span>←</span> <span>(</span><span>SOURCE</span><span>)</span><span>;</span>
 <span>ELSE</span>
 <span>ESP</span> ← <span>ESP</span> <span>-</span> <span>4</span><span>;</span>
 <span>(</span><span>SS</span><span>:</span><span>ESP</span><span>)</span> <span>←</span> <span>(</span><span>SOURCE</span><span>)</span><span>;</span>
 <span>FI</span><span>;</span>
<span>FI</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ul>
<li>e8 cw CALL rel16 首先PUSH(IP)，在EIP=EIP+rel16&amp;0x0000ffff</li>
<li>68 PUSH imm</li>
</ul>
<h2 id="intel-和-at-t-格式汇编的语法差异"> Intel 和 AT&amp;T 格式汇编的语法差异</h2>
<table>
<thead>
<tr>
<th>type</th>
<th>Intel</th>
<th>AT&amp;T</th>
</tr>
</thead>
<tbody>
<tr>
<td>Comments</td>
<td>;</td>
<td>//</td>
</tr>
<tr>
<td>Instructions</td>
<td>Untagged add</td>
<td>Tagged with operand sizes: addq</td>
</tr>
<tr>
<td>Registers</td>
<td>eax, ebx, etc.</td>
<td>%eax,%ebx, etc.</td>
</tr>
<tr>
<td>Immediates</td>
<td>0x100</td>
<td>$0x100</td>
</tr>
<tr>
<td>Indirect</td>
<td>[eax]</td>
<td>(%eax)</td>
</tr>
<tr>
<td>General indirect</td>
<td>[base + reg + reg * scale + displacement]</td>
<td>displacement(reg, reg, scale)</td>
</tr>
</tbody>
</table>
<p>AT&amp;T and Intel syntax use the opposite order for source and destination operands. Intel add eax, 4 is addl $4, %eax. The source, dest convention is maintained for compatibility with previous Unix assemblers. Note that instructions with more than one source operand, such as the enter instruction, do not have reversed order.</p>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/general-registers.png" type="image/png"/>
    </item>
    <item>
      <title>riscv</title>
      <link>https://kigane.github.io/note/cs/isa-riscv/</link>
      <guid>https://kigane.github.io/note/cs/isa-riscv/</guid>
      <source url="https://kigane.github.io/rss.xml">riscv</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
    </item>
    <item>
      <title>正则表达式</title>
      <link>https://kigane.github.io/note/cs/regex/</link>
      <guid>https://kigane.github.io/note/cs/regex/</guid>
      <source url="https://kigane.github.io/rss.xml">正则表达式</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="学习网站推荐"> 学习网站推荐</h2>
<p><a href="https://regexone.com/lesson/introduction_abcs" target="_blank" rel="noopener noreferrer">regexone.com 一个交互式的入门网站</a>
<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener noreferrer">learn-regex</a></p>
<h2 id="基础"> 基础</h2>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>match-any-charcater</td>
</tr>
<tr>
<td>[ ]</td>
<td>匹配方括号内的任意一个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>匹配除了方括号里的任意一个字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配&gt;=0个重复的在*号之前的字符</td>
</tr>
<tr>
<td>+</td>
<td>匹配&gt;=1个重复的+号前的字符</td>
</tr>
<tr>
<td>?</td>
<td>标记?之前的字符为可有可无的</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m)</td>
</tr>
<tr>
<td>(xyz)</td>
<td>子模式，匹配与 xyz 完全相等的字符串</td>
</tr>
<tr>
<td>|</td>
<td>或运算符，匹配符号前或后的字符</td>
</tr>
<tr>
<td>\</td>
<td>转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \ |</td>
</tr>
<tr>
<td>^</td>
<td>match-beginning-of-line</td>
</tr>
<tr>
<td>$</td>
<td>match-end-of-line</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>简写</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td style="text-align:center">除换行符外的所有字符</td>
</tr>
<tr>
<td>\w</td>
<td style="text-align:center">匹配所有字母数字，等同于 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td style="text-align:center">匹配所有非字母数字，即符号，等同于： [^\w]</td>
</tr>
<tr>
<td>\d</td>
<td style="text-align:center">匹配数字： [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td style="text-align:center">匹配非数字： [^\d]</td>
</tr>
<tr>
<td>\s</td>
<td style="text-align:center">匹配所有空格字符，等同于： [\t\n\f\r\p{Z}]</td>
</tr>
<tr>
<td>\S</td>
<td style="text-align:center">匹配所有非空格字符： [^\s]</td>
</tr>
<tr>
<td>\f</td>
<td style="text-align:center">匹配一个换页符</td>
</tr>
<tr>
<td>\n</td>
<td style="text-align:center">匹配一个换行符</td>
</tr>
<tr>
<td>\r</td>
<td style="text-align:center">匹配一个回车符</td>
</tr>
<tr>
<td>\t</td>
<td style="text-align:center">匹配一个制表符</td>
</tr>
<tr>
<td>\v</td>
<td style="text-align:center">匹配一个垂直制表符</td>
</tr>
<tr>
<td>\p</td>
<td style="text-align:center">匹配 CR/LF（等同于 \r\n），用来匹配 DOS 行终止符</td>
</tr>
</tbody>
</table>
<h2 id="标志"> 标志</h2>
<p>使用标志：<code>/RegEx/flags</code></p>
<table>
<thead>
<tr>
<th>标志</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td style="text-align:center">忽略大小写</td>
</tr>
<tr>
<td>g</td>
<td style="text-align:center">全局搜索(不仅仅返回第一个匹配的，而是返回全部)</td>
</tr>
<tr>
<td>m</td>
<td style="text-align:center">多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始</td>
</tr>
</tbody>
</table>
<p>(^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。</p>
<h2 id="前后预查"> 前后预查</h2>
<p>用于判断所匹配的格式是否在另一个确定的格式(通常会用小括号包裹)之前或之后，匹配结果不包含该确定格式（仅作为约束）。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>?=</td>
<td style="text-align:left">正先行断言-存在(后面一定有)</td>
<td style="text-align:left">&quot;(T</td>
</tr>
<tr>
<td>?!</td>
<td style="text-align:left">负先行断言-排除(后面一定没有)</td>
<td style="text-align:left">&quot;(T</td>
</tr>
<tr>
<td>?&lt;=</td>
<td style="text-align:left">正后发断言-存在(前面一定有)</td>
<td style="text-align:left">&quot;(?&lt;=(T</td>
</tr>
<tr>
<td>?&lt;!</td>
<td style="text-align:left">负后发断言-排除(前面一定没有)</td>
<td style="text-align:left">&quot;(?&lt;!(T</td>
</tr>
</tbody>
</table>
<h2 id="贪婪匹配和惰性匹配"> 贪婪匹配和惰性匹配</h2>
<p>正则表达式默认采用贪婪匹配模式(主要针对量词*,+,{l,},{,h},{l,h})，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ?(紧跟在量词后面) 将贪婪匹配模式转化为惰性匹配模式。</p>
<p>&quot;/(.*at)/&quot; =&gt; <strong>The fat cat sat on the mat</strong>.</p>
<p>&quot;/(.*?at)/&quot; =&gt; <strong>The fat</strong> cat sat on the mat.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux - Ubantu</title>
      <link>https://kigane.github.io/note/cs/linux/</link>
      <guid>https://kigane.github.io/note/cs/linux/</guid>
      <source url="https://kigane.github.io/rss.xml">Linux - Ubantu</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="安装"> 安装</h2>
<p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2020/0.1.html" target="_blank" rel="noopener noreferrer">NJU PA0</a><br>
分区：此电脑-&gt;管理-&gt;磁盘管理，选择磁盘，右键-&gt;压缩卷，分配适当空间即可，不用新建简单卷。</p>
<h2 id="设置"> 设置</h2>
<ul>
<li>sudo apt install gnome-tweaks</li>
<li>sudo apt remove gnome-shell-extension-ubantu-dock</li>
<li>sudo dpkg -i package_file.deb</li>
</ul>
<h2 id="关于键位"> 关于键位</h2>
<ul>
<li>C == ctrl, S == shift, M == meta | alt | esc</li>
<li>ESC == <code>C-[</code></li>
<li>Up == <code>C-p</code></li>
<li>Down == <code>C-n</code></li>
<li>Left == <code>C-b</code></li>
<li>Right == <code>C-f</code></li>
</ul>
<p>在vim等应用中<code>C-s</code>会导致无法交互，据说是和software flow control有关。按<code>C-q</code>可以退出这种状态。</p>
<h2 id="ansi转义码"> ANSI转义码</h2>
<ul>
<li>CSI 控制序列起始符 <code>ESC[</code></li>
<li>SGR 修改接下来的字符外观 <code>CSI n m</code> n为字符外观选项，可以控制字符颜色，斜体，下划线，闪烁等外观。m为SGR终止符。<code>CSI n m</code>相当于<code>CSI 0 m</code>。可以使用多个选项，中间用<code>;</code>隔开即可。如<code>\033[4;31m</code>，为红色带下划线。</li>
<li><code>ESC</code> = <code>\033</code> = <code>\e</code>(echo -e时)</li>
</ul>
<table>
<thead>
<tr>
<th>n</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Reset or normal, All attributes off</td>
</tr>
<tr>
<td>1</td>
<td>Bold or increased intensity</td>
</tr>
<tr>
<td>2</td>
<td>Faint, decreased intensity, or dim</td>
</tr>
<tr>
<td>3</td>
<td>Italic</td>
</tr>
<tr>
<td>4</td>
<td>Underline</td>
</tr>
<tr>
<td>5</td>
<td>Slow blink</td>
</tr>
<tr>
<td>9</td>
<td>Crossed-out, or strike</td>
</tr>
<tr>
<td>10</td>
<td>Primary (default) font</td>
</tr>
<tr>
<td>11–19</td>
<td>Alternative font</td>
</tr>
<tr>
<td>30–37</td>
<td>Set foreground color</td>
</tr>
<tr>
<td>38</td>
<td>Set foreground color, Next arguments are 5;n or 2;r;g;b</td>
</tr>
<tr>
<td>39</td>
<td>Default foreground color</td>
</tr>
<tr>
<td>40–47</td>
<td>Set background color</td>
</tr>
<tr>
<td>48</td>
<td>Set background color, Next arguments are 5;n or 2;r;g;b</td>
</tr>
<tr>
<td>49</td>
<td>Default background color</td>
</tr>
</tbody>
</table>
<h3 id="_8-bit颜色"> 8-bit颜色</h3>
<ul>
<li>ESC[38;5;⟨n⟩m 设置字体颜色</li>
<li>ESC[48;5;⟨n⟩m 设置背景颜色</li>
<li>0-  7:  standard colors (as in ESC [ 30–37 m)</li>
<li>8- 15:  high intensity colors (as in ESC [ 90–97 m)</li>
<li>16-231:  6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5)</li>
<li>232-255:  grayscale from black to white in 24 steps</li>
</ul>
<h3 id="_24-bit颜色-rgb"> 24-bit颜色(RGB)</h3>
<ul>
<li>ESC[38;2;⟨r⟩;⟨g⟩;⟨b⟩m 设置RGB字体颜色</li>
<li>ESC[48;2;⟨r⟩;⟨g⟩;⟨b⟩m 设置RGB背景颜色</li>
</ul>
<h2 id="unix哲学"> Unix哲学:</h2>
<ul>
<li>每个程序只做一件事, 但做到极致</li>
<li>用程序之间的相互协作来解决复杂问题</li>
<li>每个程序都采用文本作为输入和输出, 这会使程序更易于使用</li>
</ul>
<h2 id="linux命令"> Linux命令</h2>
<div><pre><code><span>df</span> -h <span># 查看硬盘空间使用情况</span>
<span>su</span> - <span># 切换到root用户</span>
adduser username <span>sudo</span> <span># 将用户分到sudo组</span>
hostnamectl <span># 显示主机信息 在/etc/hostname /etc/hosts 中修改主机名</span>
lscpu <span># 查看cpu信息</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar<br>
文件检索 - cat, more, less, head, tail, file, find<br>
输入输出控制 - 重定向, 管道, tee, xargs<br>
文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr<br>
系统监控 - jobs, ps, top, kill, free, demsg, lsof<br>
具体见Shell页</p>
<h3 id="别名"> 别名</h3>
<ul>
<li><code>alias</code> 列出已定义的别名</li>
<li><code>alias shortname=&quot;your custom cmd&quot;</code> 定义临时别名</li>
<li><code>unalias shortname</code> 取消</li>
<li><code>unalias -a</code> 全部取消</li>
<li>在~/.bashrc中定义，并 source ~/.bashrc。定义永久别名</li>
</ul>
<p>PS:alias不支持参数，所以要使用参数的话，可以在.bashrc中定义shell函数。</p>
<h3 id="特别"> 特别</h3>
<div><pre><code><span>sudo</span> <span>dmesg</span> <span># 输出OS的启动日志</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="环境变量"> 环境变量</h2>
<ul>
<li>临时定义：<code>export name=value</code> -- 只对当前shell及其子shell有效</li>
<li>永久定义，使用配置文件
<ul>
<li>用户: <code>~/.bash_profile</code></li>
<li>系统: <code>/etc/profile</code></li>
</ul>
</li>
</ul>
<p>其他相关命令</p>
<ul>
<li><code>env</code>: 查看所有环境变量</li>
<li><code>set</code>: 显示本地定义的shell变量,包括在.bashrc中定义的函数</li>
<li><code>unset</code>: 清除环境变量 unset HELLO</li>
<li><code>readonly</code>: 设置只读环境变量 readonly HELLO</li>
</ul>
<h2 id="工具"> 工具</h2>
<h3 id="tmux"> tmux</h3>
<p><code>sudo apt-get install tmux</code></p>
<ul>
<li>获取所有命令列表: C-b ?</li>
<li>创建Session: tmux new -s session_name</li>
<li>离开Session: C-b d(程序仍会继续运行)</li>
<li>回到Session: tmux ls; tmux attach-session -t 0</li>
<li>结束Session: tmux kill-session -t session_name</li>
<li>列出所有Session: C-b s</li>
<li>重命名当前Session: C-b $</li>
</ul>
<p>管理Tmux窗口</p>
<ul>
<li><code>C-b c</code> 创建新窗口</li>
<li><code>C-b w</code> 列出所有窗口，从中选一个作为当前窗口</li>
<li><code>C-b 0-9</code> 切换到窗口0-9</li>
<li><code>C-b p | n</code> 切换到前|后一个窗口</li>
<li><code>C-b ,</code> 重命名当前窗口</li>
</ul>
<p>pane</p>
<ul>
<li><code>C-b %</code> 分割为左右两个pane</li>
<li><code>C-b &quot;</code> 分割为上下两个pane</li>
<li><code>C-b o</code> 跳转到下一个pane</li>
<li><code>C-b h</code> 跳转到左边的pane。同理 j,k,l.</li>
<li><code>C-b q</code> 显示pane数量</li>
<li><code>C-b ;</code> 在当前和上一个pane间反复横跳</li>
<li><code>C-b x</code> 关闭当前pane</li>
<li><code>C-b {</code> 将当前pane移动到前一个pane位置</li>
<li><code>C-b }</code> 将当前pane移动到后一个pane位置</li>
<li><code>C-b C-o</code> 将所有窗口顺时针旋转</li>
<li><code>C-b M-o</code> 将所有窗口逆时针旋转</li>
<li><code>C-b !</code>   move the current pane into a new separate window (‘break pane’)</li>
</ul>
<p>命令行</p>
<ul>
<li><code>C-b [</code> 进入scroll模式，q退出</li>
<li><code>C-b PgUp</code> 进入scroll模式，并向上翻一页</li>
</ul>
<p>调整窗口大小</p>
<ul>
<li><code>C-b :</code> 会在底部显示命令行
<ul>
<li>输入 resize-pana -Direction #</li>
<li>Direction: U, D, L, R</li>
<li>#：数字，当前窗口向某方向上调整的尺寸。</li>
</ul>
</li>
</ul>
<h3 id="tree"> tree</h3>
<p><code>sudo apt-get install tree</code></p>
<ul>
<li>tree dir: 以树状形式展示文件夹内容</li>
<li>tree: 相当于<code>tree .</code></li>
<li>-d: 只显示dir</li>
<li>-f: 显示每个文件的完整路径</li>
<li>-i: 不显示缩进</li>
<li>-L level: 设置最大显示深度</li>
<li>-P pattern: 只显示pattern匹配的文件(如果要显示.xx，需要加上-a)</li>
<li>-I pattern: 不显示pattern匹配的文件</li>
<li>--ignore-case</li>
<li>--filelimit #: 不展开包含#个文件以上的文件夹</li>
</ul>
<p>文件显示选项</p>
<ul>
<li>-Q: 文件名加上双引号</li>
<li>-u: 显示用户名</li>
<li>-g: 显示用户组名</li>
<li>-D: 显示最后修改日期</li>
<li>-s: 显示文件大小(byte)</li>
<li>-h: 显示文件大小(更人性化)</li>
<li>-F: 显示文件类型(/:dir, =:socket fils, *:可执行文件, |:FIFO, &gt;:doors)</li>
</ul>
<p>排序</p>
<ul>
<li>-t: 最后修改时间</li>
<li>-U: 不排序</li>
<li>-r: 逆序</li>
<li>--dirsfirst: 文件夹放前面</li>
<li>--sort=size (ctime, mtime, version)</li>
</ul>
<p>输出模式</p>
<ul>
<li>-X: xml</li>
<li>-J: json</li>
<li>-H baseHREF: html</li>
</ul>
<h2 id="makefile"> makefile</h2>
<p><a href="https://www.gnu.org/software/make/manual/html_node/index.html#SEC_Contents" target="_blank" rel="noopener noreferrer">GNU make 手册</a></p>
<p>echoing：回显。通常make会将先执行的命令打印出来再执行该命令。使用-s选项关闭所有命令的回显。-n选项只打印命令，不执行。
在命令行开头加上<code>@</code>可关闭该命令的回显(-n仍会打印出来)。</p>
<p>在命令行开头加上<code>-</code>表示如果该命令执行发生错误就忽略它。</p>
<h3 id="基本规则"> 基本规则</h3>
<div><pre><code><span>target</span><span>:</span> file1 file2
    gcc -o a.out file1 file2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>#代表注释</li>
<li>命令行前必须有&lt;tab&gt;</li>
<li>target和依赖文件之间以 <code>:</code> 隔开</li>
<li>make target : 会执行相应命令行</li>
<li>make: 会默认执行第一个target</li>
</ul>
<div><pre><code>LIBS <span>=</span> -lm
OBJ <span>=</span> file1 file2
<span>target</span><span>:</span> <span>$</span><span>{</span>OBJ<span>}</span>
    gcc -o <span>$@</span> <span>$</span><span>{</span>OBJ<span>}</span> <span>$</span><span>{</span>LIBS<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>makefile的变量</p>
<ul>
<li>变量从行开头开始写</li>
<li>= 附近可以有空格</li>
<li>习惯上，用大写字母</li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span style="margin-right:0.03588em;">v</span><span>a</span><span style="margin-right:0.02778em;">r</span><span>)</span><span>或</span></span></span></span>{var}取得变量的值</li>
<li>可以使用shell的环境变量
<ul>
<li>在make target命令行中指定的环境变量优先考虑</li>
<li>makefile内部定义的环境变量次之</li>
<li>shell的环境变量最后</li>
</ul>
</li>
<li><code>$@</code> 代表 target 位置的内容</li>
<li><code>$xx</code> 称为<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html" target="_blank" rel="noopener noreferrer">automatic variables</a></li>
</ul>
<h3 id="设置变量-变量展开"> 设置变量&amp;变量展开</h3>
<p>make中变量展开方式有两种</p>
<ul>
<li>递归展开: 使用 <code>=</code>或<code>define\n....\n endef</code>。 类似引用。</li>
<li>简单展开：使用 <code>:=</code> 或 <code>::=</code>。逐行处理。</li>
<li>变量还有一种条件设置方式：使用<code>?=</code>。即如果该变量已经定义了，不会再次定义覆盖以前的。</li>
</ul>
<div><pre><code>foo <span>=</span> <span>$</span><span>(</span>bar<span>)</span>
bar <span>=</span> <span>$</span><span>(</span>ugh<span>)</span>
ugh <span>=</span> Huh?

x <span>:=</span> abc
y <span>:=</span> <span>$</span><span>(</span>x<span>)</span> efg
x <span>:=</span> later
x <span>?=</span> condition

<span>recursively</span><span>:</span>
    echo <span>$</span><span>(</span>foo<span>)</span> <span># Huh? </span>
<span>simply</span><span>:</span>
    echo <span>$</span><span>(</span>y<span>)</span> <span># abc efg</span>
<span>condition</span><span>:</span>
    echo <span>$</span><span>(</span>x<span>)</span> <span># later</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="判断"> 判断</h3>
<div><pre><code><span>ifeq</span> <span>(</span>lhs, rhs<span>)</span> <span># ifneq(l, r)</span>
<span># 如果lhs=rhs，则执行</span>
<span>else</span> <span>ifeq</span><span>(</span>l, r<span>)</span>
<span># 如果l=r，则执行</span>
<span>else</span>
<span># 其他情况</span>
<span>endif</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="include"> include</h3>
<ul>
<li><code>include filenames</code>: 在make读到这一行的时候暂停，去读filenames，读完继续。如果指定的filename不存在，则会先输出警告信息，在make remade之后如果还不存在，则报错(fatal)。文件搜寻顺序为当前文件夹，prefix/include (通常是/usr/local/include) /usr/gnu/include, /usr/local/include, /usr/include。</li>
<li><code>-include filenames</code>: 如果filename不存在，则忽略它。</li>
</ul>
<h3 id="函数"> 函数</h3>
<p>函数调用语法</p>
<div><pre><code><span>$</span><span>(</span>function arg0, arg1, ...<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="文本处理函数"> 文本处理函数</h4>
<ul>
<li>subst函数: $(subst from, to , text)</li>
<li>patsubst函数: $(patsubst pattern, replacement, text),注意这里的<code>%</code>相当于正则表达式中的通配符<code>*</code>。</li>
<li>strip函数: $(strip string),将字符串开头和结尾的空白字符删除，字符串中词与词之间的空格只保留一个。</li>
<li>findstring函数: $(findstring find, in),如果in中有find则返回find本身，否则返回空。</li>
<li>filter函数: $(filter pattern..., text)，将text中每个词和各个pattern匹配，返回所有匹配任一pattern成功的词。</li>
<li>filter-out函数: 返回匹配不成功的。</li>
<li>sort函数: $(sort list)，将list中的单词按字典序返回，并且会去重。</li>
<li>word函数: $(word n, text)，将text中的第n个词返回。n大于text中词数则返回空。</li>
<li>wordlist函数: $(wordlist s, e, text),返回从s到e个单词。闭区间。</li>
<li>words函数: $(words text),返回text中单词个数。</li>
<li>firstword函数: $(firstwords text),返回text中第一个单词。</li>
<li>lastword函数: $(lastwords text),返回text中最后一个单词。</li>
</ul>
<div><pre><code>comma<span>:=</span> ,
empty<span>:=</span>
space<span>:=</span> <span>$</span><span>(</span>empty<span>)</span> <span>$</span><span>(</span>empty<span>)</span>
foo<span>:=</span> a b c
bar<span>:=</span> <span>$</span><span>(</span><span>subst</span> <span>$</span><span>(</span>space<span>)</span>,<span>$</span><span>(</span>comma<span>)</span>,<span>$</span><span>(</span>foo<span>)</span><span>)</span> <span># bar is now ‘a,b,c’</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="文件名相关函数"> 文件名相关函数</h4>
<div><pre><code><span>$</span><span>(</span><span>dir</span> src/foo.c hacks<span>)</span> <span># src/ ./</span>
<span>$</span><span>(</span><span>notdir</span> src/foo.c hacks<span>)</span> <span># foo.c hacks</span>
<span>$</span><span>(</span><span>suffix</span> src/foo.c src-1.0/bar.c hacks<span>)</span> <span># .c .c</span>
<span>$</span><span>(</span><span>basename</span> src/foo.c src-1.0/bar hacks<span>)</span> <span># src/foo src-1.0/bar hacks</span>
<span>$</span><span>(</span><span>addsuffix</span> .c,foo bar<span>)</span> <span># foo.c bar.c</span>
<span>$</span><span>(</span>addprefix src/,foo bar<span>)</span> <span># src/foo src/bar</span>
<span>$</span><span>(</span><span>join</span> a b,.c .o<span>)</span> <span>#  a.c b.o // join list1,list2 将list1和list中的单词一一对应的连接。</span>
<span>$</span><span>(</span><span>wildcard</span> pattern<span>)</span> <span># 输出当前目录下匹配的文件名。</span>
<span>$</span><span>(</span><span>realpath</span> names…<span>)</span> <span># 输出name文件的绝对路径，name必须是存在的文件或文件名</span>
<span>$</span><span>(</span><span>abspath</span> names…<span>)</span> <span># 输出name文件的绝对路径，name可以包含通配符</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="wildcard"> wildcard</h4>
<p><code>$(wildcard pattern...)</code>: 某些地方不能使用<code>%</code>通配符时，就需要使用该函数。输出当前目录下匹配的文件名。</p>
<div><pre><code>objects <span>:=</span> <span>$</span><span>(</span><span>patsubst</span> %.c,%.o,<span>$</span><span>(</span><span>wildcard</span> *.c<span>)</span><span>)</span>

<span>foo</span> <span>:</span> <span>$</span><span>(</span>objects<span>)</span>
        cc -o foo <span>$</span><span>(</span>objects<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="call"> call</h4>
<p><code>$(call variable, param1, param2)</code>,其中variable是makefile中的变量，variable的值中的<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>0</span><span>)</span><span>代表自身的名字，</span></span></span></span>(1)代表param1,$(2)代表param2，以此类推。</p>
<div><pre><code>reverse <span>=</span> <span>$</span><span>(</span>2<span>)</span> <span>$</span><span>(</span>1<span>)</span>

foo <span>=</span> <span>$</span><span>(</span><span>call</span> reverse,a,b<span>)</span> <span># foo = b a</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="shell"> shell</h4>
<p><code>$(shell shellcmd)</code>: 创建shell执行shellcmd，返回shellcmd的输出。返回状态存储在<code>.SHELLSTATUS</code>变量中</p>
<div><pre><code>contents <span>:=</span> <span>$</span><span>(</span><span>shell</span> cat foo<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="ssh"> ssh</h2>
<div><pre><code><span>sudo</span> <span>apt</span> <span>install</span> openssh-client <span># 只连接别的机器</span>
<span>sudo</span> <span>apt</span> <span>install</span> openssh-server <span># 本机作为服务器</span>
/etc/init.d/ssh start <span># 手动启动server</span>
/etc/init.d/ssh stop <span># 停止server</span>
<span>vim</span> /etc/ssh/sshd_config <span># 配置文件，可修改端口号</span>
/etc/init.d/ssh restart <span># 修改后需要重启server</span>
<span>ssh</span> -p <span>22</span> user@ip <span># 登录另一台开了openssh-server的机器</span>
<span>hostname</span> -I <span># 查看本机ip地址</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><a href="https://www.netsarang.com/zh/free-for-home-school/" target="_blank" rel="noopener noreferrer">xshell 免费版</a></p>
<h2 id="任务管理"> 任务管理</h2>
<ul>
<li>将任务放到后台执行 <code>cmd &amp;</code> 会显示任务的序号和相关的PID</li>
<li>为了不让后台任务的输出影响前台，可以重定向流</li>
<li>将当前任务放到后台暂停 <code>C-z</code></li>
<li>查看当前任务状态 <code>jobs</code>
<ul>
<li>-l 列出任务序号，PID，任务状态，命令串</li>
<li>-r 仅列出后台run的任务</li>
<li>-s 仅列出后台stop的任务</li>
<li><code>+</code> 表示最近被放到后台的任务。 <code>-</code> 表示最近第二个被放到后台的任务</li>
</ul>
</li>
<li>将后台任务拿到前台处理 <code>fg [[%]jobnumber]</code>
<ul>
<li>不加jobnumber，默认将最近被放到后台的任务拿出来</li>
<li><code>fg -</code>，默认将最近第二个被放到后台的任务拿出来</li>
<li><code>fg %1</code> 指定将任务序号为1的任务拿出来</li>
</ul>
</li>
<li>让任务在后台的状态变成运行中 <code>bg [[%]jobnumber]</code></li>
<li>管理后台任务 <code>kill -signal %jobnumber</code>
<ul>
<li>signal
<ul>
<li>-1: 重新读取一次参数的配置文件</li>
<li>-2: 相当于<code>C-c</code></li>
<li>-9: 立刻强制删除一个任务</li>
<li>-15: 正常中止一个任务。默认值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程管理"> 进程管理</h2>
<ul>
<li><code>ps -l</code> 查看当前bash的相关进程
<ul>
<li>F: 进程标识(process flag)，说明进程的权限
<ul>
<li>4 root权限</li>
<li>1 仅fork，没有exec</li>
</ul>
</li>
<li>S: 进程状态
<ul>
<li>R: Running</li>
<li>S: Sleep</li>
<li>D: 不可被唤醒的睡眠状态，如等待I/O</li>
<li>T: 停止状态(stop)</li>
<li>Z: Zombie，僵尸状态，进程已经被中止但无法移出内存</li>
</ul>
</li>
<li>UID: 进程所属用户的UID</li>
<li>PID,PPID: 进程号，父进程的进程号</li>
<li>C: CPU使用率(%)</li>
<li>PRI: Priority 进程优先级</li>
<li>NI: Nice 进程优先级相关</li>
<li>ADDR: 进程在内存的那个部分。running进程显示 <code>-</code></li>
<li>SZ: 进程使用的内存大小</li>
<li>WCHAN: 进程是否在运行 <code>-</code>表示运行中</li>
<li>TTY: 登录者的终端位置</li>
<li>TIME: 进程实际使用的CPU运行时间</li>
<li>CMD: 触发进程的命令</li>
</ul>
</li>
<li><code>ps aux</code> 查看系统所有进程
<ul>
<li>VSZ: 进程使用的虚拟内存量(kB)</li>
<li>RSS: 进程使用的固定内存量(kB)</li>
<li>STAT: 同S</li>
</ul>
</li>
<li><code>top</code> 动态查看进程的状态
<ul>
<li>-d n 指定更新状态间隔的秒数</li>
<li>-p PID 查看指定进程。要看多个进程，重复使用多次-p选项即可。</li>
<li>top 按键命令
<ul>
<li>? 帮助</li>
<li>P 以CPU使用率排序</li>
<li>M 以内存使用率排序</li>
<li>N 以PID排序</li>
<li>T 以进程使用的CPU时间排序</li>
<li>q 退出</li>
<li>k 给某个PID一个signal</li>
<li>r 给某个PID一个新nice值</li>
</ul>
</li>
</ul>
</li>
<li><code>kill -signal PID</code> 同jobs</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>shell</title>
      <link>https://kigane.github.io/note/cs/shell-cheatsheet/</link>
      <guid>https://kigane.github.io/note/cs/shell-cheatsheet/</guid>
      <source url="https://kigane.github.io/rss.xml">shell</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="shell-是什么"> shell 是什么</h2>
<p>核心功能：允许你执行程序，输入并获取某种半结构化的输出。</p>
<h2 id="shell-基础"> shell 基础</h2>
<div><pre><code>hostname:~$ <span># 主机名:当前目录 $显示当前并非root用户</span>
hostname:~$ <span>echo</span> hello
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>shell 基于空格分割命令并进行解析，执行第一个单词代表的程序，后续单词将作为程序访问的参数</p>
<h3 id="环境变量"> 环境变量</h3>
<p>shell去哪里找需要执行的程序呢？shell是一个编程环境，有变量，条件，循环和函数，在shell中执行命令就是在执行一段shell可以理解的代码。如果执行的命令不是shell的关键字，shell就会咨询<strong>环境变量$PATH</strong>，其中，不同的路径由&quot;:&quot;分割。</p>
<p>当然，不用$PATH，直接给出执行程序的路径也可以。</p>
<div><pre><code><span>echo</span> <span>$PATH</span>
/bin/echo <span>$PATH</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="ls-l-chmod"> ls -l &amp; chmod</h3>
<div><pre><code><span>#权限     TODO  TODO  TODO 文件大小(B)  最后修改时间 文件名</span>
-rw-r--r-- <span>1</span>   user  user    <span>220</span>     May <span>25</span> 02:38 .bash_logout
-rw-r--r-- <span>1</span>   user  user   <span>3771</span>     May <span>25</span> 02:38 .bashrc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>权限由10个字符表示：</p>
<ul>
<li>第一个：d 表示这是一个目录</li>
<li>后面每3个一组： 表示文件所有者(u,user)，用户组(g,group)，其他所有人(o,other)所具有的权限</li>
<li>
<ul>
<li>表示相应无权限</li>
</ul>
</li>
<li>-rwx 分别表示<strong>读，写，执行</strong>权限</li>
</ul>
<p><code>chmod 0777 FILE</code>: 表示将FILE权限设为-rwxrwxrwx。第一个参数不知道什么意思。如果不是4个数，会在前面补0，如4实际为0004。
<code>chmod u+x FILE</code>: 表示为用户添加FILE执行权限。[ugoa][+-=][rwx]</p>
<h3 id="在程序间创建连接-重定向"> 在程序间创建连接--重定向</h3>
<p>shell中程序有两个主要的流：</p>
<ul>
<li>输入流：键盘 '/dev/stdin'</li>
<li>输出流：显示器  '/dev/stdout', '/dev/stderr'</li>
<li>空：忽略输出 /dev/null</li>
</ul>
<p>当然，可以重定向</p>
<div><pre><code><span>echo</span> hello <span>></span> hello.txt <span># hello</span>
<span>cat</span> <span>&lt;</span> hello.txt <span>></span> hello2.txt <span># hello2.txt 中内容: hello</span>
<span>echo</span> world <span>>></span> hello.txt <span># hello\nworld</span>
<span># echo \ world >> hello.txt # hello\n world 空格需要转义</span>
<span># echo ' world' >> hello.txt # hello\n world 或用引号(单，双都可)包裹</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>&gt;, &lt; 用于重定向流，&gt;&gt;用于追加内容。</p>
<p>管道(pipes)：&quot;|&quot; 操作符，用于将一个程序的输出和另一个程序的输入连接起来。</p>
<h3 id="root"> root</h3>
<p>sudo 可以让用户以root的身份执行紧跟着的程序。</p>
<p>只有根用户才能做的操作：向<code>sysfs</code>文件写入内容，该文件暴露了一些内核参数，所以用户可以在运行时配置系统内核。系统被挂载在<code>/sys</code>下。</p>
<h2 id="shell脚本"> shell脚本</h2>
<ul>
<li>变量赋值：<code>foo=bar</code>，<strong>不能有空格</strong></li>
<li>访问变量：<code>$foo</code></li>
<li>字符串：单引号表示原义字符串，其中的变量不会被转义。而双引号中变量会被转义。</li>
</ul>
<h3 id="bash函数"> bash函数</h3>
<div><pre><code><span>mcd</span><span>(</span><span>)</span><span>{</span>
    <span>mkdir</span> -p <span>"<span>$1</span>"</span>
    <span>cd</span> <span>"<span>$1</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>bash使用很多特殊变量表示参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0</td>
<td style="text-align:left">脚本名</td>
</tr>
<tr>
<td style="text-align:center">$1~$9</td>
<td style="text-align:left">第n个参数</td>
</tr>
<tr>
<td style="text-align:center">$@</td>
<td style="text-align:left">所有参数</td>
</tr>
<tr>
<td style="text-align:center">$#</td>
<td style="text-align:left">参数个数</td>
</tr>
<tr>
<td style="text-align:center">$?</td>
<td style="text-align:left">前一个命令的返回值</td>
</tr>
<tr>
<td style="text-align:center">$$</td>
<td style="text-align:left">当前脚本的进程识别码</td>
</tr>
<tr>
<td style="text-align:center">!!</td>
<td style="text-align:left">完整的上一条命令，包括参数</td>
</tr>
<tr>
<td style="text-align:center">$_</td>
<td style="text-align:left">上一条命令的最后一个参数</td>
</tr>
</tbody>
</table>
<p>命令通常使用<code>STDOUT</code>返回输出值，使用<code>STDERR</code>返回错误码。返回值0表示正常执行，其他都表示有错误发生。可以搭配短路运算符(<code>&amp;&amp;</code>,<code>||</code>)进行条件判断。</p>
<ul>
<li>同一行的多个命令可以用 ; 分隔</li>
<li>命令替换 (command substitution):以变量的形式获取一个命令的输出。通过 $(CMD) 这样的方式来执行CMD这个命令时，它的输出结果会替换掉$(CMD)。例如，如果执行 for file in $(ls) ，shell首先将调用ls ，然后遍历得到的这些返回值。</li>
</ul>
<p>示例</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Starting program at <span><span>$(</span><span>date</span><span>)</span></span>"</span> <span># date会被替换成日期和时间</span>

<span>echo</span> <span>"Running program <span>$0</span> with <span>$#</span> arguments with pid <span>$$</span>"</span>

<span>for</span> <span>file</span> <span>in</span> <span>"<span>$@</span>"</span><span>;</span> <span>do</span>
    <span>grep</span> foobar <span>"<span>$file</span>"</span> <span>></span> /dev/null <span><span>2</span>></span> /dev/null
    <span># 如果模式没有找到，则grep退出状态为 1</span>
    <span># 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span>
    <span>if</span> <span>[</span><span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>]</span><span>;</span> <span>then</span> <span># [[ 中的命令必须前后空一格 ]]</span>
        <span>echo</span> <span>"File <span>$file</span> does not have any foobar, adding one"</span>
        <span>echo</span> <span>"# foobar"</span> <span>>></span> <span>"<span>$file</span>"</span>
    <span>fi</span>
<span>done</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在bash中进行比较时，尽量使用双方括号 [[ ]] 而不是单方括号 [ ]，这样会降低犯错的几率，尽管这样并不能兼容 sh。</p>
<p>在shebang行(脚本第一行)中使用env命令(!/usr/bin/env bash)是一种好的实践，env会用PATH环境变量来进行定位，从而提高脚本的可移植性。</p>
<ul>
<li>函数只能用与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 shebang 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用export将环境变量导出，并将值传递给环境变量。</li>
</ul>
<h3 id="文件描述符"> 文件描述符</h3>
<ul>
<li>0 STDIN  标准输入 键盘 '/dev/stdin'</li>
<li>1 STDOUT 标准输出 显示器 '/dev/stdout', '/dev/stderr'</li>
<li>2 STDERR 标准错误</li>
<li>空：忽略输出 /dev/null</li>
</ul>
<p>当文件描述符(0,1,2)与重定向符号&quot;&lt;, &gt;&quot;组合之后，就可以重新定向输入，输出，及错误。</p>
<ul>
<li><code>command 2&gt;file1</code> 命令执行的错误信息保存到了file1文件中。显示屏只是显示正确的信息。</li>
<li><code>command 1&gt;file1 2&gt;file2</code> 命令执行后，没有显示。因为正确输出到file1，错误定向到file2</li>
<li><code>command &amp;&gt;file1</code> 命令执行后，输出和错误都定向到file1中
PS:2&gt;file 可以放在命令的前面，也可以放在后面。效果一样。</li>
</ul>
<p>在shell脚本中，进行流的重定向</p>
<ul>
<li>exec 1&gt; file1</li>
<li>exec 2&gt; file2</li>
<li>exec 0&lt; file0</li>
</ul>
<p>指定命令的输出传到STDERR指定的文件: <code>echo &quot;some output&quot; &gt;&amp;2</code></p>
<h2 id="shell工具"> shell工具</h2>
<h3 id="查看程序执行时间-time"> 查看程序执行时间--time</h3>
<h3 id="查找文件-find"> 查找文件--find</h3>
<p>find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]</p>
<p>find会搜索以每个给出的starting-point为根的文件树，找出匹配expression的文件。默认的starting-point为<code>.</code>。</p>
<p>选项</p>
<ul>
<li>-P 将symbolic links视为文件，不搜索其指向的文件。这是默认行为</li>
<li>-L 搜索symbolic links指向的文件</li>
<li>-H 不搜索symbolic links，除了在处理命令行参数的时候。(应该说的是最后的expression)</li>
<li>以上三个只能选一个。同时出现，只有最后一个生效。</li>
</ul>
<hr>
<ul>
<li>-D 打印find命令的诊断信息</li>
</ul>
<hr>
<ul>
<li>-Olevel 优化等级
<ul>
<li>0,1 默认等级。expressions重新排序，-name,-regex测试首先进行</li>
<li>2 -type,-xtype首先执行。</li>
<li>3 所有cost-based查询优化符都会启用。如果有必要的话，测试的顺序会以代价小的优先。</li>
</ul>
</li>
</ul>
<p>表达式--描述如何匹配文件和如何处理匹配的文件</p>
<ul>
<li>组成
<ul>
<li>Tests 返回T/F，通常以文件的属性为判断基础。</li>
<li>Actions 会产生其他影响。也会返回T/F，但以action的成功与否为基础。</li>
<li>Global options 总返回true。会影响所有Tests和Actions的行为。</li>
<li>Positional options 总返回true。只影响紧随其后的Tests或Actions。</li>
<li>Operators expression中其他东西的连接符。默认为 <code>-a</code> 即 <code>AND</code></li>
</ul>
</li>
<li>Positional options
<ul>
<li>-daystart 时间度量从今天0:00开始，而非24小时前。</li>
<li>-regextype type 改变正则表达式的语法。具体请 -regextype help</li>
<li>-warn,-nowarn 打开或关闭警告信息</li>
</ul>
</li>
<li>Global options
<ul>
<li>-d/-depth 先处理每个目录的内容，再处理目录本身</li>
<li>-maxdepth levels 目录树的最大展开深度。0表示只处理starting-point本身这个根节点。</li>
<li>-mindepth levels 目录树的最小展开深度。1表示只不处理starting-point本身这个根节点。</li>
</ul>
</li>
<li>Tests
<ul>
<li>数字参数 +n 大于n, -n 小于n, n 正好n。</li>
</ul>
<hr>
<ul>
<li>-xmin n 文件最后一次x是n分钟以前吗？</li>
<li>-xnewer reference 文件比指定文件的x更新吗？</li>
<li>-xtime n 文件最后一次x是n*24小时以内吗？(+1表示48小时以内，以次类推)</li>
<li>其中x可为
<ul>
<li>a access，表示文件的上次使用时间。</li>
<li>c change，表示文件状态的上次修改时间。</li>
<li>m modify，表示文件数据的上次修改时间。没有mnewer，因为-newer的默认行为就是这个。</li>
</ul>
</li>
<li>-newerXY reference 如果文件的X时间比Y时间新，则返回true。X,Y可以是
<ul>
<li>a accsess time</li>
<li>B birthtime</li>
<li>c inode status change time</li>
<li>m modification time</li>
<li>t reference直接解释为时间。</li>
</ul>
</li>
<li>-used n 文件上次status改变后到最后access时间过了n天</li>
</ul>
<hr>
<ul>
<li>-empty 空文件或空文件夹</li>
<li>-executable 当前用户可执行的文件</li>
<li>-gid n 文件的数字组(group)ID为n</li>
<li>-group gname 文件属于特定组</li>
<li>-uid n</li>
<li>-user uname</li>
<li>-ilname,-iname,-ipath,-iregex 忽略大小写版本</li>
<li>-inum n 文件有n个inode</li>
<li>-links n 文件有n个hard link</li>
<li>-lname pattern 文件是symbolic link且内容和pattern匹配。(如果使用的-L选项，则总返回false)</li>
<li>-name pattern 匹配文件名(只会用文件名取匹配，不包含任何<code>/</code>)。元字符<code>*</code> <code>?</code> <code>[]</code>会匹配以<code>.</code> 开头的文件。要忽略以<code>.</code>开头的文件和文件夹，使用-prune选项。</li>
<li>-path pattern 匹配完整的文件名(包含以某个starting point开始的路径，例如 ./src/hello.c)。注意：文件夹的末尾不会加<code>/</code>。</li>
<li>-wholename pattern 匹配完整的文件名(绝对路径)。</li>
<li>-regex pattern 匹配完整的文件名。(必须匹配整个完整的文件名，例如'./fubar3' 必须用'.*bar.'匹配)</li>
<li>-perm mode 所有的权限匹配。mode 0xxx，参考chmod</li>
<li>-perm -mode 所有的权限都有。 -[ugoa][rwx]</li>
<li>-perm /mode 有其中一个权限</li>
<li>-readable 当前用户可读</li>
<li>-writable 当前用户可写</li>
<li>-size n[cwbkMG] 使用n单位的空间的文件，会舍入。
<ul>
<li>b 表示512B为一个单位</li>
<li>c bytes</li>
<li>w two-byte word</li>
<li>k KiB, 1024B</li>
<li>M MiB, 1024k</li>
<li>G GiB, 1024M</li>
</ul>
</li>
<li>-type c 类型c包括
<ul>
<li>b block(buffered) special</li>
<li>c character(unbuffered) special</li>
<li>d 目录</li>
<li>p named pipe(FIFO)</li>
<li>f 常规文件</li>
<li>l symbolic link</li>
<li>s socket</li>
<li>D door</li>
</ul>
</li>
<li>-xtype 对symbolic link类型的文件，xtype会检查该link文件，而type不会。</li>
</ul>
</li>
<li>Actions
<ul>
<li>-delete 删除文件，成功时返回true。</li>
<li>-exec cmd; 执行cmd;，当cmd返回状态0时返回true。cmd会为每个匹配的文件执行一次。cmd会在执行find命令的起始目录执行。<code>{}</code>表示当前匹配的文件，<code>;</code>表示命令结束。</li>
<li>-exec cmd {} + <code>-exec</code>的变体，执行cmd，所有匹配的文件都用空格连接后作为参数放在cmd后。</li>
<li>-execdir cmd ;</li>
<li>-execdir cmd {} + cmd会在匹配文件所在目录执行</li>
<li>-ok cmd ;</li>
<li>-okdir cmd ; 执行命令时会弹出提示框，问你是否执行。</li>
<li>-ls 以ls -dils 的格式输出当前文件。</li>
<li>-fls file 将-ls的输出输出到file文件中。 如果file不存在，创建一个新的，否则，覆盖(truncated)。</li>
<li>-print 将完整文件名输出，以newline隔开。默认选项</li>
<li>-print0  将完整文件名输出，以'\0'隔开。</li>
<li>-printf format
<ul>
<li>%p 文件名 '%h/%f'</li>
<li>%P 不包含starting-point的文件名</li>
<li>%f 纯文件名</li>
<li>%F 文件使用的文件系统</li>
<li>%h 文件所在的文件夹名</li>
<li>%y 文件的类型</li>
<li>%i 文件的十进制inode数</li>
<li>%k 文件大小kB</li>
<li>%m 文件的八进制权限bit</li>
<li>%M 文件的权限符号表示</li>
<li>%s 文件大小B</li>
<li>%t/%a/%c/%Tk/%Ak/%Ck 文件时间，k为时间的表示方式。</li>
<li>%d 文件在目录树中的深度，0表示根节点starting-point。</li>
</ul>
</li>
<li>-fprint/-fprint0/-fprintf file [format]</li>
<li>-prune 如果文件是目录，不要进入。如果使用了-depth,-delete，则无效。</li>
<li>-quit 立即退出。</li>
</ul>
</li>
<li>Operators 按优先级降序
<ul>
<li>( expr ) 因为shell中括号有特殊含义，最好这么写'(expr)'</li>
<li>! expr</li>
<li>expr1 [-a] expr2 -a等于AND</li>
<li>expr1 -o expr2 -o等于OR</li>
<li>expr1, expr2 两个表达式都会被评估，但最后一个表达式的返回值成为整个列表的返回值。可以用于搜索一些不同类型的目标，但只遍历一次。</li>
<li>注意-a 比 -o 优先级高，意味着什么。举例来说，find . -name afile -o -name bfile -print 不会输出afile。</li>
</ul>
</li>
</ul>
<p>例如</p>
<div><pre><code><span># 查找所有名称为src的文件夹</span>
<span>find</span> <span>.</span> -name src -type d
<span># 查找所有文件夹路径中包含test的python文件</span>
<span>find</span> <span>.</span> -path <span>'*/test/*.py'</span> -type f
<span># 查找前一天修改的所有文件</span>
<span>find</span> <span>.</span> -mtime -1
<span># 查找所有大小在500k至10M的tar.gz文件</span>
<span>find</span> <span>.</span> -size +500k -size -10M -name <span>'*.tar.gz'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<div><pre><code><span># 删除全部扩展名为.tmp 的文件</span>
<span>find</span> <span>.</span> -name <span>'*.tmp'</span> -exec <span>rm</span> <span>{</span><span>}</span> <span>\</span><span>;</span>
<span># 查找全部的 PNG 文件并将其转换为 JPG</span>
<span>find</span> <span>.</span> -name <span>'*.png'</span> -exec convert <span>{</span><span>}</span> <span>{</span><span>}</span>.jpg <span>\</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="xargs"> xargs</h3>
<p>xargs [opts] [cmd [initial-args]]</p>
<p>xargs从标准输入读取items(以blank或newline为分隔符划分，空行直接忽略)，建立并执行cmd命令。initial-args默认是用item填，直到达到系统定义的命令行限制。这样，cmd的总调用数会相对变少，性能表现好些。另外，xargs默认会将blank和newline特殊处理，所以，包含blank和newline的文件名不会被正确处理，需要使用-0选项。</p>
<p>选项</p>
<ul>
<li>-t, --verbose 在执行cmd前，将其用STDERR输出</li>
<li>-p, --interactive 执行每个命令前让用户决定是否执行</li>
<li>-a file, --arg-file=file 从file读取输入，而非STDIN。如果使用了这个选项，则STDIN在执行cmd时不会变，否则会被重定向到/dev/null。</li>
<li>-r 如果标准输入为空，则不要执行任何cmd。xargs默认会至少执行一次</li>
</ul>
<hr>
<ul>
<li>-L max-lines 每个cmd使用的非空输入最多为max-line行。</li>
<li>-n max-args, --max-args=max-args 每个cmd最多使用max-args的参数。如果在达到max-args之前，size超了，则停。</li>
<li>-s max-chars, --max-chars=max-chars 限制每个cmd最多使用的字符数，包括cmd和initail-args和最后的'\0'。最多不能超过系统命令行限制。</li>
<li>-x, --exit 如果size超了，直接退出</li>
</ul>
<hr>
<ul>
<li>--show-limits 显示os的命令行长度限制。 最好这么用：<code>xargs --show-limits 0&lt; /dev/null</code></li>
<li>-P max-procs, --max-procs=max-proc 多线程执行。默认为1，设为0表示使用尽可能多的线程。</li>
<li>-0, --null items会以'\0'结束，而非空格。所有字符都取字面量。通常和find -print0连用。</li>
<li>-d delim, --delimiter=delim 输入item解析终止符。仅支持单个字符。</li>
<li>-E eof-str 如果在输入的某一行出现了eof-str，则其余的输入被忽略。</li>
</ul>
<div><pre><code><span>find</span> /tmp -name core -type f -print <span>|</span> <span>xargs</span> /bin/rm -f
<span>find</span> /tmp -name core -type f -print0 <span>|</span> <span>xargs</span> -0 /bin/rm -f
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="wc-代码统计"> wc--代码统计</h3>
<p>print newline, word, and byte counts for each file.</p>
<p>用法</p>
<ul>
<li>wc [OPTION] ... [FILE] ...</li>
<li>wc [OPTION] ... --file0-from=F</li>
<li>如果没有指定FILE或FILE=-，则以标准输入为输入。</li>
</ul>
<p>选项</p>
<ul>
<li>统计信息显示的相对顺序：newline, word, character, byte, maximum line length</li>
<li>-c, --bytes</li>
<li>-m, --chars</li>
<li>-l, --lines</li>
<li>--files0-from=F 用C风格字符串指定的所有输入文件</li>
<li>-L, --max-line-length</li>
<li>-w, --words</li>
</ul>
<h3 id="查找代码-grep"> 查找代码--grep</h3>
<p>grep 有很多选项，如 -C ：获取查找结果的上下文（Context）；-v 将对结果进行反选（Invert），也就是输出不匹配的结果。例如， grep -C 5 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 -R 会递归地进入子目录并搜索所有的文本文件。</p>
<h3 id="sed-流编辑器"> sed--流编辑器</h3>
<p>sed [opts] [script] [input-file]</p>
<ul>
<li>-n 使用安静模式，不会总显示stdin的所有行，只显示被sed处理的行。</li>
<li>-f scriptfile 读取文件中的操作脚本，并执行</li>
<li>-r 使用扩展的正则表达式语法</li>
<li>-i 直接修改文件内容</li>
<li>script
<ul>
<li>#a content: 在#行，后新增一行，内容为content</li>
<li>#i content: 在#行，前新增一行，内容为content</li>
<li>l,hc content: 将l行到h行的内容替换为content</li>
<li>l,hd: 删除l行到h行。$表示最后一行</li>
<li>l,hp: 打印l行到h行。</li>
<li>[l,h]s/old/new/g: 查找并替换</li>
</ul>
</li>
</ul>
<h3 id="awk-行文本处理"> awk--行文本处理</h3>
<p>常见用法: awk 'program text' file, 从file中读取输入，每一行都用'program text'处理。</p>
<ul>
<li>awk每次处理一行，最小处理单位为字段(field, 以空格分隔)</li>
<li>变量
<ul>
<li>$0 整行</li>
<li>$# 第#个字段</li>
<li>NF 第一行的字段总数</li>
<li>NR 当前awk处理的是第几行</li>
<li>FS 目前的分隔符，默认为空格</li>
</ul>
</li>
<li>逻辑运算 &gt;,&lt;,&gt;=, &lt;=, ==, !=</li>
</ul>
<hr>
<p>mawk [-F separator] [-v var=value] [--] 'program text' [file...]<br>
mawk [-F separator] [-v var=value] [-f program-file] [--] [file...]</p>
<ul>
<li>-F 指定分隔符</li>
<li>-v 预先设置变量</li>
<li>-f 从指定的文件中读取awk程序</li>
<li>file 输入，未指定则从STDIN中读取</li>
</ul>
<hr>
<p>AWK语言</p>
<ul>
<li>程序结构： pattern{action}的序列
<ul>
<li>pattern可以是
<ul>
<li>BEGIN 在处理第一行之前顺序执行所有的 BEGIN 后的action。</li>
<li>END 在处理最后一行之后顺序执行所有的 END 后的action。</li>
<li>expr</li>
<li>expr1, expr2</li>
</ul>
</li>
<li>语句以<code>;</code>或newline结束。</li>
<li>控制流
<ul>
<li>if (expr) statement</li>
<li>if (expr) statement else statement</li>
<li>while (expr) statement</li>
<li>do statement while (expr)</li>
<li>for (opt_expr; opt_expr; opt_expr) statement</li>
<li>for (var in array) statement</li>
<li>continue</li>
<li>break</li>
</ul>
</li>
</ul>
</li>
<li>数据类型：numeric和string。
<ul>
<li>所有numeric都是以浮点数为内部表示和运算。true == 1.0</li>
<li>string常量以双引号表示</li>
</ul>
</li>
<li>正则表达式
<ul>
<li>expr ~ /regex/ 如果expr匹配regex，则返回1.</li>
<li>expr !~ /regex/ 如果expr不匹配regex，则返回1.</li>
<li>/r/ {action} 相当于 $0 ~ /r/ {action}, 当行匹配r时，才执行action</li>
</ul>
</li>
<li>内置变量
<ul>
<li>$0 整行</li>
<li>$# 第#个字段</li>
<li>NF 第一行的字段总数</li>
<li>NR 当前awk处理的是第几行</li>
<li>FS 目前的field分隔符，默认为空格</li>
<li>RS record分隔符，默认为'\nm'</li>
<li>OFS,ORS 输出时的相应分隔符</li>
<li>ARGC</li>
<li>ARGV</li>
<li>FILENAME 输入文件的文件名</li>
</ul>
</li>
<li>内置函数
<ul>
<li>数学函数
<ul>
<li>atan2(y, x)</li>
<li>cos(x)</li>
<li>sin(x)</li>
<li>exp(x)</li>
<li>int(x) 向0舍入</li>
<li>log(x) 自然对数</li>
<li>rand()</li>
<li>srand(seed)</li>
<li>sqrt(x)</li>
</ul>
</li>
<li>mktime(format)</li>
<li>String
<ul>
<li>index(s, t) t在s中的起始位置</li>
<li>length(s)</li>
<li>match(s, r) 返回s中第一个r的位置</li>
<li>split(s, A, r) 用r分割s为一系列field，并以数组形式存储在A中。如果r省略，默认为FS。</li>
<li>sprintf(format, expr-list) 返回一个格式串</li>
<li>sub(r, s, t) 替换一次 将t中的r替换成s。 t缺省为$0</li>
<li>gsub(r, s, t) 全部替换</li>
<li>substr(s, i, n) 返回s第i个字符后的n个字符，n省略，则返回i后所有字符。(包含第i个)</li>
<li>tolower(s) 将s中全部字符换为小写</li>
<li>toupper(s)</li>
</ul>
</li>
</ul>
</li>
<li>输出
<ul>
<li>print 将$0输出</li>
<li>print expr1,expr2,... 输出 expr1 OFS expr2 OFS...ORS</li>
<li>printf format, expr-list</li>
<li>getline 略</li>
</ul>
</li>
</ul>
<hr>
<p>示例</p>
<ol>
<li>模拟cat {print}</li>
<li>模拟wc {chars += length($0) + 1 # add 1 for the '\n'
words += NF}
END {print NR, words, chars}</li>
<li>排序文件</li>
</ol>
<div><pre><code>{line[NR] = $0 &quot;&quot;} # 确保每一行都是string类型
END {
    isort(line, NR)
    for (i =1; i &lt;=NR; i++) print line[i]    
}
 
function isort(A, n,  i, j, hold)
{
    for (i = 2; i &lt;= n; i++)
    {
        hold = A[j = i]
        while (A[j-1] &gt; hold)
        { j--; A[j+1] = A[j]}
        A[j] = hold
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="nl-加行号显示"> nl--加行号显示</h3>
<p><code>nl [opts] [file]</code> file为<code>-</code>或未指定时，从STDIN读入。</p>
<h3 id="文件夹导航"> 文件夹导航</h3>
<p>fasd和autojump这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于frecency对文件和文件排序，也就是说它会同时针对频率（frequency ）和时效（ recency）进行排序。默认情况下，fasd使用命令 z 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问/home/user/files/cool_project 目录，那么可以直接使用 z cool 跳转到该目录。对于 autojump，则使用j cool代替即可。</p>
<h2 id="cheatsheet"> cheatsheet</h2>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">man</td>
<td style="text-align:left">用户手册</td>
</tr>
<tr>
<td style="text-align:center">cd</td>
<td style="text-align:left">切换目录</td>
</tr>
<tr>
<td style="text-align:center">pwd</td>
<td style="text-align:left">当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">which</td>
<td style="text-align:left">确定某个程序名代表的是哪个具体程序</td>
</tr>
<tr>
<td style="text-align:center">ls</td>
<td style="text-align:left">显示目录包含的文件</td>
</tr>
<tr>
<td style="text-align:center">mv</td>
<td style="text-align:left">移动或重命名文件</td>
</tr>
<tr>
<td style="text-align:center">cp</td>
<td style="text-align:left">复制文件</td>
</tr>
<tr>
<td style="text-align:center">rm</td>
<td style="text-align:left">删除文件</td>
</tr>
<tr>
<td style="text-align:center">mkdir</td>
<td style="text-align:left">新建文件夹</td>
</tr>
<tr>
<td style="text-align:center">touch</td>
<td style="text-align:left">创建文件或修改文件时间</td>
</tr>
<tr>
<td style="text-align:center">chmod [mode] FILE</td>
<td style="text-align:left">修改文件权限</td>
</tr>
<tr>
<td style="text-align:center">grep [pattern] FILE</td>
<td style="text-align:left">打印pattern匹配成功的行</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>vim</title>
      <link>https://kigane.github.io/note/cs/vim/</link>
      <guid>https://kigane.github.io/note/cs/vim/</guid>
      <source url="https://kigane.github.io/rss.xml">vim</source>
      <category>使用指南</category>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="vim基础"> Vim基础</h2>
<h3 id="资料"> 资料</h3>
<p><a href="https://missing-semester-cn.github.io/2020/editors/" target="_blank" rel="noopener noreferrer">学习Vim</a><br>
vimtutor : Vim安装时自带的教程<br>
<a href="https://vim-adventures.com/" target="_blank" rel="noopener noreferrer">Vim Adventures</a><br>
<a href="https://vimways.org/2019/" target="_blank" rel="noopener noreferrer">Vim 小技巧</a></p>
<p><img src="/assets/img/vim-keyboard.png" alt="Vim 键盘图" /></p>
<h3 id="改键"> 改键</h3>
<p>ubantu</p>
<ul>
<li>setxkbmap -option caps:escape capslock映射为esc</li>
<li>setxkbmap -option ctrl:nocaps capslock映射为ctrl</li>
</ul>
<h3 id="模式"> 模式</h3>
<p>Vim的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p>
<ul>
<li>正常模式：在文件中四处移动光标进行修改</li>
<li>插入模式：插入文本</li>
<li>替换模式：替换文本</li>
<li>可视化(一般，行，块)模式：选中文本块</li>
<li>命令模式：用于执行命令</li>
</ul>
<p>在不同的操作模式下，键盘敲击的含义也不同。</p>
<p>按下 <code>ESC</code> 从任何其他模式返回正常模式。 在正常模式，键入 <code>i</code> 进入插入 模式， <code>R</code> 进入替换模式， <code>v</code> 进入可视(一般)模式， <code>V</code> 进入可视(行)模式， <code>Ctrl-V</code>, 有时也写作 <code>^V</code>进入可视(块)模式， <code>:</code> 进入命令模式。</p>
<p>Vim 最重要的设计思想是 Vim 的界面本身是一个程序语言。键入操作本身是命令， 这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p>
<h3 id="缓存-标签页-窗口"> 缓存，标签页，窗口</h3>
<p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim 会话包含一系列标签页，每个标签页包含一系列窗口(分隔面板)。每个窗口显示一个缓存(可以是同一个缓存)。</p>
<p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p>
<h3 id="基操"> 基操</h3>
<ul>
<li><code>vim $(fzf)</code></li>
<li><code>:q</code>退出(关闭窗口)</li>
<li><code>:w</code>保存当前文件(写)</li>
<li><code>:w FILE</code> 另存为</li>
<li><code>:wq</code>保存然后退出</li>
<li><code>:e {文件名}</code> 打开要编辑的文件</li>
<li><code>:ls</code>显示打开的缓存</li>
<li><code>:help {标题}</code> 打开帮助文档
<ul>
<li><code>:help :w</code>打开 <code>:w</code>命令的帮助文档</li>
<li><code>:help w</code>打开 <code>w</code> 移动的帮助文档</li>
</ul>
</li>
</ul>
<h3 id="移动"> 移动</h3>
<p>正常模式下
在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。</p>
<ul>
<li>基本移动: hjkl (左， 下， 上， 右)</li>
<li>单词word： w (下一个词的首字母)， b (当前词首)， e (当前词尾) ge(上一个单词词尾)</li>
<li>广义单词WORD： W, B, E, gE (广义单词为空格之间的所有字符，单词为数字字母下划线的序列)</li>
<li>段落： <code>{</code>, <code>}</code>。段落是由空行隔开的代码段。</li>
<li>行： 0 (行初)， ^ | _ (第一个非空格字符)， $ (行尾)</li>
<li>屏幕： H (屏幕首行)， M (屏幕中间)， L (屏幕底部)</li>
<li>文件： gg (文件头)， G (文件尾)</li>
<li>行数： <code>:{num}&lt;CR&gt;</code> 或者 <code>{num}G</code> 转到第num行</li>
<li>ctrl+f 向下翻页</li>
<li>ctrl+b 向上翻页</li>
<li>ctrl+d 向下翻半页</li>
<li>ctrl+u 向上翻半页</li>
<li><strong>杂项： % (找到配对，比如各种括号)</strong></li>
<li>查找： f{字符}， t{字符}， F{字符}， T{字符}
<ul>
<li>查找(find)/到(until) 向前/向后 在本行的{字符}</li>
<li><code>,</code> / <code>;</code> 用于导航匹配</li>
</ul>
</li>
</ul>
<h3 id="编辑"> 编辑</h3>
<p>Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</p>
<ul>
<li>O / o 在之上/之下插入行，并进入编辑模式</li>
<li>r{char}: 替换一个字符</li>
<li>R: 进入替换模式</li>
<li>d{移动命令} 删除 {移动命令}
<ul>
<li>例如， dw 删除词, d$ 删除到行尾, d0 删除到行头。</li>
</ul>
</li>
<li>c{移动命令} 改变 {移动命令}
<ul>
<li>例如， cw 改变词 相当于 d{移动命令} 再 i</li>
</ul>
</li>
<li>cc 删除该行并在该行进入插入模式</li>
<li>x 删除字符（等同于 dl）</li>
<li>s 替换字符（等同于 xi）</li>
<li>可视化模式 + 操作
<ul>
<li>选中文字, d 删除 或者 c 改变</li>
</ul>
</li>
<li>u 撤销, Ctrl-r 重做</li>
<li>y 复制 (复制大段需要进入VISUAL模式)</li>
<li>yy 复制一行</li>
<li>p 粘贴 (也可将刚刚删除的内容(储存在Vim寄存器中)粘贴到光标后)</li>
</ul>
<h3 id="计数"> 计数</h3>
<p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p>
<ul>
<li>3w 向前移动三个词</li>
<li>5j 向下移动5行</li>
<li>7dw 删除7个词</li>
</ul>
<h3 id="搜索"> 搜索</h3>
<ul>
<li>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配，向后/向前
<ul>
<li>set hls(earch) 设置搜索高亮</li>
<li>:noh 清楚高亮显示</li>
</ul>
</li>
<li>:grep 系统的grep</li>
<li>:vimgrep pattern path 在目录中搜索pattern。<code>**</code>表示递归搜索。 <code>**/*.c</code>搜索具体文件类型。
<ul>
<li>执行后，vim会跳转到第一个匹配项处</li>
<li>:cn, :cp 逐个浏览匹配项</li>
<li>:copen 显示匹配列表</li>
</ul>
</li>
</ul>
<h3 id="修饰语"> 修饰语</h3>
<p>你可以用修饰语改变“名词”的意义。修饰语有 i，表示“内部”或者“在内“，和 a， 表示”周围“。</p>
<ul>
<li>ci( 改变当前括号内的内容</li>
<li>ci[ 改变当前方括号内的内容</li>
<li>da' 删除一个单引号字符串， 包括周围的单引号</li>
</ul>
<h3 id="扩展vim"> 扩展Vim</h3>
<p>Vim 有很多扩展插件。从 Vim 8.0 开始，你可以使用内置的插件管理系统。只需要创建一个 ~/.vim/pack/vendor/start/ 的文件夹，然后把插件放到这里。</p>
<p><a href="https://vimawesome.com/" target="_blank" rel="noopener noreferrer">vimawesome</a></p>
<h2 id="practice-vim"> practice vim</h2>
<ul>
<li>
<p><code>.</code> 用于重复一次修改。(从进入插入模式开始到按ESC退出为止的所有操作)。</p>
</li>
<li>
<p><code>u</code> 撤销一次修改。输入间隔的停顿时间较长时，就退出吧。可以控制撤销粒度。</p>
</li>
<li>
<p>在插入模式中使用Up,Down等光标键，将会产生一个新的撤销块。可以认为是先退回普通模式，在执行jklh。也会影响<code>.</code>命令。</p>
</li>
<li>
<p><code>f{char}</code> 用于在一行内查找下一个指定字符，并立即将光标移动到那里。</p>
</li>
<li>
<p><code>;</code> 会重复向后查找上次f命令查找的字符</p>
</li>
<li>
<p><code>,</code> 和<code>;</code>方向相反</p>
</li>
<li>
<p>j,k,0,$用于操作实际行，但加上g前缀后操作屏幕行。</p>
</li>
<li>
<p><code>:s/target/replacement</code> 使用<code>&amp;</code>重复。</p>
</li>
<li>
<p><code>*</code> 查找当前光标下的单词。光标会跳到下一个匹配项。</p>
</li>
<li>
<p><code>&lt;C-h&gt;</code> 删除前一个字符，同BS</p>
</li>
<li>
<p><code>&lt;C-w&gt;</code> 删除前一个单词</p>
</li>
<li>
<p><code>&lt;C-u&gt;</code> 删除至行首。这三个命令比较通用。</p>
</li>
<li>
<p><code>&lt;C-o&gt;</code> 进入插入-普通模式，执行一个命令后返回插入模式。</p>
</li>
<li>
<p><code>&lt;C-r&gt;=</code> 使用表达式寄存器计算一个表达式，并插入结果。</p>
</li>
<li>
<p><code>&lt;C-v&gt;{123}</code> 插入三位数ASCII码对应的字符</p>
</li>
<li>
<p><code>&lt;C-v&gt;u{1234}</code> 插入Unicode码对应的字符</p>
</li>
<li>
<p><code>&lt;C-k&gt;{char1}{char2}</code> 插入组合字符表示的单个字符</p>
</li>
<li>
<p><code>ga</code> 查看光标所在字符的 ASCII码，Unicode码，字符组合(digr)</p>
</li>
<li>
<p><code>&lt;C-g&gt;</code> 在可视模式和选择模式中切换</p>
</li>
<li>
<p><code>o</code> 在可视模式中可以切换固定的端点。</p>
</li>
<li>
<p><code>gv</code> 重新选择上次的高亮选区</p>
</li>
<li>
<p><code>:xx</code> 由于历史原因，被称为Ex命令</p>
</li>
<li>
<p>[range]格式为{start},{end}。</p>
<ul>
<li><code>.</code>表示当前行</li>
<li><code>%</code>表示所有行</li>
<li><code>'&lt;,'&gt;</code>表示当前高亮选区</li>
<li>start，end也可以是模式。如<code>:/&lt;html&gt;/,/&lt;\/html&gt;/p</code>打印html标签所在行及之间的所有行。</li>
<li>start,end也可以加上偏移。如<code>:/&lt;html&gt;/+1,/&lt;\/html&gt;/-1p</code>打印html标签之间的所有行(不包括所在行)。</li>
<li>0 表示文件第一行上方的虚拟行</li>
</ul>
</li>
<li>
<p>:{num} num被解析为地址，会跳转到指定行。</p>
</li>
<li>
<p>:[range]normal {commands} 对指定范围内的所有行执行相同的命令</p>
</li>
<li>
<p>:copy | :co | :t 复制指定行并粘贴到当前行下方。不会使用寄存器。</p>
</li>
<li>
<p><code>@:</code> 重复上次Ex命令</p>
</li>
<li>
<p><code>q:</code> 打开命令行窗口，记录了Ex命令历史，可以轻松重复以前的Ex命令</p>
</li>
<li>
<p>:shell 打开shell。exit回到vim。</p>
</li>
<li>
<p><code>z&lt;CR&gt;</code> 将光标行放到屏幕顶端</p>
</li>
<li>
<p><code>zz</code> 将光标行放到屏幕中间</p>
</li>
</ul>
<h3 id="text-object"> Text Object</h3>
<ul>
<li>aw: a word</li>
<li>iw: inner word</li>
<li>aW: a WORD</li>
<li>as: a setence</li>
<li>is</li>
<li>ap: a paragraph</li>
<li>ip</li>
<li><code>a[ | a]</code> a [] block, <code>&quot;[content]&quot;-&gt;&quot;[content]&quot;</code></li>
<li><code>i[ | i]</code> inner [] block, <code>&quot;[content]&quot;-&gt;&quot;content&quot;</code></li>
<li>a,i作为前缀省略</li>
<li><code>(,),b</code></li>
<li><code>&lt;,&gt;</code></li>
<li><code>t</code> tag block <code>&lt;a&gt;content&lt;/a&gt;</code></li>
<li><code>{,},B</code></li>
<li>&quot;</li>
<li>'</li>
<li>`</li>
</ul>
<h2 id="vim进阶"> Vim进阶</h2>
<h3 id="vim生成的文件"> vim生成的文件</h3>
<ul>
<li>backup 是普通的加~备份.</li>
<li>undofile 加后缀un~。用于在下次打开文件时也可以执行撤销命令撤销上次的修改。</li>
<li>writebackup 是防止灾难时的加~备份, 特点是文件正常写入之后就会自动删除. 也就是说如果你的文件有正常写入(不正常情况通常发生在磁盘快要满的时候), 你是很难见到这个文件出现的.</li>
<li>swapfile 也是防止灾难, 不过是缓冲区的备份, 也就是你正在编辑的内容. 如果你在编辑的时候电脑断电或者Vim发生异常退出, 而你没有保存, 你可以从.file.txt.swp里恢复这个文件.</li>
</ul>
<p>禁止备份功能<br>
在~/.vimrc中添加</p>
<div><pre><code>set nobackup
set noundofile
set nowritebackup
set noswapfile
" 备份到某个目录  // 表示会保存目录信息到文件名中
set directory=$HOME/.vim/tmp//
set backupdir=$HOME/.vim/tmp//
set undodir=$HOME/.vim/tmp//
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="搜索和替换"> 搜索和替换</h3>
<ul>
<li><code>:s/foo/bar/g</code> 当前行的foo替换成bar</li>
<li><code>:%s/foo/bar/gc</code> 所有行的foo替换成bar，且需要一个个确认(<code>c</code>)</li>
<li><code>:5,12s/foo/bar/g</code> 5-12行的foo替换成bar</li>
</ul>
<h3 id="宏"> 宏</h3>
<ul>
<li>q{字符} 来开始在寄存器{字符}中录制宏</li>
<li>q停止录制</li>
<li>@{字符} 重放宏</li>
<li>宏的执行遇错误会停止</li>
<li>{计数}@{字符}执行一个宏{计数}次</li>
</ul>
<h3 id="在vim中执行外部命令"> 在Vim中执行外部命令</h3>
<p><code>:!external command&lt;CR&gt;</code>: <code>!</code>和回车之间的都是被当做外部命令执行。</p>
<h3 id="保存选中部分-取回内容"> 保存选中部分，取回内容</h3>
<p>按v进入可视化模式，移动以选择内容。然后<code>:w FILE</code>即可。<br>
注意按<code>:</code>后底部出现了<code>:'&lt;,'&gt;</code>。</p>
<p><code>:r FILE</code> 将FILE内容放入光标下一行<br>
<code>:r !cmd</code> 将cmd的输出放入光标下一行</p>
<h3 id="设置"> 设置</h3>
<p><code>:set xxx</code></p>
<ul>
<li>ic : 搜索时忽略大小写</li>
<li>hls : 高亮匹配的字符</li>
<li>noxxx : 取消xxx设置</li>
</ul>
<h3 id="自动补全"> 自动补全</h3>
<p>Vim命令也有自动补全，<code>tab</code>补全唯一的一个,<code>ctrl-d</code>显示所有候选。</p>
<h3 id="代码折叠"> 代码折叠</h3>
<ul>
<li>在.vimrc中设置 set foldmethod=syntax|indent</li>
<li>zc 折叠</li>
<li>zo 展开</li>
<li>za 折叠展开切换</li>
<li>zR 打开所有折叠</li>
<li>zM 关闭所有折叠</li>
</ul>
<h3 id="命令重映射"> 命令重映射</h3>
<ul>
<li>:map 递归映射</li>
<li>:unmap 取消映射</li>
<li>:mapclear 清除所有映射</li>
<li>:noremap 非递归映射</li>
<li>前缀
<ul>
<li>nore: 非递归</li>
<li>n: 在普通模式下生效</li>
<li>v | x: VISUAL模式</li>
<li>i: INSERT模式</li>
<li>c: 命令模式</li>
</ul>
</li>
<li>键表
<ul>
<li><code>&lt;k0&gt;</code> - <code>&lt;k9&gt;</code> 小键盘 0 到 9</li>
<li><code>&lt;S-...&gt;</code> Shift＋键</li>
<li><code>&lt;C-...&gt;</code> Control＋键</li>
<li><code>&lt;M-...&gt;</code> Alt＋键 或 meta＋键</li>
<li><code>&lt;A-...&gt;</code> 同 <code>&lt;M-...&gt;</code></li>
<li><code>&lt;Esc&gt;</code> Escape</li>
<li><code>&lt;Up&gt;</code> 光标上移键</li>
<li><code>&lt;Space&gt;</code> 空格</li>
<li><code>&lt;Tab&gt;</code> Tab</li>
<li><code>&lt;CR&gt;</code> 等于<code>&lt;Enter&gt;</code></li>
<li><code>&lt;f1&gt;~&lt;f12&gt;</code></li>
<li><code>&lt;home&gt; &lt;insert&gt; &lt;del&gt; &lt;end&gt;</code></li>
<li><code>&lt;nop&gt;</code> 无操作</li>
</ul>
</li>
</ul>
<div><pre><code>" 在插入模式下加入一对引号或括号
inoremap ' ''<span><span><span>&lt;</span>esc</span><span>></span></span>i
inoremap " ""<span><span><span>&lt;</span>esc</span><span>></span></span>i
inoremap ( ()<span><span><span>&lt;</span>esc</span><span>></span></span>i
inoremap [ []<span><span><span>&lt;</span>esc</span><span>></span></span>i
inoremap { {}<span><span><span>&lt;</span>esc</span><span>></span></span>i
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="先导键-leader-key"> 先导键(leader key)</h3>
<p>本质是用户或插件自定义的快捷键的命令空间。默认的先导键为<code>\</code>。</p>
<div><pre><code>" 需要放在.vimrc的顶部
" let mapleader = ','
let mapleader = "\<span><span><span>&lt;</span>space</span><span>></span></span>" " mapleader变量中不含特殊字符，所以转义字符是必要的
" 使用先导键
nnoremap <span><span><span>&lt;</span>leader</span><span>></span></span>w :w<span><span><span>&lt;</span>cr</span><span>></span></span> " 用leader-w保存文件 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="vim寄存器"> vim寄存器</h3>
<p>使用<code>&quot;</code>访问寄存器</p>
<ul>
<li>无名寄存器 复制粘贴默认使用的寄存器。可用<code>&quot;</code>访问</li>
<li>a~z寄存器 用于手动复制数据。例如，将一个单词复制到a寄存器,<code>&quot;ayw</code>,粘贴<code>&quot;ap</code></li>
<li>0~9寄存器 最近10次删除的历史记录</li>
<li>只读寄存器
<ul>
<li><code>%</code> 当前文件名</li>
<li><code>#</code> 文件所在目录</li>
<li><code>.</code> 最后插入的文本</li>
<li><code>:</code> 最后执行的命令</li>
</ul>
</li>
<li><code>*</code> 系统的主粘贴板</li>
<li><code>+</code> Linux中<code>&lt;C-c|v&gt;</code>使用的粘贴板</li>
<li>使用:reg rid 访问寄存器内容</li>
</ul>
<h2 id="多文件-多窗口"> 多文件，多窗口</h2>
<ul>
<li>:help window-moving</li>
<li>:help window-resize</li>
<li>:ls 显示所有buffer。 %当前焦点所在的文件。#轮换文件，按<code>C-^</code>可以切换到该文件。a活动窗口。</li>
<li>:w! 将磁盘中的文件读入缓冲区。即回滚所有修改。</li>
<li>:q! 不修改，关闭所有窗口。</li>
<li><code>&lt;C-w&gt;&lt;C-w&gt;</code> 按住ctrl，连续按ww可以循环切换窗口。</li>
<li>:pwd 查看vim当前工作目录。默认是在shell中打开vim时，shell的工作目录。</li>
<li>:lcd {path} 设置当前窗口的本地工作目录</li>
<li>:windo lcd {path} 为所有窗口设置本地工作目录</li>
<li>% 在文件路径中表示当前缓冲区的完整文件路径。按tab展开。</li>
<li>%:h 当前缓冲区的完整文件路径，去除了文件名。</li>
<li>重映射 <code>cnoremap &lt;expr&gt;%% getcmdtype() == ':' ? expand('%:h').'/' : '%%'</code></li>
</ul>
<p>在不同文件buffer间切换</p>
<ul>
<li>:bn 下一个文件buffer</li>
<li>:bp 上一个文件buffer</li>
<li>:ls 输出buffer列表 %表示当前窗口的缓冲区，a表示活动的缓冲区(可见)。</li>
<li>:b[num] 切换到第num个buffer</li>
<li>:b{bufname} 使用文件名切换</li>
<li>:bd 删除缓冲区</li>
<li>:e file 打开文件</li>
<li>:jumps 显示vim的跳转列表。
<ul>
<li><code>&lt;C-o&gt;</code> 在跳转列表中后退</li>
<li><code>&lt;C-i&gt;</code> 前进</li>
</ul>
</li>
<li>:changes 显示vim的修改记录表。
<ul>
<li>g; 跳转到上一次修改的地方</li>
<li>g, 下</li>
</ul>
</li>
<li>:find 在当前path下查找文件或文件夹。不支持模糊。不加**则不会进入子文件夹</li>
<li>set path+=...</li>
<li>:set path? 查看path的值</li>
<li>gf 跳转到光标下的文件</li>
</ul>
<p>用 <code>:sp</code> / <code>:vsp | :vs</code> 来分割窗口<br>
同一个缓存可以在多个窗口中显示。</p>
<p>切换</p>
<ul>
<li><code>&lt;C-W&gt; j</code> 下一个</li>
<li><code>&lt;C-W&gt; k</code> 上一个</li>
<li><code>&lt;C-W&gt; h</code> 左边一个</li>
<li><code>&lt;C-W&gt; l</code> 右边一个</li>
<li><code>&lt;C-W&gt; w</code> | <code>&lt;C-W&gt; &lt;C-w&gt;</code> 一个一个遍历窗口</li>
<li><code>&lt;C-W&gt; o</code> 只保留当前窗口</li>
<li><code>:close</code> 关闭当前窗口，不会退出Vim</li>
</ul>
<p>标签页</p>
<ul>
<li>:tabnew [file] 打开新标签页</li>
<li>:tabedit [file] 打开新标签页</li>
<li>gt | :tabnext</li>
<li>gT | :tabprevious</li>
<li>Ngt 跳转到标签页N</li>
<li>:tabclose</li>
<li>:tabmove N 将当前标签页移动到第N个标签页之后</li>
<li>:tabonly</li>
<li><code>&lt;C-w&gt; T</code> 将当前窗口移动到一个新标签页</li>
</ul>
<p>调整窗口大小</p>
<ul>
<li><code>[num]&lt;C-W&gt; +</code> 当前窗口增加一行</li>
<li><code>[num]&lt;C-W&gt; -</code> 当前窗口减少一行</li>
<li>:resize +n|-n 简写:res。垂直。</li>
<li>:vertical resize +n|-n 简写:vert res。水平</li>
<li><code>&lt;C-W&gt; =</code> 将所有窗口宽高恢复一致。</li>
</ul>
<h2 id="会话-session"> 会话(session)</h2>
<ul>
<li>保存 <code>:mksession ~/.vim/sessions/xxx.vim</code> | <code>:mks ~/.vim/sessions/xxx.vim</code></li>
<li>恢复 <code>vim -S ~/.vim/sessions/xxx.vim</code></li>
</ul>
<h2 id="插件"> 插件</h2>
<p>:so % 在vim中直接source当前文件</p>
<h3 id="vim-plug"> vim-plug</h3>
<ul>
<li>下载文件 <code>curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.github.com/junegunn/vim-plug/master/plug.vim</code></li>
<li>vim-plug初始化 在.vimrc中添加两个call。</li>
<li>插件管理
<ul>
<li>添加插件 <code>Plug &lt;username&gt;/&lt;repo&gt;</code></li>
<li>:PlugInstall 安装添加的插件</li>
<li>:PlugUpdate 更新插件</li>
<li>:PlugUpgrade 更新vim-plug。需要source一下。</li>
<li>:PlugClean 移除不用的插件</li>
</ul>
</li>
<li>插件延迟加载
<ul>
<li>Plug 'scrooloose/nerdtree', {'on', : 'NERDTreeToggle'} 在执行'NERDTreeToggle'命令时再加载</li>
<li>Plug 'junegunn/goyo.vim', {'for', : 'markdown'} 按文件类型加载</li>
</ul>
</li>
</ul>
<div><pre><code>call plug<span>#begin()</span>
Plug <span>'mileszs/ack.vim'</span>
Plug <span>'easymotion/vim-easymotion.vim'</span>
call plug<span>#end()</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="ctags"> ctags</h3>
<p><code>sudo apt-get install ctags</code></p>
<h4 id="生成tags文件"> 生成tags文件</h4>
<p>在源码根目录下</p>
<div><pre><code>ctags -R --exclude<span>=</span>.git --exclude<span>=</span>vendor/* --<span>..</span>.
</code></pre>
<div><span>1</span><br></div></div><p>这样就会生成一个tags文件，ctags需要这个文件实现跳转。<br>
常用的选项可以写在 ~/.ctags 文件中</p>
<div><pre><code>-R
--exclude<span>=</span>.git
--exclude<span>=</span>vendor/*
<span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>自动生成ctags</p>
<div><pre><code>autocmd BufWritePost *.c *.h *.cpp silent! !ctags -R &amp;
</code></pre>
<div><span>1</span><br></div></div><h4 id="how-to-use"> How to use</h4>
<ul>
<li>找一个指定的tag，并用Vim打开其定义位置，在shell中使用 <code>vim -t &lt;tag&gt;</code>，也可以使用正则</li>
<li>在Vim中
<ul>
<li><code>ctrl+]</code>(有多个tag时，会选一个直接进入) 或 <code>g]</code>(有多个会显示一个列表) 或 <code>:ta[g] ctrl+rw</code> 跳转到tag</li>
<li><code>:ts tag_name</code> 列出所有tag_name匹配的tag</li>
<li><code>:pts tag_name</code> <code>:ts</code>功能，但有预览</li>
<li><code>ctrl+w}</code> 或 <code>:ptag ctrl+rw</code> 预览tag</li>
<li><code>ctrl+wz</code> 或 <code>:pc</code> 关闭上面打开的预览</li>
<li><code>:tn</code> 或 <code>:tp</code> 在多个匹配的tag上跳转</li>
<li><code>ctrl+t</code> 向tag栈底跳一格(相当于返回上一个tag)</li>
<li><code>:tags</code> 显示tag栈，当前活动的有 <code>&gt;</code> 标记</li>
</ul>
</li>
<li>使用正则
<ul>
<li><code>:tag main</code> 直接跳转到 tag &quot;main&quot;</li>
<li><code>:tag /^get</code> 直接跳转到以&quot;get&quot;开头的 tag</li>
<li><code>:tag /Final$</code> 直接跳转到以&quot;Final&quot;结尾的 tag</li>
<li><code>:tag /norm</code> 列出包含&quot;norm&quot;的 tag</li>
<li><code>:tag /Final$\C</code> 列出以&quot;Final&quot;结尾的 tag
PS：记得要保持tags索引文件最新</li>
</ul>
</li>
</ul>
<h3 id="youcompleteme"> YouCompleteMe</h3>
<p>需要安装cmake和llvm。因为该插件需要编译代码。 <code>sudo apt-get install cmake llvm</code></p>
<div><pre><code>" .vimrc中配置vim-plug
let g:plug_timeout = 300 " 为插件增加超时时间
Plug 'Valloric/YouCompleteMe', {'do': './install.py'}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>:source ~/.vimrc | PlugInstall</p>
<h3 id="ack"> ack</h3>
<p>mileszs/ack.vim</p>
<ul>
<li>:Ack [opts] {pattern} [{dirs}]</li>
<li>--cc为c，--rr为r。ack规定语言必须大于一个字符。</li>
<li>在搜索结果中
<ul>
<li>? 命令帮助</li>
<li>o 同 enter</li>
<li>O 打开文件并关闭搜索窗口</li>
<li>go 打开文件但焦点保持在搜索结果窗口</li>
<li>q 退出</li>
<li>v,h,t,V,H,T 小写打开并切换到，大写打开但焦点保持在搜索结果窗口</li>
<li>gv 在右边打开一个窗口，焦点保持在搜索结果窗口</li>
</ul>
</li>
</ul>
<h3 id="ctrlp"> ctrlp</h3>
<p>完整路径模糊查找。可查文件，buffer，最近使用文件(MRU)， tag等等。</p>
<ul>
<li>c-p 打开查找面板</li>
<li>c-d 选择文件查找|路径查找</li>
<li>c-r 开关正则匹配</li>
<li>c-f, c-b 在file查找 ,buffer查找 ,mru查找中切换。</li>
<li>c-j, c-k 在查找结果中上下移动</li>
<li>c-t 在新tab页中打开</li>
<li>c-x,c-v 在新窗口中打开。(x-上下， v-左右)</li>
<li>c-z 标记多个文件，c-o打开这些文件</li>
<li>c-y 新建文件如果目录不存在，则创建</li>
</ul>
<h3 id="easy-motion"> easy-motion</h3>
<p>easymotion/vim-easymotion</p>
<ul>
<li>\w 向后跳转到单词头</li>
<li>\b 向前跳转到单词头</li>
<li>\s 双向跳转到指定字符</li>
<li>\j 向下跳转到行首</li>
<li>\k 向上跳转到行首</li>
</ul>
<h3 id="vim-bookmark"> vim-bookmark</h3>
<table>
<thead>
<tr>
<th>Action</th>
<th>Shortcut</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>在当前行添加/删除书签</td>
<td>mm</td>
<td>:BookmarkToggle</td>
</tr>
<tr>
<td>Add/edit/remove当前行的书签名</td>
<td>mi</td>
<td>:BookmarkAnnotate name</td>
</tr>
<tr>
<td>显示所有书签</td>
<td>ma</td>
<td>:BookmarkShowAll</td>
</tr>
<tr>
<td>清除当前buffer的所有书签</td>
<td>mc</td>
<td>:BookmarkClear</td>
</tr>
<tr>
<td>清除所有buffer的所有书签</td>
<td>mx</td>
<td>:BookmarkClearAll</td>
</tr>
<tr>
<td>下一个书签</td>
<td>mn</td>
<td>:BookmarkNext</td>
</tr>
<tr>
<td>上一个书签</td>
<td>mp</td>
<td>:BookmarkPrev</td>
</tr>
<tr>
<td>将当前行的书签向上移动n行</td>
<td>nmkk</td>
<td>:BookmarkMoveUp n</td>
</tr>
<tr>
<td>将当前行的书签向下移动n行</td>
<td>nmjj</td>
<td>:BookmarkMoveDown n</td>
</tr>
<tr>
<td>将当前行的书签移动到第n行</td>
<td>nmg</td>
<td>:BookmarkMoveToLine n</td>
</tr>
<tr>
<td>将书签保存到文件中</td>
<td></td>
<td>:BookmarkSave FILE</td>
</tr>
<tr>
<td>从文件中加载书签</td>
<td></td>
<td>:BookmarkLoad FILE</td>
</tr>
</tbody>
</table>
<h3 id="snippet"> snippet</h3>
<ul>
<li>:UltiSnippetsEdit 编辑当前类型文件的snippets</li>
<li>格式</li>
</ul>
<h2 id="vim-script"> vim-script</h2>
<h3 id="语法"> 语法</h3>
<ul>
<li>set 为Vim内部选项赋值</li>
<li>let 对非Vim内部变量</li>
<li>没有bool类型，1为真，0为假</li>
<li>作用域前缀
<ul>
<li>g: 全局作用域。默认</li>
<li>v: Vim所定义的全局作用域</li>
<li>I: 局部作用域</li>
<li>b,w,t: 当前缓冲区，窗口，标签页</li>
<li>s: :source'd执行的Vim脚本中的局部文件作用域</li>
<li>a: 函数的参数</li>
</ul>
</li>
<li>echom 输出，可以用:message查看输出历史</li>
<li>条件表达式
<ul>
<li>if expr</li>
<li>else if expr</li>
<li>else</li>
<li>endif</li>
<li>(expr ? true : false)</li>
</ul>
</li>
<li>文本比较
<ul>
<li>== 文本比较</li>
<li>=~ 正则匹配</li>
<li>!~ 正则不匹配</li>
<li>后缀?|#表示忽略|考虑大小写</li>
<li>无后缀是否忽略取决于Vim的内置选项ignorecase</li>
</ul>
</li>
<li>函数调用：如果是单独调用，必须在前面加个call。在表达式中，则不必。</li>
<li>list：类似python的list。add,insert,remove,sort,extend,index,empty,len,count</li>
<li>dict: 代码跨多行时，要在行尾加<code>\</code>. :help dict</li>
<li>循环
<ul>
<li>for expr in exprs</li>
<li>endfor</li>
<li>while expr</li>
<li>endwhile</li>
</ul>
</li>
<li>函数
<ul>
<li>function! Funcname() 函数名首字母必须大写。!防止多次定义</li>
<li>endfunction</li>
</ul>
</li>
<li>和Vim交互
<ul>
<li>execute 将参数解析为Vim命令并执行</li>
<li>normal 执行按键序列</li>
<li>silent 隐藏其他命令的输出</li>
<li>has 检查Vim是否支持某个功能 :help feature-list</li>
<li>confirm</li>
<li>input</li>
</ul>
</li>
<li>:help eval</li>
</ul>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/vim-keyboard.png" type="image/png"/>
    </item>
    <item>
      <title>导言</title>
      <link>https://kigane.github.io/note/cv/</link>
      <guid>https://kigane.github.io/note/cv/</guid>
      <source url="https://kigane.github.io/rss.xml">导言</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="计算机视觉面临的挑战"> 计算机视觉面临的挑战</h2>
<ul>
<li>人眼接受的视觉数据极其多，且大部分是冗余的</li>
<li>视皮层会压缩信息，大脑高级中枢只处理一部分抽象的数据，但仍比其他信息多至少两个数量级</li>
<li>大脑有约100亿个细胞，每个细胞有大量突触，处理能力非常强</li>
<li>人类可以通过积极的使用和训练对眼脑系统进行动态&quot;编程&quot;</li>
</ul>
<hr>
<ul>
<li>训练集不充分，无法代表实际情况</li>
<li>要提供充分的训练集，存储是个问题，参数增加导致的组合爆炸也是问题</li>
</ul>
<hr>
<ul>
<li>图像处理
<ul>
<li>将图像转换为包含相同比特数据的更容易处理的形式</li>
<li>分类,抽象</li>
</ul>
</li>
</ul>
<h2 id="nms"> NMS</h2>
<p>NMS是大部分深度学习目标检测网络所需要的，大致算法流程为：</p>
<ol>
<li>对所有预测框的置信度降序排序</li>
<li>选出置信度最高的预测框，确认其为正确预测（下次就没有他了，已经被确认了），并计算他与其他预测框的IOU</li>
<li>根据2中计算的IOU去除重叠度高的，IOU&gt;threshold就删除</li>
<li>剩下的预测框返回第1步，直到没有剩下的为止</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>数字图像处理</title>
      <link>https://kigane.github.io/note/cv/dip/</link>
      <guid>https://kigane.github.io/note/cv/dip/</guid>
      <source url="https://kigane.github.io/rss.xml">数字图像处理</source>
      <category>CV</category>
      <pubDate>Sun, 03 Oct 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="绪论"> 绪论</h2>
<h3 id="数字图像"> 数字图像</h3>
<ul>
<li>一个图像定义了一个2D-函数，f(x, y)，其中x, y是空间坐标，函数值为灰度(grey level或intensity)。</li>
<li>图像数字化(digitalization)
<ul>
<li>必须指定像素大小</li>
<li>必须指定灰度范围，即灰阶。</li>
<li>从连续到离散，一定会丢失部分信息</li>
</ul>
</li>
<li>数据特点
<ul>
<li>维数。通常是2和3，有时会更多，如4D图像增加了时间维度。</li>
<li>大。</li>
<li>每个voxel对应物理空间中的一个点</li>
</ul>
</li>
<li>图像描述
<ul>
<li>2D image: f(i, j)</li>
<li>3D image: f(i, j, k)</li>
<li>4D image: f(i, j, k, t)</li>
<li>注意：f, i, j, k, t都是正整数。</li>
</ul>
</li>
<li>数字图像三要素
<ul>
<li>pixel</li>
<li>grey level</li>
<li>coordinates</li>
</ul>
</li>
</ul>
<h3 id="数字图像处理"> 数字图像处理</h3>
<ul>
<li>采样(sampling):测量图像每个像素位置的灰度值</li>
<li>量化(quantization):将测量值用整数表示</li>
<li>对比度(contrast):图像内灰度变化的幅度</li>
<li>解像度(resolution):</li>
<li>采样密度(sampling density):像素间距</li>
<li>放大率(magnification):图像与真实世界的尺度关系(比例尺)</li>
</ul>
<h3 id="图像分类"> 图像分类</h3>
<ul>
<li>二值图像(Binary image)</li>
<li>灰度图像(Gray level image)</li>
<li>彩色图像(Color image)</li>
<li>伪彩图像(False color image)</li>
</ul>
<p>根据传感器分类，有红外，紫外，MRI，超声，微波，X-光片，PET(正电子成像，氧的新陈代谢)，照片...<br>
其他分类方式略。</p>
<h3 id="图像处理流程"> 图像处理流程</h3>
<ul>
<li>Low level:从图像到图像，也称image filtering
<ul>
<li>Enhancement
<ul>
<li>Sharpen</li>
<li>Smooth</li>
<li>...</li>
</ul>
</li>
<li>Interpolate</li>
<li>Reduce Noise</li>
<li>Crop(裁剪)</li>
</ul>
</li>
<li>Intermediate level:从图像到符号表示，也称image segmentation
<ul>
<li>Region/Contour Extraction(ROI, Region of Interest)</li>
<li>Labeling</li>
<li>Grouping</li>
</ul>
</li>
<li>High level:从符号表示(symbolic representation)到功能性描述(functional description)，也称图像理解或模式识别。
<ul>
<li>Recognition</li>
<li>Modeling</li>
</ul>
</li>
</ul>
<h2 id="基本图像操作"> 基本图像操作</h2>
<h3 id="灰度直方图"> 灰度直方图</h3>
<p>图像的灰度直方图是基于灰阶的pixel分布函数。其x坐标代表灰阶，y代表对应灰阶的像素数目。主要缺点是丢失了像素的空间信息。</p>
<ul>
<li>图像的灰度直方图通常是双峰(bimodal)的。</li>
<li>双峰之间的最小灰阶是最优的二值化threshold选择之一。</li>
<li>二值化的threshold可以是固定的(fixed)或适应性的(adaptive)</li>
</ul>
<h3 id="二值化方法"> 二值化方法</h3>
<h4 id="isodata-algorithm"> Isodata Algorithm</h4>
<ul>
<li>选择一个初始threshold值，T<sub>0</sub>(e.g. mean intensity)</li>
<li>用T<sub>0</sub>将图像分成两个部分R<sub>1</sub>,R<sub>2</sub></li>
<li>分别计算两个部分的mean intensity u<sub>1</sub>, u<sub>2</sub></li>
<li>选择新的threshold, T<sub>1</sub>=(u<sub>1</sub>+u<sub>2</sub>)/2</li>
<li>重复，直到threshold不再改变</li>
</ul>
<h4 id="otsu-algorithm"> OTSU Algorithm</h4>
<ul>
<li>t: total</li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.4306em;"></span><span style="margin-right:0.03588em;">ω</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.106em;vertical-align:-1.2777em;"></span><span><span><span><span style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>0</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span style="margin-right:0.13889em;">T</span></span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.13889em;">P</span><span>(</span><span>i</span><span>)</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.13889em;">P</span><span>(</span><span>i</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span><span><span>n</span></span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>i</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>/</span><span style="margin-right:0.10903em;">N</span></span></span></span></li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span>μ</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.106em;vertical-align:-1.2777em;"></span><span><span><span><span style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>0</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span style="margin-right:0.13889em;">T</span></span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>i</span><span style="margin-right:0.13889em;">P</span><span>(</span><span>i</span><span>)</span><span>/</span><span style="margin-right:0.03588em;">ω</span></span></span></span></li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.1111em;vertical-align:-0.247em;"></span><span><span><span style="margin-right:0.03588em;">σ</span></span><span><span><span><span style="height:0.8641em;"><span style="top:-2.453em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>t</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.247em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.106em;vertical-align:-1.2777em;"></span><span><span><span><span style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>0</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span style="margin-right:0.13889em;">T</span></span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span>(</span><span>i</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1.1141em;vertical-align:-0.25em;"></span><span>u</span><span><span>)</span><span><span><span><span style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span></span></span></span></span><span style="margin-right:0.13889em;">P</span><span>(</span><span>i</span><span>)</span></span></span></span></li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.1111em;vertical-align:-0.247em;"></span><span><span><span style="margin-right:0.03785em;">δ</span></span><span><span><span><span style="height:0.8641em;"><span style="top:-2.453em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>b</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.247em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span><span>μ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1.1141em;vertical-align:-0.25em;"></span><span><span>μ</span><span><span><span><span style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>t</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span><span>)</span><span><span><span><span style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span><span>μ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1.1141em;vertical-align:-0.25em;"></span><span><span>μ</span><span><span><span><span style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>t</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span><span>)</span><span><span><span><span style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span>，其中<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span><span>μ</span><span><span><span><span style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>t</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7778em;vertical-align:-0.1944em;"></span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span><span>μ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span><span>μ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 代入可得 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.0972em;vertical-align:-0.2831em;"></span><span><span><span style="margin-right:0.03785em;">δ</span></span><span><span><span><span style="height:0.8141em;"><span style="top:-2.4169em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>b</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>2</span></span></span></span></span><span>​</span></span><span><span style="height:0.2831em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span><span>μ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span><span>μ</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span><span>)</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span style="margin-right:0.03588em;">η</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:2.4229em;vertical-align:-0.9318em;"></span><span><span></span><span><span><span><span style="height:1.4911em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03785em;">δ</span><span><span><span><span style="height:0.7959em;"><span style="top:-2.4542em;margin-left:-0.0379em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>t</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:0.2458em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03785em;">δ</span><span><span><span><span style="height:0.8141em;"><span style="top:-2.4169em;margin-left:-0.0379em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>b</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:0.2831em;"><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.9318em;"><span></span></span></span></span></span><span></span></span></span></span></span></li>
<li>如果有256个灰阶，则计算出256个<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.625em;vertical-align:-0.1944em;"></span><span style="margin-right:0.03588em;">η</span></span></span></span>取最大值</li>
</ul>
<h4 id="entropy-method"> Entropy Method</h4>
<ul>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.08125em;">H</span><span><span><span><span style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>b</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.0582em;vertical-align:-1.2777em;"></span><span>−</span><span style="margin-right:0.1667em;"></span><span><span><span><span style="height:1.7806em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>0</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>t</span></span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span>p</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>i</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span>(</span><span><span>p</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>i</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>)</span><span style="margin-right:1em;"></span><span><span style="margin-right:0.08125em;">H</span><span><span><span><span style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02691em;">w</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.1371em;vertical-align:-1.336em;"></span><span>−</span><span style="margin-right:0.1667em;"></span><span><span><span><span style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>t</span><span>+</span><span>1</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>255</span></span></span></span></span><span>​</span></span><span><span style="height:1.336em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span>p</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>i</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span>lo<span style="margin-right:0.01389em;">g</span></span><span>(</span><span><span>p</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>i</span></span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>)</span></span></span></span></li>
<li>同样计算256个值，选择合适的灰阶t使得<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.08125em;">H</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.08125em;">H</span><span><span><span><span style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>b</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8333em;vertical-align:-0.15em;"></span><span><span style="margin-right:0.08125em;">H</span><span><span><span><span style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02691em;">w</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (b:black，通常是背景色， w:white，通常是前景色)最大化</li>
</ul>
<h4 id="adaptive-threshold-local-threshold"> Adaptive Threshold/Local Threshold</h4>
<ul>
<li>将图像分成一个个小区域，每个区域计算各自的threshold</li>
<li>适合背景不均匀的情况</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>直方图均衡化</title>
      <link>https://kigane.github.io/note/cv/equalize_histogram/</link>
      <guid>https://kigane.github.io/note/cv/equalize_histogram/</guid>
      <source url="https://kigane.github.io/rss.xml">直方图均衡化</source>
      <category>CV</category>
      <pubDate>Sun, 05 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="总览"> 总览</h2>
<ul>
<li>提高全局对比度，在图像灰度集中于某个小区域时效果尤为明显</li>
<li>直方图均衡化将集中在一起的灰度像素值打散到全灰度级上来获得对比度的增强</li>
<li>适合处理曝光不足的照片和骨骼的x-ray图像，热力图，卫星图</li>
<li>是可逆的，需要知道直方图均衡化函数</li>
<li>一个缺点是对背景噪音和有用的信号一视同仁</li>
<li>会使图像产生不真实感</li>
<li>对低color depth的图像，会进一步降低其color depth</li>
<li>改进，在提高对比度的同时不改变灰度的均值和避免细节上的损失
<ul>
<li>adaptive histogram equalization</li>
<li>contrast limiting adaptive histogram equalization (CLAHE)</li>
<li>multipeak histogram equalization (MPHE)</li>
<li>multipurpose beta optimized bihistogram equalization (MBOBHE)</li>
</ul>
</li>
</ul>
<h2 id="具体算法"> 具体算法</h2>
<ul>
<li>计算图像的hist直方图，即每个灰度有多少像素</li>
<li>计算hist的cumsum()，即cdf</li>
<li>用cdf当权值在目标RANGE内进行插值。
<ul>
<li><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>h</span><span>(</span><span style="margin-right:0.03588em;">v</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1.4551em;vertical-align:-0.4451em;"></span><span>ro</span><span>u</span><span>n</span><span>d</span><span>(</span><span><span></span><span><span><span><span style="height:1.01em;"><span style="top:-2.655em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.08125em;">H</span><span>×</span><span style="margin-right:0.13889em;">W</span><span>−</span><span><span><span style="margin-right:0.07778em;">cdf</span></span><span><span><span><span style="height:0.3281em;"><span style="top:-2.357em;margin-right:0.0714em;"><span style="height:2.5em;"></span><span><span><span>min</span></span></span></span></span><span>​</span></span><span><span style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span style="height:3em;"></span><span><span><span><span style="margin-right:0.07778em;">cdf</span></span><span>(</span><span style="margin-right:0.03588em;">v</span><span>)</span><span>−</span><span><span><span style="margin-right:0.07778em;">cdf</span></span><span><span><span><span style="height:0.3281em;"><span style="top:-2.357em;margin-right:0.0714em;"><span style="height:2.5em;"></span><span><span><span>min</span></span></span></span></span><span>​</span></span><span><span style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.4451em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.2222em;"></span><span>×</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>L</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>))</span></span></span></span></li>
<li>cdf<sub>min</sub>代表灰度最低像素的个数</li>
<li>HxW为图像像素总数</li>
<li>L为灰度级，通常为256</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>名词解释</title>
      <link>https://kigane.github.io/note/cv/nouns/</link>
      <guid>https://kigane.github.io/note/cv/nouns/</guid>
      <source url="https://kigane.github.io/rss.xml">名词解释</source>
      <category>CV</category>
      <pubDate>Tue, 07 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目标检测"> 目标检测</h2>
<div><p>Tips</p>
<p>Object Localization is finding where and what a single object exists in an image.
Object Detection is finding where and what multiple objects are in an image.</p>
</div>
<div><p>Tips</p>
<p>Sliding Window: 预定义一个box，在二维的图像上滑动。在每个位置，裁剪图像，缩放为224x224送入CNN。</p>
<ul>
<li>计算量极大(OverFeat方法可以简化一些计算)
<ul>
<li>滑动步长不能大大</li>
<li>需要不同大小的滑动窗口</li>
</ul>
</li>
<li>会产生大量包含物体的bboxes</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Attention is all you need</title>
      <link>https://kigane.github.io/note/cv/transformer/</link>
      <guid>https://kigane.github.io/note/cv/transformer/</guid>
      <source url="https://kigane.github.io/rss.xml">Attention is all you need</source>
      <category>thesis</category>
      <pubDate>Sun, 14 Nov 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="摘要"> 摘要</h2>
<ul>
<li>Transformer，一个新的网络架构，只使用注意力机制(attention mechanism)，完全没用循环和卷积</li>
<li>对于机器翻译任务，性能表现更好，可并行度更高，训练时间大量减少</li>
<li>可以泛化到其它任务上</li>
<li><a href="https://github.com/tensorflow/tensor2tensor" target="_blank" rel="noopener noreferrer">代码实现</a></li>
</ul>
<h2 id="结论"> 结论</h2>
<ul>
<li>Transformer是第一个完全用注意力机制的序列转录模型(sequence transduction model)，它将encoder-decoder架构中最常用的循环层(recurrent layers)替换成multi-headed self-attention。</li>
<li>对于机器翻译任务，确实性能表现更好，训练时间更少</li>
<li>作者认为Transformer不仅可以应用到文本处理上，在图像，语音，视频上应该也可行。让生成不那么时序化也是另一个研究方向。</li>
</ul>
<h2 id="导言"> 导言</h2>
<ul>
<li>循环模型最主要的缺点是难以并行化，训练时间长。因为它要计算序列的隐藏状态h<sub>t</sub>时，必须先计算h<sub>t-1</sub>。</li>
<li>已经有人将attention机制应用于encoder-decoder架构了，但是是和循环模型一起使用的。</li>
<li>我们只用attention机制，效果更好</li>
</ul>
<h2 id="相关工作"> 相关工作</h2>
<ul>
<li>有人试过用CNN来改进RNN，但这样做的缺点是序列相隔比较远的像素产生联系很难，用transformer就很容易了。但CNN有和好处是可以有多个输出通道，所以作者又提出了multi-headed self-attention用来模拟CNN的多输出通道的效果。</li>
<li>self-attention机制不是作者的创新，相关工作已经有了。</li>
<li>作者的创新在于在encoder-decoder架构中只使用self-attention机制。</li>
</ul>
<h2 id="模型架构"> ==模型架构==</h2>
]]></content:encoded>
    </item>
    <item>
      <title>分水岭算法</title>
      <link>https://kigane.github.io/note/cv/watershed/</link>
      <guid>https://kigane.github.io/note/cv/watershed/</guid>
      <source url="https://kigane.github.io/rss.xml">分水岭算法</source>
      <category>CV</category>
      <pubDate>Tue, 07 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="opencv中使用分水岭算法"> opencv中使用分水岭算法</h2>
<h3 id="主要步骤"> 主要步骤</h3>
<ul>
<li>用一种颜色(或强度)标记我们确定为前景或对象的区域</li>
<li>用另一种颜色标记我们确定为背景或非对象的区域</li>
<li>最后用 0 标记我们不确定的区域。</li>
<li>应用分水岭算法。标记将使用我们给出的标签进行更新，对象的边界值将为-1。</li>
</ul>
<h3 id="代码"> 代码</h3>
]]></content:encoded>
    </item>
    <item>
      <title>JS 小知识</title>
      <link>https://kigane.github.io/note/js/</link>
      <guid>https://kigane.github.io/note/js/</guid>
      <source url="https://kigane.github.io/rss.xml">JS 小知识</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="箭头函数"> 箭头函数</h2>
<p>类似 lambda 表达式。</p>
<div><pre><code><span>(</span><span>params</span><span>)</span><span>=></span><span>{</span>
    <span>// body...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>需要注意的是，箭头函数没有 this, 如果在箭头函数内使用了 this，会导致 this 作为变量一直向上级词法作用域查找，直至找到为止。这经常会导致错误。</p>
<h2 id="提升-hoisting"> 提升(Hoisting)</h2>
<p>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。函数声明也一样。类似 C++ 中 static 的工作方式。</p>
<h2 id="in"> in</h2>
<ul>
<li>在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中</li>
<li>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将<code>[[Enumerable]]</code>标记为false的属性）的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的。</li>
</ul>
<h2 id="exports-module-exports"> exports&amp;module.exports</h2>
<p>模块是自包含的功能单元，可以在项目中共享和重复使用。
由于JavaScript最初没有模块的概念，随着时间的推移出现了各种竞争格式。Node.js中使用的是CommonJS格式。其他格式(<a href="https://www.jvandemo.com/a-10-minute-primer-to-javascript-modules-module-formats-module-loaders-and-module-bundlers/" target="_blank" rel="noopener noreferrer">可以参考这里</a>)。</p>
<p>Node.js 内置了许多模块，例如</p>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>const</span> folderPath <span>=</span> <span>'./'</span><span>;</span>

fs<span>.</span><span>readdir</span><span>(</span>folderPath<span>,</span> <span>(</span><span>err<span>,</span> files</span><span>)</span> <span>=></span> <span>{</span>
    files<span>.</span><span>forEach</span><span>(</span><span>file</span> <span>=></span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>file<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>更多<a href="https://www.w3schools.com/nodejs/ref_modules.asp" target="_blank" rel="noopener noreferrer">可以参考这里</a></p>
<h3 id="创建和导出模块"> 创建和导出模块</h3>
<div><pre><code><span>// in ./user.js</span>
<span>const</span> <span>getName</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>'Zrt'</span><span>;</span>
<span>}</span><span>;</span>

exports<span>.</span>getName <span>=</span> getName<span>;</span>

<span>// in ./index.js</span>
<span>const</span> user <span>=</span> <span>require</span><span>(</span><span>'./user'</span><span>)</span><span>;</span> <span>// .js 很显然，可以省略</span>
console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>User: </span><span><span>${</span>user<span>.</span><span>getName</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span> <span>// User: Zrt</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="导出多个方法和值"> 导出多个方法和值</h3>
<div><pre><code><span>// in ./user.js</span>
<span>const</span> <span>getName</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>'Zrt'</span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> <span>getLocation</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>'dzxx'</span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> dateOfBirth <span>=</span> <span>'9.9.1999'</span><span>;</span>

exports<span>.</span>getName <span>=</span> getName<span>;</span>
exports<span>.</span>getLocation <span>=</span> getLocation<span>;</span>
exports<span>.</span>dob <span>=</span> dateOfBirth<span>;</span>

<span>// in ./index.js</span>
<span>const</span> user <span>=</span> <span>require</span><span>(</span><span>'./user'</span><span>)</span><span>;</span> <span>// .js 很显然，可以省略</span>
console<span>.</span><span>log</span><span>(</span>
  <span><span>`</span><span><span>${</span>user<span>.</span><span>getName</span><span>(</span><span>)</span><span>}</span></span><span> lives in </span><span><span>${</span>user<span>.</span><span>getLocation</span><span>(</span><span>)</span><span>}</span></span><span> and was born on </span><span><span>${</span>user<span>.</span>dob<span>}</span></span><span>.</span><span>`</span></span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="语法变体"> 语法变体</h3>
<div><pre><code><span>// ./user.js</span>
exports<span>.</span><span>getName</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>'Jim'</span><span>;</span>
<span>}</span><span>;</span>

exports<span>.</span><span>getLocation</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>'Munich'</span><span>;</span>
<span>}</span><span>;</span>

exports<span>.</span>dob <span>=</span> <span>'12.01.1982'</span><span>;</span>

<span>// ./index.js</span>
<span>// ES6 语法 Destructuring Assignment</span>
<span>const</span> <span>{</span> getName<span>,</span> dob <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./user'</span><span>)</span><span>;</span> 
console<span>.</span><span>log</span><span>(</span>
  <span><span>`</span><span><span>${</span><span>getName</span><span>(</span><span>)</span><span>}</span></span><span> was born on </span><span><span>${</span>dob<span>}</span></span><span>.</span><span>`</span></span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="导出默认值"> 导出默认值</h3>
<p>如果一个模块只想导出一个东西，module.exports更常用。</p>
<div><pre><code><span>// ./user.js</span>
<span>class</span> <span>User</span> <span>{</span>
  <span>constructor</span><span>(</span><span>name<span>,</span> age<span>,</span> email</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>this</span><span>.</span>email <span>=</span> email<span>;</span>
  <span>}</span>

  <span>getUserStats</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>
      Name: </span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span>
      Age: </span><span><span>${</span><span>this</span><span>.</span>age<span>}</span></span><span>
      Email: </span><span><span>${</span><span>this</span><span>.</span>email<span>}</span></span><span>
    </span><span>`</span></span><span>;</span>
  <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> User<span>;</span>

<span>// ./index.js</span>
<span>const</span> User <span>=</span> <span>require</span><span>(</span><span>'./user'</span><span>)</span><span>;</span>
<span>const</span> jim <span>=</span> <span>new</span> <span>User</span><span>(</span><span>'Jim'</span><span>,</span> <span>37</span><span>,</span> <span>'jim@example.com'</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>jim<span>.</span><span>getUserStats</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="console-log-module"> console.log(module)</h3>
<p>console.log(module);结果可以看到，exports属性。</p>
<div><pre><code>Module <span>{</span>
  id<span>:</span> <span>'.'</span><span>,</span>
  path<span>:</span> <span>'f:\\workspace\\MyBlogs\\docs\\guide'</span><span>,</span>
  exports<span>:</span> <span>{</span><span>}</span><span>,</span>
  parent<span>:</span> <span>null</span><span>,</span>
  filename<span>:</span> <span>'f:\\workspace\\MyBlogs\\docs\\guide\\index.js'</span><span>,</span>
  loaded<span>:</span> <span>false</span><span>,</span>
  children<span>:</span> <span>[</span>
    Module <span>{</span>
      id<span>:</span> <span>'f:\\workspace\\MyBlogs\\docs\\guide\\test.js'</span><span>,</span>
      path<span>:</span> <span>'f:\\workspace\\MyBlogs\\docs\\guide'</span><span>,</span>
      exports<span>:</span> <span>[</span>Object<span>]</span><span>,</span>
      parent<span>:</span> <span>[</span>Circular<span>]</span><span>,</span>
      filename<span>:</span> <span>'f:\\workspace\\MyBlogs\\docs\\guide\\test.js'</span><span>,</span>
      loaded<span>:</span> <span>true</span><span>,</span>
      children<span>:</span> <span>[</span><span>]</span><span>,</span>
      paths<span>:</span> <span>[</span>Array<span>]</span>
    <span>}</span>
  <span>]</span><span>,</span>
  paths<span>:</span> <span>[</span>
    <span>'f:\\workspace\\MyBlogs\\docs\\guide\\node_modules'</span><span>,</span>
    <span>'f:\\workspace\\MyBlogs\\docs\\node_modules'</span><span>,</span>
    <span>'f:\\workspace\\MyBlogs\\node_modules'</span><span>,</span>
    <span>'f:\\workspace\\node_modules'</span><span>,</span>
    <span>'f:\\node_modules'</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="三个点"> 三个点(<code>...</code>)</h2>
<p>js中的<code>...</code>有两种意思。<br>
在函数参数列表中--剩余参数</p>
<div><pre><code><span>function</span> <span>myFunc</span><span>(</span><span>x<span>,</span> y<span>,</span> <span>...</span>args</span><span>)</span>
<span>{</span>
  console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>y<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>args<span>)</span><span>;</span>
<span>}</span>

<span>myFunc</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>)</span><span>;</span> <span>// output: 1, 2, [3, 4, 5, 6]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>spread operator -- 展开操作符<br>
展开可迭代对象的元素</p>
<div><pre><code><span>const</span> featured <span>=</span> <span>[</span><span>'Deep Dish'</span><span>,</span> <span>'Pepperoni'</span><span>,</span> <span>'Hawaiian'</span><span>]</span><span>;</span>
<span>const</span> specialty <span>=</span> <span>[</span><span>'Meatzza'</span><span>,</span> <span>'Spicy Mama'</span><span>,</span> <span>'Margherita'</span><span>]</span><span>;</span>

<span>const</span> pizzas <span>=</span> <span>[</span><span>...</span>featured<span>,</span> <span>'veg pizza'</span><span>,</span> <span>...</span>specialty<span>]</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>pizzas<span>)</span><span>;</span> <span>// 'Deep Dish', 'Pepperoni', 'Hawaiian', 'veg pizza', 'Meatzza', 'Spicy Mama', 'Margherita'</span>

<span>var</span> obj1 <span>=</span> <span>{</span> foo<span>:</span> <span>'bar'</span><span>,</span> x<span>:</span> <span>42</span> <span>}</span><span>;</span>
<span>var</span> obj2 <span>=</span> <span>{</span> foo<span>:</span> <span>'baz'</span><span>,</span> y<span>:</span> <span>13</span> <span>}</span><span>;</span>

<span>var</span> clonedObj <span>=</span> <span>{</span> <span>...</span>obj1 <span>}</span><span>;</span>
<span>// Object { foo: "bar", x: 42 }</span>

<span>var</span> mergedObj <span>=</span> <span>{</span> <span>...</span>obj1<span>,</span> <span>...</span>obj2 <span>}</span><span>;</span>
<span>// Object { foo: "baz", x: 42, y: 13 }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="caller-callee"> caller &amp; callee</h2>
<ul>
<li>JS中函数是对象，函数名是指针，函数参数用arguments数组保存。</li>
<li>arguments.callee是一个指向拥有该arguments对象的函数的指针。通常用于解耦函数和函数名。</li>
<li>functionName.caller中保存着调用当前函数的函数的引用，如果是在全局作用域中调用，则为null。</li>
</ul>
<h2 id="apply-call-bind-this"> apply &amp; call &amp; bind &amp; this</h2>
<ul>
<li>this引用的是函数执行时的环境对象(全局对象window，或某个函数对象)。使用var声明的变量会被添加到最近的环境中。不加var声明的变量会被添加到全局环境中。</li>
<li>apply和call可以用于传递参数，可以固定部分参数。但真正强大的地方是能通<strong>第一个参数</strong>修改this对象绑定，扩充函数的作用域，这种扩充作用域的方式，不需要对象和方法有任何耦合关系。</li>
<li>bind会创建一个函数实例，其this值会被绑定到传给bind的参数。</li>
</ul>
<div><pre><code><span>// 传参数</span>
<span>function</span> <span>sum</span><span>(</span><span>num1<span>,</span> num2</span><span>)</span> <span>{</span>
    <span>return</span> num1 <span>+</span> num2<span>;</span>
<span>}</span>

<span>function</span> <span>callSum1</span><span>(</span><span>num1<span>,</span> num2</span><span>)</span> <span>{</span>
    <span>return</span> <span>sum</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span>
<span>}</span>

<span>function</span> <span>callSum2</span><span>(</span><span>num1</span><span>)</span> <span>{</span>
    <span>return</span> <span>sum</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> <span>[</span>num1<span>,</span> <span>5</span><span>]</span><span>)</span>
<span>}</span>

<span>function</span> <span>callSum3</span><span>(</span><span>num1<span>,</span> num2</span><span>)</span> <span>{</span>
    <span>return</span> <span>sum</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> num1<span>,</span> num2<span>)</span>
<span>}</span>

<span>var</span> bindSum <span>=</span> <span>sum</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>修改绑定</p>
<div><pre><code><span>var</span> o <span>=</span> <span>{</span> color<span>:</span> <span>'blue'</span> <span>}</span>
<span>var</span> color <span>=</span> <span>'red'</span>

<span>function</span> <span>sayColor</span><span>(</span><span>)</span><span>{</span>
  <span>alert</span><span>(</span><span>this</span><span>.</span>color<span>)</span> <span>// red</span>
<span>}</span>

<span>var</span> objColor <span>=</span> <span>sayColor</span><span>.</span><span>bind</span><span>(</span>o<span>)</span>
<span>objColor</span><span>(</span><span>)</span> <span>// blue</span>

<span>sayColor</span><span>.</span><span>apply</span><span>(</span>o<span>)</span> <span>// blue</span>
<span>sayColor</span><span>.</span><span>call</span><span>(</span>o<span>)</span> <span>// blue</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="正则"> 正则</h2>
<p>语法如下</p>
<div><pre><code><span>var</span> text <span>=</span> <span>"mom and dad and baby"</span>
<span>var</span> pattern <span>=</span> <span><span>/</span><span>mom( and dad( and baby)?)?</span><span>/</span><span>gi</span></span>  <span>// /pattern/flags。产生一个RegEx对象。</span>
<span>var</span> matches <span>=</span> pattern<span>.</span><span>exec</span><span>(</span>text<span>)</span> <span>// pattern.exec(text) === text.match(pattern)</span>
console<span>.</span><span>log</span><span>(</span>matches<span>.</span>index<span>)</span> <span>// 匹配项位置：0</span>
console<span>.</span><span>log</span><span>(</span>matches<span>.</span>input<span>)</span> <span>// 输入字符串：mom and dad and baby</span>
console<span>.</span><span>log</span><span>(</span>matches<span>[</span><span>0</span><span>]</span><span>)</span> <span>// 模式匹配到的子串</span>
console<span>.</span><span>log</span><span>(</span>matches<span>[</span><span>1</span><span>]</span><span>)</span> <span>// 捕获组1 (捕获组，即正则中括号内的部分，如果没匹配上，则为undefined)</span>
console<span>.</span><span>log</span><span>(</span>matches<span>[</span><span>2</span><span>]</span><span>)</span> <span>// 捕获组2 </span>
<span>// 如果没有捕获组，则matches只有第一项</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="json"> JSON</h2>
<ul>
<li>JSON.stringify(obj, filter, indentOption):把JavaScript对象序列化为JSON字符串。只有数据，不包括方法。
<ul>
<li>filter可以是数组，包含要序列化的属性，不再其内的属性序列化时被忽略。</li>
<li>filter也可以是函数<code>function(key, value) {}</code>，将在每个键值对上调用。通常会用一个switch语句来分别决定如何处理不同的属性。函数的返回值为序列化时使用的value值。</li>
<li>indentOption指定json文件的缩进格式(数字表示以几个空格为缩进)。</li>
</ul>
</li>
<li>JSON.parse(jsonText, filter):把JSON字符串解析为原生JavaScript值。</li>
</ul>
<p>假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下</p>
<ol>
<li>如果对象存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，返回对象本身。</li>
<li>如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值第(1)步返回的值。</li>
<li>对第(2)步返回的每个值进行相应的序列化。</li>
<li>如果提供了第三个参数，执行相应的格式化。</li>
</ol>
<h2 id="proxy对象"> Proxy对象</h2>
<p>可以创建另一个对象的代理。拦截并重新定义对象的基础操作，如读写。使用方法和对象一样。
两个参数</p>
<ul>
<li>target: 目标对象</li>
<li>handler: 一个对象，定义哪些操作会被拦截，如何重定义被拦截的操作。</li>
</ul>
<p>PS:Reflect对象可用于指定对象原来的操作。</p>
<h3 id="基础示例1"> 基础示例1</h3>
<div><pre><code><span>const</span> target <span>=</span> <span>{</span>
  message1<span>:</span> <span>"hello"</span><span>,</span>
  message2<span>:</span> <span>"everyone"</span>
<span>}</span><span>;</span>

<span>const</span> handler <span>=</span> <span>{</span>
  <span>get</span><span>:</span> <span>function</span><span>(</span><span>target<span>,</span> prop<span>,</span> receiver</span><span>)</span> <span>{</span>
    <span>// prop：正要get的属性， receiver：代理对象或继承自代理的对象</span>
    <span>return</span> <span>"world"</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span> <span>// 这样设置handler之后，无论获取什么属性，都只会返回"world"</span>

<span>const</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handler<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="基础示例2"> 基础示例2</h3>
<div><pre><code><span>const</span> target <span>=</span> <span>{</span>
  message1<span>:</span> <span>"hello"</span><span>,</span>
  message2<span>:</span> <span>"everyone"</span>
<span>}</span><span>;</span>

<span>const</span> handler <span>=</span> <span>{</span>
  <span>get</span><span>:</span> <span>function</span> <span>(</span><span>target<span>,</span> prop<span>,</span> receiver</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prop <span>===</span> <span>"message2"</span><span>)</span> <span>{</span> <span>// 只特殊处理message2属性</span>
      <span>return</span> <span>"world"</span><span>;</span>
    <span>}</span>
    <span>return</span> Reflect<span>.</span><span>get</span><span>(</span><span>...</span>arguments<span>)</span><span>;</span> <span>// 其他属性按原对象来</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>

<span>const</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handler<span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>proxy<span>.</span>message1<span>)</span><span>;</span> <span>// hello</span>
console<span>.</span><span>log</span><span>(</span>proxy<span>.</span>message2<span>)</span><span>;</span> <span>// world</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="数组示例"> 数组示例</h3>
<div><pre><code><span>let</span> products <span>=</span> <span>new</span> <span>Proxy</span><span>(</span><span>[</span>
  <span>{</span> name<span>:</span> <span>'Firefox'</span><span>,</span> type<span>:</span> <span>'browser'</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'SeaMonkey'</span><span>,</span> type<span>:</span> <span>'browser'</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'Thunderbird'</span><span>,</span> type<span>:</span> <span>'mailer'</span> <span>}</span>
<span>]</span><span>,</span>
<span>{</span>
  <span>get</span><span>:</span> <span>function</span><span>(</span><span>obj<span>,</span> prop</span><span>)</span> <span>{</span>
    <span>// The default behavior to return the value; prop is usually an integer</span>
    <span>if</span> <span>(</span>prop <span>in</span> obj<span>)</span> <span>{</span>
      <span>return</span> obj<span>[</span>prop<span>]</span><span>;</span> <span>// products[0]</span>
    <span>}</span>

    <span>// Get the number of products; an alias of products.length</span>
    <span>if</span> <span>(</span>prop <span>===</span> <span>'number'</span><span>)</span> <span>{</span>
      <span>return</span> obj<span>.</span>length<span>;</span> <span>// products.number</span>
    <span>}</span>

    <span>let</span> result<span>,</span> types <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>for</span> <span>(</span><span>let</span> product <span>of</span> obj<span>)</span> <span>{</span> <span>// products[name]</span>
      <span>if</span> <span>(</span>product<span>.</span>name <span>===</span> prop<span>)</span> <span>{</span>
        result <span>=</span> product<span>;</span>
      <span>}</span>
      <span>if</span> <span>(</span>types<span>[</span>product<span>.</span>type<span>]</span><span>)</span> <span>{</span> <span>// 根据type分类</span>
        types<span>[</span>product<span>.</span>type<span>]</span><span>.</span><span>push</span><span>(</span>product<span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        types<span>[</span>product<span>.</span>type<span>]</span> <span>=</span> <span>[</span>product<span>]</span><span>;</span>
      <span>}</span>
    <span>}</span>

    <span>// Get a product by name</span>
    <span>if</span> <span>(</span>result<span>)</span> <span>{</span>
      <span>return</span> result<span>;</span>
    <span>}</span>

    <span>// Get products by type</span>
    <span>if</span> <span>(</span>prop <span>in</span> types<span>)</span> <span>{</span>
      <span>return</span> types<span>[</span>prop<span>]</span><span>;</span>
    <span>}</span>

    <span>// Get product types</span>
    <span>if</span> <span>(</span>prop <span>===</span> <span>'types'</span><span>)</span> <span>{</span>
      <span>return</span> Object<span>.</span><span>keys</span><span>(</span>types<span>)</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>undefined</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>products<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>          <span>// { name: 'Firefox', type: 'browser' }</span>
console<span>.</span><span>log</span><span>(</span>products<span>.</span>number<span>)</span><span>;</span>      <span>// 3</span>
console<span>.</span><span>log</span><span>(</span>products<span>[</span><span>'Firefox'</span><span>]</span><span>)</span><span>;</span>  <span>// { name: 'Firefox', type: 'browser' }</span>
console<span>.</span><span>log</span><span>(</span>products<span>[</span><span>'Chrome'</span><span>]</span><span>)</span><span>;</span>   <span>// undefined</span>
console<span>.</span><span>log</span><span>(</span>products<span>.</span>browser<span>)</span><span>;</span>     <span>// [{ name: 'Firefox', type: 'browser' }, { name: 'SeaMonkey', type: 'browser' }]</span>
console<span>.</span><span>log</span><span>(</span>products<span>.</span>types<span>)</span><span>;</span>       <span>// ['browser', 'mailer']</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CSS 高级话题</title>
      <link>https://kigane.github.io/note/js/css-advance/</link>
      <guid>https://kigane.github.io/note/js/css-advance/</guid>
      <source url="https://kigane.github.io/rss.xml">CSS 高级话题</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="背景-阴影和混合模式"> 背景，阴影和混合模式</h2>
<p>backgrounp属性是以下8个属性的简写</p>
<ul>
<li>background-image——指定一个文件或者生成的颜色渐变作为背景图片。
<ul>
<li>可以是一个图片url路径，如url(bg.png)</li>
<li>也可以是一个渐变函数，如linear-gradient(to-right, white, blue)</li>
</ul>
</li>
<li>background-position——设置背景图片的初始位置。</li>
<li>background-size——指定元素内背景图片的渲染尺寸。</li>
<li>background-repeat——决定在需要填充整个元素时，是否平铺图片。</li>
<li>background-origin——决定背景相对于元素的边框盒、内边距框盒(初始值)或内容盒子来定位。</li>
<li>background-clip——指定背景是否应该填充边框盒(初始值)、内边距框盒或内容盒子。</li>
<li>background-attachment——指定背景图片是随着元素上下滚动(初始值)，还是固定在视口区域。注意，使用fixed值会对页面性能产生负面影响。</li>
<li>background-color——指定纯色背景，渲染到背景图片下方。</li>
</ul>
<h3 id="渐变"> 渐变</h3>
<h4 id="linear-gradient"> linear-gradient</h4>
<p>linear-gradient函数使用三个参数来定义行为：角度、起始颜色和终止颜色。例如角度值是to right，意思是渐变从元素的左侧开始(起始颜色)，平滑过渡到右侧(终止颜色)。</p>
<hr>
<p>指定渐变的角度</p>
<ul>
<li>to right，to top，to bottom，to bottomright等</li>
<li>使用更确切的单位，更精确地控制角度。值0deg代表垂直向上，更大的值会沿着顺时针变化
<ul>
<li>deg——角度</li>
<li>rad——弧度</li>
<li>turn——代表环绕圆周的圈数。可以使用小数来表示不足一圈，比如0.25turn相当于90deg。</li>
<li>grad——百分度(gradian)。一个完整的圆是400grad,100grad相当于90deg。</li>
</ul>
</li>
</ul>
<hr>
<p>指定渐变的颜色节点</p>
<ul>
<li>一个渐变可以接受任意数量的颜色节点，节点之间通过逗号分隔。渐变会自动均匀地平铺这些颜色节点。也可以在渐变函数中为每个颜色节点明确指定位置。例如linear-gradient(90deg, red 0%, white 50%, blue 100%)</li>
<li>条纹效果：linear-gradient(90deg, red 40%, white 40%, white 60%, blue 60%)。如果在同一个位置设置两个颜色节点，那么渐变会直接从一个颜色变换到另一个，而不是平滑过渡。因为第一个颜色节点是红色，在40%的位置，所以渐变从左侧边缘一直到40%是纯红色，最后一个颜色节点是蓝色，也是在60%的位置，这样就会直接变换成蓝色，然后一直到右侧边缘是蓝色。</li>
<li>repeating-linear-gradient(-45deg, #57b, #57b 10px, #148 10px, #148 20px)。条纹进度条。</li>
</ul>
<h4 id="radial-gradient"> radial-gradient</h4>
<p>另一类渐变是径向渐变。线性渐变是从元素的一端开始，沿着直线过渡到另一端，而径向渐变不同，默认情况下，渐变在元素中是从中心开始，平滑过渡到边缘。渐变整体呈椭圆形，跟随元素大小进行变化。</p>
<p>跟线性渐变一样，径向渐变同样支持颜色节点。你可以提供多个节点，使用百分比或者长度单位指定节点位置。你也可以把径向渐变设置为圆形而非椭圆，甚至可以指定渐变中心点的位置。repeating-radial-gradient()函数可以重复生成图样，形成同心圆环。</p>
<p><img src="/assets/img/radial-gradient.png" alt="radial-gradient" /></p>
<h3 id="阴影"> 阴影</h3>
<p>有两个属性可以创建阴影，box-shadow可以为元素盒子生成阴影，text-shadow可以为渲染后的文字生成阴影。</p>
<p>box-shadow: x y blur-radius expand-radius shodow-color</p>
<ul>
<li>x 水平偏移</li>
<li>y 垂直偏移</li>
<li>blur-radius 用来控制阴影边缘模糊区域的大小，可以为阴影生成一个更柔和、有点透明的边缘。</li>
<li>expand-radius 用来控制阴影的大小，设置为正值可以使阴影全方位变大，设为负值则会变小。</li>
<li>shodow-color 阴影颜色</li>
<li>inset 关键字，让阴影出现在元素内部</li>
<li>可以同时设置多个阴影，用逗号分隔即可</li>
<li>文本阴影的语法也基本上完全一样：水平偏移量、垂直偏移量、模糊半径(可选)和颜色。但文本阴影不支持inset关键字和扩展半径值。</li>
</ul>
<div><pre><code><span>.button:active</span> <span>{</span>
    <span>box-shadow</span><span>:</span> inset 0 0 0.5em #124<span>,</span> inset 0 0.5em 1em <span>rgba</span><span>(</span>0<span>,</span>0<span>,</span>0<span>,</span>0.4<span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="混合模式"> 混合模式</h3>
<p>大部分情况下，不论是使用真正的图片还是渐变，元素一般只会使用一张背景图片。但某些情况下你可能想要使用两张或者更多的背景图片，CSS是支持这么做的。使用多个背景图片时，列表中排在前面的图片会渲染到排序靠后的图片上面。一般是希望第二张图片也可以透视显示。这时就可以使用混合模式(blend mode)。<br>
<img src="/assets/img/blend-mode.png" alt="blend" /></p>
<div><pre><code><span><span><span>&lt;</span>!doctype</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>blend<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.blend</span> <span>{</span>
    <span>min-height</span><span>:</span> 400px<span>;</span>
    <span>background-image</span><span>:</span> <span><span>url</span><span>(</span>images/bear.jpg<span>)</span></span><span>,</span> <span><span>url</span><span>(</span>images/bear.jpg<span>)</span></span><span>;</span>
    <span>background-size</span><span>:</span> cover<span>;</span>
    <span>background-repeat</span><span>:</span> no-repeat<span>;</span>
    <span>background-position</span><span>:</span> -30vw<span>,</span> 30vw<span>;</span>
    <span>background-blend-mode</span><span>:</span> multiply<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="对比-颜色和间距"> 对比，颜色和间距</h2>
<h3 id="对比"> 对比</h3>
<p>对比是设计中的一种手段，通过突出某物来达到吸引注意力的目的。我们的眼睛和思维天生对模式比较敏感，一旦某种东西破坏了模式的整体效果，我们就自然而然地注意到了它。<br>
若要起到对比的效果，页面必须先建立模式，就如同必须先有了规矩才能打破规矩。<br>
推进样式代码复用，就可以确保网站中使用一致的模式。建立统一的模式，然后打破模式，突出网页上最重要的部分，这是专业设计师的一个核心思路。<br>
CTA，即Call To Action的缩写，是一种针对核心元素的营销手段，希望引导用户使用。</p>
<h3 id="颜色"> 颜色</h3>
<p>调色板：一般会有一种主色，其他颜色基于主色。其他颜色一般是同一色系不同明暗度的颜色，还有一些补充颜色。大部分调色板也会有黑色和白色，以及少量的灰色。因为这些颜色会在CSS中多次重复出现，所以将它们指定为变量可以节省很多时间</p>
<p>颜色表示法：</p>
<ul>
<li>十六进制表示法：#fffffff,#000</li>
<li>rgb(), rgba()：描述红、绿、蓝彩色值的颜色表示法，使用十进制而非十六进制。取值范围为0-255。</li>
<li>hsl(), hsla()：是一种更适合人类读取的颜色表示法。需要3个参数。
<ul>
<li>第一个参数表示色相，是一个0~359的整数值。这代表色相环上的360度，从红色(0)、黄色(60)、绿色(120)、青色(180)、蓝色(240)、洋红色(300)依次过渡，最后回到红色。</li>
<li>第二个参数表示饱和度，是一个代表色彩强度的百分数，100%的时候颜色最鲜艳，0%就意味着没有彩色，只是一片灰色。</li>
<li>第三个参数表示明度，也是百分数，代表颜色有多亮(或者多暗)。大部分鲜艳的颜色是使用50%的明度值。明度值设置得越高，颜色越浅，100%就是纯白色；设置得越低，颜色越暗，0%就是黑色。</li>
</ul>
</li>
</ul>
<hr>
<p>为某种颜色寻找一个搭配的颜色，最简单的方式是找到它的补色(complement)。补色位于色相环的对侧位置，蓝色的补色是黄色；绿色的补色是紫色；红色的补色是青色。使用HSL颜色值时，计算补色非常简单，为色相值加上或者减去180即可。</p>
<p>检查背景和文本的对比度是否符合要求。<a href="https://contrast-ratio.com/" target="_blank" rel="noopener noreferrer">CSS colorcontrast checker: contrast-ratio</a></p>
<h3 id="间距"> 间距</h3>
<p>这部分工作里的大多数内容可以简单归结为正确设置元素的外边距。一般从最容易的地方开始，哪怕后面可能需要再做一些调整。<br>
我们需要思考两件事情，一个是是否需要使用相对单位，另一个是行高如何影响垂直间距。</p>
<p>使用绝对单位会比较容易，但是使用相对单位会有很多好处，不论em还是rem(更有弹性，响应式)。</p>
<p>在盒模型中，元素的内容盒子为内边距所环绕，然后是边框，最后是外边距。但是对于段落和标题这样的元素，内容盒子并不是只有显示出来的文字区域，元素的行高决定了内容盒子最终的高度，这要超出字符的顶部和底部。
<img src="/assets/img/line-height.png" alt="行高" /><br>
网页里的行高设为1.4。只有一行文字的元素，内容盒子的高度就是1.4em，文字在内部垂直居中。字号是16px，内容盒子的最终高度就是22.4px。额外的6.4px平均分配到文字的上方和下方。</p>
<p>如果为行内元素添加内边距，元素本身会变高，却不会增加文本行的高度。文本行的高度只由行高来决定。要解决这个问题，就需要增加每项的行高。如果一个元素是弹性子元素（或者行内块级元素），为了容纳它，其所在的行会随之增高。</p>
<p><strong>牢记行高可以影响垂直间距</strong>。</p>
<h2 id="排版"> 排版</h2>
<h3 id="web字体"> Web字体</h3>
<p>通过在线服务使用Web字体是最简单也最普遍的方式。谷歌字体有很多高质量并且开源的字体(还免费)，建议使用。<br>
选中字体后，复制link标签并添加到页面的head里，这样就为页面添加了一个包含字体描述的样式表。谷歌通过样式表为页面配置好了Web字体需要的设置，然后就可以在自己的样式表中随意使用Web字体了。需要使用font-family属性来指定字体。</p>
<div><p>关于serif</p>
<p>Serif——字母笔画末端的小线条或者“爪状”装饰。包含serif的字体就被称为serif字体（例如Times New Roman）。如果没有serif，那就是sans-serif字体（例如Helvetica）。</p>
</div>
<div><p>字型和字体</p>
<p>字型（typeface）和字体（font）这两个术语经常被混为一谈。字型通常是指字体（比如Roboto）的整个家族，一般由同一个设计师创造。一种字型可能会存在多种变体和字重（比如细体、粗体、斜体、压缩，等等），这些变体的每一种可称之为一种字体（font）。</p>
</div>
<h3 id="调整字距"> 调整字距</h3>
<p>line-height和letter-spacing，这两个属性可以控制文本行之间的距离（垂直方向）和字符之间的距离（水平方向）。</p>
<ul>
<li>line-height属性的初始值是关键字normal，大约等于1.2，但是在大部分情况下，这个值太小了。对于正文主体来说，介于1.4和1.6之间的值比较理想。</li>
<li>letter-spacing通常从0.01em开始测试，直到你满意为止。</li>
</ul>
<div><p>Tips</p>
<p>文字行越长，行高应该设置得越大。这样读者的眼睛扫到下一行的时候才更容易，不会注意力分散。理想情况下，每行文字的长度应该控制在45～75个字符，一般认为这样的长度最利于阅读。</p>
</div>
<p>在设计领域，文本行之间的距离称为行距（leading，与bedding有点谐音），来源于印刷版每行文字之间添加的一条条的引导线（lead）。字符之间的距离称之为字距（tracking）。行高一般使用“点”作单位来描述，比如18pt，代表的是一行文字的高度加上它与下一行文字之间的距离。这实际上与CSS的line-height一样。你必须首先把它转化为跟字体一样使用像素单位，然后再计算出无单位数字。把pt值乘以1.333，就可以把pt转化为px（因为每英寸是96px，并且每英寸等于72pt, 96/72=1.333），即18pt×1.333=24px。然后除以字号，得到无单位的行高值，即24px/16px=1.5。字距通常会给定一个字数，比如100。因为这个数字表示1em的千分之一，所以除以1000就可以转化成em单位，即100/1000=0.1em。</p>
<p>对于正文主体来讲，调整间距是为了使阅读体验效果更佳，但对于标题和其他内容很少的元素（比如按钮）来讲，影响不大。这时候间距可调整范围大大增加，就可以多多发挥创意了。也可以使用负数设置字符间距，让字符更紧凑。</p>
<h2 id="过渡"> 过渡</h2>
<h3 id="从这边到那边"> 从这边到那边</h3>
<p>过渡是通过一系列transition-*属性来实现的。如果某个元素设置了过渡，那么当它的属性值发生变化时，并不是直接变成新值，而是使用过渡效果。</p>
<details><summary>Code</summary>
<p><button>Hover over me</button>
<style>
button {
background-color: hsl(180, 50%, 50%);
border: 0;
color: white;
font-size: 1rem;
padding: .3em 1em;
transition-property: all; /* 所有属性变化都使用过渡效果 <em>/
transition-duration: 0.5s; /</em> 过渡时间 */
}
button:hover {
background-color: hsl(0, 50%, 50%);
border-radius: 1em;
}
</style></p>
</details>
<ul>
<li>transition-property：指定哪些属性使用过渡。</li>
<li>transition-duration：代表过渡到最终值之前需要多长时间</li>
<li>元素属性任何时候发生变化都会触发过渡：可以是状态改变的时候，比如：hover；也可以是JavaScript导致变化的时候，比如添加或者移除类影响了元素的样式。</li>
<li>过渡属性要设置在一个始终指向需要过渡的元素的选择器。因为虽然其他属性发生着变化，但你肯定不想过渡属性本身发生变化。</li>
<li>简写属性transition： transition:property duration timing-function delay
<ul>
<li>timing-function 定时函数，用来控制属性的中间值如何计算，实际上控制的是过渡过程中变化率如何加速或者减速。定时函数可以是一个关键字值，比如linear或者ease-in，也可以是自定义函数。</li>
<li>delay 延迟时间</li>
</ul>
</li>
</ul>
<h3 id="定时函数"> 定时函数</h3>
<p>过渡让某个属性从一个值“移动”到另一个值，定时函数用来说明如何移动。</p>
<ul>
<li>linear：值以固定的速度改变</li>
<li>ease-in：变化速度开始时慢，然后一直加速，直到过渡完成</li>
<li>ease-out：是减速，开始时快速变化，结束时比较慢</li>
</ul>
<p>定时函数是基于数学定义的贝塞尔曲线（Bézier curve）。浏览器使用贝塞尔曲线作为随时间变化的函数，来计算某个属性的值。
<img src="/assets/img/transition-timing-func.png" alt="定时函数" /><br>
这些贝塞尔曲线都是从左下方开始，持续延伸到右上方。时间是从左向右递进的，曲线代表某个值在到达最终值的过程中是如何变化的。</p>
<div><p>设置定时函数</p>
<p>打开开发者工具并检查样式面板中的定时函数，旁边有一个小小的标志符号。点击标志符号会打开一个弹窗，可以在弹窗中修改定时函数的曲线。</p>
</div>
<div><p>过渡时间</p>
<p>按照经验来讲，大部分的过渡持续时间应该处于200～500ms。时间如果再长，用户就会感觉页面变得卡慢，页面响应让他们产生了无谓的等待，尤其是面对那些经常或者重复使用的过渡特效时。<br>
对于鼠标悬停、淡入淡出和轻微缩放特效，应该使用较快的过渡速度。一般要控制在300ms以下，有时候甚至可能要低到100ms。对于那些包含较大移动或者复杂定时函数的过渡，比如弹跳特效，要使用较长的300～500ms的持续时间。</p>
</div>
<div><p>选择定时函数</p>
<p>可以在下列场景中分别使用这三种函数。</p>
<ul>
<li>线性——颜色变化和淡出、淡入效果。</li>
<li>减速——用户发起的变化。用户点击按钮或者划过元素的时候，使用ease-out或者类似曲线。这样用户就可以看到快速发生的反馈，及时响应输入，然后元素慢慢过渡到最终状态。</li>
<li>加速——系统发起的变化。当内容加载完成或者超时事件触发的时候，使用ease-in或者类似曲线。这样元素就可以慢慢引起用户注意，然后速度越来越快直到完成最终变化。</li>
</ul>
</div>
<hr>
<p>另一种定时函数--阶跃steps()<br>
阶跃函数需要两个参数：阶跃次数和一个用来表示每次变化发生在阶跃的开始还是结束的关键词（start或者end）<br>
<img src="/assets/img/step-func.png" alt="阶跃函数" /><br>
第二个参数的默认值是end，所以steps(3)等于steps(3, end)。</p>
<h3 id="创建下拉菜单并添加过渡效果"> 创建下拉菜单并添加过渡效果</h3>
<p>使用透明度的过渡为下拉菜单的打开和闭合添加淡入淡出特效。</p>
<div><pre><code><span>.dropdown__drawer</span> <span>{</span>
    <span>position</span><span>:</span> absolute<span>;</span>
    <span>background-color</span><span>:</span> white<span>;</span>
    <span>width</span><span>:</span> 10em<span>;</span>
    <span>opacity</span><span>:</span> 0<span>;</span>
    <span>visibility</span><span>:</span> hidden<span>;</span>
    <span>transition</span><span>:</span> opacity 0.2s linear<span>,</span> <span>/* 透明度过渡效果--淡出 */</span>
                visibility 0s linear 0.2s<span>;</span> <span>/* 淡出时，可见性在透明度过渡完成时再变化 */</span>
<span>}</span>
<span>.dropdown.is-open .dropdown__drawer</span> <span>{</span>
    <span>opacity</span><span>:</span> 1<span>;</span>
    <span>visibility</span><span>:</span> visible<span>;</span>
    <span>transition-delay</span><span>:</span> 0s<span>;</span> <span>/* 菜单淡入时，可见性要立即变化，否则看不到淡入效果 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>visibility属性可以从页面上移除某个元素，有点类似于display属性，分别设置visible和hidden即可。但跟display不同的是，visibility可以支持动画。为它设置过渡不会使其逐渐消失，但transition-delay可以生效，而在display属性上是不生效的。<br>
为某个元素设置visibility: hidden可以从可见页面中移除该元素，但不会从文档流中移除它，这就意味着该元素仍然占位。其他元素会继续围绕该元素的位置布局，在页面上保留一个空白区域。在我们的例子中，不会影响到菜单，因为我们同时也设置了绝对定位。</p>
<hr>
<p>实现自动高度</p>
<div><pre><code><span>.dropdown__drawer</span> <span>{</span>
    <span>position</span><span>:</span> absolute<span>;</span>
    <span>background-color</span><span>:</span> white<span>;</span>
    <span>width</span><span>:</span> 10em<span>;</span>
    <span>height</span><span>:</span> 0<span>;</span>
    <span>overflow</span><span>:</span> hidden<span>;</span>
    <span>transition</span><span>:</span> height 0.3s ease-out<span>;</span>
<span>}</span>
<span>.dropdown.is-open .dropdown__drawer</span> <span>{</span>
    <span>height</span><span>:</span> auto<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>很遗憾，这种纯css写法不会奏效。因为过渡不支持auto，必须指定确定的高度值。但在css中没办法知道具体的高度值。因为只有当内容在浏览器中渲染完成之后才能确定高度，所以需要使用JavaScript来获取。<br>
页面加载完成后，访问DOM元素的scrollHeight属性，就可以获取到高度值。</p>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>var</span> toggle <span>=</span> document<span>.</span><span>getElementsByClassName</span><span>(</span><span>'dropdown__toggle'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span>
    <span>var</span> dropdown <span>=</span> toggle<span>.</span>parentElement<span>;</span>
    <span>var</span> drawer <span>=</span> document<span>.</span><span>getElementsByClassName</span><span>(</span><span>'dropdown__drawer'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>;</span>
    <span>var</span> height <span>=</span> drawer<span>.</span>scrollHeight<span>;</span> <span>// 元素的高度值</span>

    toggle<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
        e<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
        dropdown<span>.</span>classList<span>.</span><span>toggle</span><span>(</span><span>'is-open'</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>dropdown<span>.</span>classList<span>.</span><span>contains</span><span>(</span><span>'is-open'</span><span>)</span><span>)</span> <span>{</span>
            drawer<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'height'</span><span>,</span> height <span>+</span> <span>'px'</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            drawer<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'height'</span><span>,</span> <span>'0'</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="变换"> 变换</h2>
<p>transform属性，它可以用来改变页面元素的形状和位置，其中包括二维或者三维的旋转、缩放和倾斜。用法：<code>transform:rotata(90deg)</code>
<img src="/assets/img/transformation.png" alt="变换" /><br>
使用变换的时候要注意一件事情，虽然元素可能会被移动到页面上的新位置，但它不会脱离文档流。你可以在屏幕范围内以各种方式平移元素，其初始位置不会被其他元素占用。当旋转某元素的时候，它的一角可能会移出屏幕边缘，同样也可能会遮住旁边其他元素的部分内容。</p>
<div><p>注意</p>
<p>变换不能作用在span或者a这样的行内元素上。若确实要变换此类元素，要么改变元素的display属性，替换掉inline（比如inline-block），要么把元素改为弹性子元素或者网格项目（为父元素应用display: flex或者display: grid）。</p>
</div>
<ul>
<li>变换是围绕基点（point of origin）发生的。基点是旋转的轴心，也是缩放或者倾斜开始的地方。这就意味着元素的基点是固定在某个位置上，元素的剩余部分围绕基点变换（但translate()是个例外，因为平移过程中元素整体移动）。</li>
<li>默认情况下，基点就是元素的中心，但可以通过transform-origin:x y属性改变基点位置。
<ul>
<li>常用值：left, right, top, bottom, center</li>
<li>基点也可以指定为百分比，从元素左上角开始测量。</li>
</ul>
</li>
<li>可以对transform属性指定多个值，用空格隔开。变换的每个值从右向左按顺序执行，类似矩阵变换。</li>
</ul>
<h3 id="图标放大效果"> 图标放大效果</h3>
<p>图标设置过宽度和高度，因此我们可以通过增大这些属性来放大它。但会重新计算文档流时，导致其周围的一些元素跟着移动。如果改用变换，那周围的元素不会受到影响。</p>
<div><pre><code><span>.nav-links__icon</span> <span>{</span>
    <span>transition</span><span>:</span> transform 0.2s ease-out<span>;</span>
<span>}</span>

<span>.nav-links a:hover > .nav-links__icon,
.nav-links a:focus > .nav-links__icon</span> <span>{</span>
    <span>transform</span><span>:</span> <span>scale</span><span>(</span>1.3<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="飞入效果"> 飞入效果</h3>
<p>菜单的标签没有必要一直保持可见状态。默认情况下可以把它们隐藏，只在相应位置保留图标，告诉用户菜单的位置。当用户移动鼠标到菜单或者导航元素上时，再把标签以淡入的方式展示出来。</p>
<div><pre><code><span>.nav-links</span> <span>{</span>
    <span>display</span><span>:</span> block<span>;</span>
    <span>padding</span><span>:</span> 1em<span>;</span>
    <span>margin-bottom</span><span>:</span> 0<span>;</span>
<span>}</span>
<span>.nav-links > li + li</span> <span>{</span>
    <span>margin-left</span><span>:</span> 0<span>;</span>
<span>}</span>

<span>.nav-links__label</span> <span>{</span>
    <span>display</span><span>:</span> inline-block<span>;</span>
    <span>margin-left</span><span>:</span> 1em<span>;</span> <span>/* 为过渡效果预留的空间 */</span>
    <span>padding-right</span><span>:</span> 1em<span>;</span>
    <span>opacity</span><span>:</span> 0<span>;</span>
    <span>transform</span><span>:</span> <span>translate</span><span>(</span>-1em<span>)</span><span>;</span>
    <span>transition</span><span>:</span> transform 0.4s <span>cubic-bezier</span><span>(</span>0.2<span>,</span> 0.9<span>,</span> 0.3<span>,</span> 1.3<span>)</span><span>,</span> <span>/*  */</span>
                opacity 0.4s linear<span>;</span> <span>/* 背景淡入淡出 */</span>
<span>}</span>
<span>.nav-links:hover .nav-links__label,
.nav-links a:focus > .nav-links__label</span> <span>{</span>
    <span>opacity</span><span>:</span> 1<span>;</span>
    <span>transform</span><span>:</span> <span>translate</span><span>(</span>0<span>)</span><span>;</span>
<span>}</span>

<span>.nav-links__icon</span> <span>{</span>
    <span>transition</span><span>:</span> transform 0.2s ease-out<span>;</span>
<span>}</span>

<span>.nav-links a:hover > .nav-links__icon,
.nav-links a:focus > .nav-links__icon</span> <span>{</span>
    <span>transform</span><span>:</span> <span>scale</span><span>(</span>1.3<span>)</span><span>;</span>
<span>}</span>

<span>/* 为每个菜单项设置不同的延迟时间。这样就可以使每段动画交错飞入显示
，不再一次性全部展示出来，就像翻滚的“波浪” */</span>
<span>.nav-links > li:nth-child(2) .nav-links__label</span> <span>{</span>
    <span>transition-delay</span><span>:</span> 0.1s<span>;</span>
<span>}</span>
<span>.nav-links > li:nth-child(3) .nav-links__label</span> <span>{</span>
    <span>transition-delay</span><span>:</span> 0.2s<span>;</span>
<span>}</span>
<span>.nav-links > li:nth-child(4) .nav-links__label</span> <span>{</span>
    <span>transition-delay</span><span>:</span> 0.3s<span>;</span>
<span>}</span>
<span>.nav-links > li:nth-child(5) .nav-links__label</span> <span>{</span>
    <span>transition-delay</span><span>:</span> 0.4s<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><h3 id="_3d变换"> 3D变换</h3>
<p>旋转和平移都可以在三个维度上实现：X轴、Y轴和Z轴。</p>
<div><pre><code><span>.a</span> <span>{</span>
    <span>transform</span><span>:</span> <span>translate</span><span>(</span>15px<span>,</span> 50px<span>)</span><span>;</span> <span>/* 等价于transform: translateX(15px) translateY(50px); */</span>
    <span>transform</span><span>:</span> <span>rotate</span><span>(</span>30deg<span>)</span><span>;</span> <span>/* 等价于transform: rotateZ(30deg); */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="透视距离"> 透视距离</h4>
<p>为页面添加3D变换之前，我们需要先确定一件事情，即透视距离（perspective）。变换后的元素一起构成了一个3D场景。接着浏览器会计算这个3D场景的2D图像，并渲染到屏幕上。透视距离类似相机到近平面的距离。</p>
<p>可以通过两种方式指定透视距离：使用perspective()变换或者使用perspective属性。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>row<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>One<span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>Two<span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>Three<span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>Four<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
    <span>.row</span> <span>{</span>
        <span>display</span><span>:</span> flex<span>;</span>
        <span>justify-content</span><span>:</span> center<span>;</span>
        <span>/* 给父容器设置透视距离，则所有子容器可看作一个整体，效果和单独设置不同 */</span>
        <span>/* perspective: 200px; .box的transform只设置rotateX */</span>
    <span>}</span>

    <span>.box</span> <span>{</span>
        <span>box-sizing</span><span>:</span> border-box<span>;</span>
        <span>width</span><span>:</span> 150px<span>;</span>
        <span>margin</span><span>:</span> 0 2em<span>;</span>
        <span>padding</span><span>:</span> 60px 0<span>;</span>
        <span>text-align</span><span>:</span> center<span>;</span>
        <span>background-color</span><span>:</span> <span>hsl</span><span>(</span>150<span>,</span> 50%<span>,</span> 40%<span>)</span><span>;</span>
        <span>transform</span><span>:</span> <span>perspective</span><span>(</span>200px<span>)</span> <span>rotateX</span><span>(</span>30deg<span>)</span><span>;</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><p>注意</p>
<ul>
<li>添加透视距离是3D变换中非常重要的部分。如果不设置透视距离，离得远的元素不会显得变小，离得近的元素也不会显得变大。</li>
<li>透视距离小，3D效果就会比较强。透视距离大，3D效果就会比较弱。</li>
</ul>
</div>
<h4 id="其他3d属性"> 其他3D属性</h4>
<ul>
<li>perspective-origin：默认情况下，透视距离的渲染是假设观察者（或者镜头）位于元素中心的正前方。perspective-origin属性可以上下、左右移动镜头的位置。</li>
<li>backface-visibility：如果你使用rotateX()或者rotateY()旋转元素超过90度，就会发现一些有趣的事情：元素的“脸”不再直接朝向你。它的“脸”转向别的地方，你会看到元素的背面。默认情况下背面是可见的，但我们可以为元素设置backface-visibility:hidden来改变它。添加这条声明之后，元素只有在正面朝向观察者的时候才可见，朝向别处的时候不可见。
<ul>
<li>针对这项技术，一个可能的应用场景是把两个元素背靠背放在一起，就像卡片的两面。卡片的正面展示出来，背面隐藏。然后我们可以旋转它们的容器元素，使这两个元素都翻转过来，这样正面隐藏背面显现。</li>
</ul>
</li>
<li>transform-style:preserve-3d -- 假设对容器设置了透视距离，接下来对容器内的元素进行3D变换。容器元素渲染时，实际上会被绘制成2D场景，就像是3D对象的一张照片。这看起来没什么问题，因为元素最终就是要渲染到2D屏幕上的。如果接下来我们对容器元素进行3D旋转，就有问题了。这是因为实际上没有对整个场景进行旋转，只是旋转3D场景的2D照片。透视距离全都错了，场景中的立体感也被破坏了。这时transform-style:preserve-3d就有作用了。
<ul>
<li>参考<a href="https://davidwalsh.name/css-cube" target="_blank" rel="noopener noreferrer">css cube</a></li>
</ul>
</li>
</ul>
<h2 id="动画"> 动画</h2>
<p>CSS中的动画包括两部分：用来定义动画的@keyframes规则和为元素添加动画的animation属性。</p>
<h3 id="关键帧"> 关键帧</h3>
<p>关键帧（keyframe）是指动画过程中某个特定时刻。我们定义一些关键帧，浏览器负责填充或者插入这些关键帧之间的帧图像。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.box</span> <span>{</span>
    <span>width</span><span>:</span> 100px<span>;</span>
    <span>height</span><span>:</span> 100px<span>;</span>
    <span>background-color</span><span>:</span> green<span>;</span>
    <span>animation</span><span>:</span> over-and-back 1.5s linear 3<span>;</span>
<span>}</span>

<span><span>@keyframes</span> over-and-back</span> <span>{</span>
<span>0%</span> <span>{</span>
    <span>background-color</span><span>:</span> <span>hsl</span><span>(</span>0<span>,</span> 50%<span>,</span> 50%<span>)</span><span>;</span>
    <span>transform</span><span>:</span> <span>translate</span><span>(</span>0<span>)</span><span>;</span>
<span>}</span>

<span>50%</span> <span>{</span>
    <span>transform</span><span>:</span> <span>translate</span><span>(</span>50px<span>)</span><span>;</span>
<span>}</span>

<span>100%</span> <span>{</span>
    <span>background-color</span><span>:</span> <span>hsl</span><span>(</span>270<span>,</span> 50%<span>,</span> 90%<span>)</span><span>;</span>
    <span>transform</span><span>:</span> <span>translate</span><span>(</span>0<span>)</span><span>;</span>
<span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>animation是简写属性。</p>
<ul>
<li>animation-name——代表动画名称，来自@keyframes规则定义。</li>
<li>animation-duration——代表动画持续时间</li>
<li>animation-timing-function——代表定时函数</li>
<li>animation-iteration-count——代表动画重复的次数。初始值默认是1。</li>
</ul>
<div><p>注意</p>
<ol>
<li>颜色从0%的红色平滑过渡到100%的淡紫色，但是接下来动画重复的时候立即变回红色。如果你打算重复某个动画并希望整体衔接流畅，需要确保结束值和初始值相匹配。</li>
<li>最后一次重复动画结束后，背景颜色变为绿色，即原样式规则中指定的值。但注意动画持续过程中，这句样式声明被@keyframes中的规则覆盖了。如果出现样式层叠，那么动画中设置的规则比其他声明拥有更高的优先级。</li>
<li>优先级规则：用户代理样式 &lt; 作者自定义样式 &lt; @keyframe中定义的样式 &lt; !important</li>
</ol>
</div>
<h3 id="动画延迟和填充模式"> 动画延迟和填充模式</h3>
<p>可以使用animation-delay属性推迟动画开始的时间，该属性行为和transition-delay类似。</p>
<div><pre><code><span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.flyin-grid</span> <span>{</span>
    <span>margin</span><span>:</span> 0 1rem<span>;</span>
    <span>perspective</span><span>:</span> 500px<span>;</span> <span>/* 添加透视距离 */</span>
<span>}</span>

<span>.flyin-grid__item</span> <span>{</span>
    <span>animation</span><span>:</span> fly-in 600ms ease-in<span>;</span> <span>/* 添加动画 */</span>
    <span>/* animation-fill-mode: backwards; 加上这一句，动画前的元素的初始位置就对了 */</span>
<span>}</span>
<span>/* 添加动画延迟 */</span>
<span>.flyin-grid__item:nth-child(2)</span> <span>{</span>
    <span>animation-delay</span><span>:</span> 0.15s<span>;</span>
<span>}</span>
<span>.flyin-grid__item:nth-child(3)</span> <span>{</span>
    <span>animation-delay</span><span>:</span> 0.3s<span>;</span>
<span>}</span>
<span>.flyin-grid__item:nth-child(4)</span> <span>{</span>
    <span>animation-delay</span><span>:</span> 0.45s<span>;</span>
<span>}</span>


<span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 30em<span>)</span></span> <span>{</span>
<span>.flyin-grid</span> <span>{</span>
    <span>display</span><span>:</span> flex<span>;</span>
    <span>flex-wrap</span><span>:</span> wrap<span>;</span>
    <span>margin</span><span>:</span> 0 5rem<span>;</span>
<span>}</span>

<span>.flyin-grid__item</span> <span>{</span>
    <span>flex</span><span>:</span> 1 1 300px<span>;</span>
    <span>margin-left</span><span>:</span> 0.5em<span>;</span>
    <span>margin-right</span><span>:</span> 0.5em<span>;</span>
    <span>max-width</span><span>:</span> 600px<span>;</span>
<span>}</span>

<span><span>@supports</span> <span>(</span><span>display</span><span>:</span> grid<span>)</span></span> <span>{</span> <span>/* 查询浏览器是否支持grid属性，如果支持，则下面样式生效 */</span>
    <span>.flyin-grid</span> <span>{</span>
        <span>display</span><span>:</span> grid<span>;</span>
        <span>/* 尽可能多的生成网格轨道，每个轨道至少300px，如果元素较少，会将非空轨道扩展以填满空白 */</span>
        <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>auto-fit<span>,</span> <span>minmax</span><span>(</span>300px<span>,</span> 1fr<span>)</span><span>)</span><span>;</span>
        <span>grid-gap</span><span>:</span> 2em<span>;</span> <span>/* 网格元素间距 */</span>
    <span>}</span>

    <span>.flyin-grid__item</span> <span>{</span>
        <span>max-width</span><span>:</span> initial<span>;</span> <span>/* div 的 max-width 初始值为 none，即没有限制*/</span>
        <span>margin</span><span>:</span> 0<span>;</span>
    <span>}</span>
<span>}</span>
<span>}</span>

<span>.card</span> <span>{</span>
    <span>margin-bottom</span><span>:</span> 1em<span>;</span>
    <span>padding</span><span>:</span> 0.5em<span>;</span>
    <span>background-color</span><span>:</span> white<span>;</span>
    <span>color</span><span>:</span> <span>hsl</span><span>(</span>210<span>,</span> 15%<span>,</span> 20%<span>)</span><span>;</span>
    <span>box-shadow</span><span>:</span> 0.2em 0.5em 1em <span>rgba</span><span>(</span>0<span>,</span> 0<span>,</span> 0<span>,</span> 0.3<span>)</span><span>;</span>
<span>}</span>
<span>.card > img</span> <span>{</span>
    <span>width</span><span>:</span> 100%<span>;</span>
<span>}</span>

<span><span>@keyframes</span> fly-in</span> <span>{</span>
    <span>0%</span> <span>{</span>
        <span>transform</span><span>:</span> <span>translateZ</span><span>(</span>-800px<span>)</span> <span>rotateY</span><span>(</span>90deg<span>)</span><span>;</span>
        <span>opacity</span><span>:</span> 0<span>;</span>
    <span>}</span>
    <span>56%</span> <span>{</span>
        <span>transform</span><span>:</span> <span>translateZ</span><span>(</span>-160px<span>)</span> <span>rotateY</span><span>(</span>87deg<span>)</span><span>;</span>
        <span>opacity</span><span>:</span> 1<span>;</span>
    <span>}</span>
    <span>100%</span> <span>{</span>
        <span>transform</span><span>:</span> <span>translateZ</span><span>(</span>0<span>)</span> <span>rotateY</span><span>(</span>0<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>

<span><span><span>&lt;</span>main</span> <span>class</span><span><span>=</span><span>"</span>flyin-grid<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>flyin-grid__item card<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>images/chicken1.jpg<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>a chicken<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;</span>h4</span><span>></span></span>Mrs. Featherstone<span><span><span>&lt;/</span>h4</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
        She may be a bit frumpy, but Mrs Featherstone gets
        the job done. She lays her largish cream-colored
        eggs on a daily basis. She is gregarious to a fault.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>This Austra White is our most prolific producer.<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>flyin-grid__item card<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>images/chicken2.jpg<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>a chicken<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;</span>h4</span><span>></span></span>Hen Solo<span><span><span>&lt;/</span>h4</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
        Though the most recent addition to our flock, Hen
        Solo is a fast favorite among our laying brood. She
        is a sassy and suspicious hen; we frequently have to
        follow her to find where she has hidden her loot from
        the other hens.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>This Snowy Easter Egger lays in delicate shades of
        blue and green. A full dozen of her eggs costs an
        additional $2.<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>flyin-grid__item card<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>images/chicken3.jpg<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>a chicken<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;</span>h4</span><span>></span></span>Cluck Norris<span><span><span>&lt;/</span>h4</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
        Every brood has its brawler. Cluck Norris is our
        feistiest hen, frequently picking fights with other
        hens about laying territory and foraging space. Her
        sister hens continue to hope that she will follow the
        steps of her namesake (eventually) and focus the her
        strength of will for good.
    <span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>This Buff Chantecler is as robust and hardy as her
        Canadian forebears, laying through the coldest parts
        of the winter.<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>main</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br></div></div><p>以上代码有一个问题：后面的元素在动画还没开始播放的时候就出现在了最终位置，开始播放时才转到动画初始位置。</p>
<p>使用animation-fill-mode可以在动画播放前或播放后应用动画样式。</p>
<ul>
<li>初始值是none--意思是动画执行前或执行后动画样式都不会应用到元素上。</li>
<li>backwards--在动画执行之前，浏览器就会取出动画中第一帧的值，并把它们应用在元素上。</li>
<li>forwards--在动画播放完成后仍然应用最后一帧的值。</li>
<li>both--会同时向前和向后填充。<br>
为页面添加后向填充模式可以修复动画开始时的元素跳动。</li>
</ul>
<h3 id="用动画传递意图"> 用动画传递意图</h3>
<p>好的动画不是最后才加上的，而是融入到了开发过程中。它们向用户传达页面上某些事物的特殊含义。<br>
动画可以向用户表明按钮被点击了或者消息被接收了。如果你曾经提交过表单，回想一下是否经常记不清自己点没点过注册按钮，就知道这有多重要了。</p>
<p><a href="https://animista.net/play/basic" target="_blank" rel="noopener noreferrer">CSS Animista</a></p>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/radial-gradient.png" type="image/png"/>
    </item>
    <item>
      <title>CSS 基础</title>
      <link>https://kigane.github.io/note/js/css-basic/</link>
      <guid>https://kigane.github.io/note/js/css-basic/</guid>
      <source url="https://kigane.github.io/rss.xml">CSS 基础</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基础"> 基础</h2>
<h3 id="术语"> 术语</h3>
<ul>
<li>声明：CSS中的一行，由一个属性和一个值组成。例如 color:black。</li>
<li>声明块：包含在大括号内的一组声明。</li>
<li>规则集：选择器 + 声明块</li>
<li>@规则：用“@”符号开头的语法。比如@import规则或者@media查询。</li>
<li>层叠值：作为层叠结果，应用到一个元素上的特定属性的值。</li>
<li>计算值：浏览器根据相对单位的值计算出的绝对值。</li>
<li>声明值：声明中的值</li>
<li>视口：浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏。</li>
<li>*：通用选择器，选中页面上所有元素</li>
<li>普通文档流：指网页元素的默认布局行为。行内元素跟随文字的方向从左到右排列，当到达容器边缘时会换行。块级元素会占据完整的一行，前后都有换行。</li>
</ul>
<h3 id="选择器"> 选择器</h3>
<p>基础选择器</p>
<ul>
<li>tagname 标签选择器。优先级001</li>
<li>.class 类选择器。优先级010</li>
<li>#id ID选择器。优先级100</li>
<li><code>*</code> 通用选择器。优先级000</li>
</ul>
<hr>
<p>组合选择器</p>
<ul>
<li>a&gt;b 子组合器。a的直接后代b</li>
<li>a+b 相邻兄弟组合器。紧跟在a后面的兄弟元素b。</li>
<li>a~b 通用兄弟组合器。所有在a后面的兄弟元素b。</li>
<li>a b 选择a的后代中的任何匹配b选择器的元素。</li>
<li>ab  选择所有既符合a，又符合b的元素。复合选择器。多个基础选择器可以连起来(不使用空格或者其他组合器)组成一个复合选择器。复合选择器选中的元素将匹配其全部基础选择器。例如.dropdown.is-active只能匹配同时有这两个类的元素。</li>
</ul>
<hr>
<p>伪类选择器<br>
用于选中处于某个特定状态的元素。这种状态可能是由于用户交互，也可能是由于元素相对于其父级或兄弟元素的位置。伪类选择器始终以一个冒号(:)开始。优先级等于一个类选择器(0,1,0)。</p>
<ul>
<li>:first-child——匹配的元素是其父元素的第一个子元素。</li>
<li>:last-child——匹配的元素是其父元素的最后一个子元素。</li>
<li>:only-child——匹配的元素是其父元素的唯一一个子元素(没有兄弟元素)。</li>
<li>:nth-child(an+b)——匹配的元素在兄弟元素中间有特定的位置。公式an+b里面的a和b是整数，n取所有自然数，包括0。</li>
<li>:nth-last-child(an+b)——类似于：nth-child()，但不是从第一个元素往后数，而是从最后一个元素往前数。</li>
<li>:first-of-type——类似于：first-child，但不是根据在全部子元素中的位置查找元素，而是根据拥有相同标签名的子元素中的数字顺序查找第一个元素。</li>
<li>:last-of-type——匹配每种类型的最后一个子元素。</li>
<li>:only-of-type——该选择器匹配的元素是满足该类型的唯一一个子元素。</li>
<li>:nth-of-type(an+b)——根据目标元素在特定类型下的数字顺序以及特定公式选择元素，类似于：nth-child。</li>
<li>:nth-last-of-type(an+b)——根据元素类型以及特定公式选择元素，从其中最后一个元素往前算，类似于：nth-last-child。</li>
<li><code>:not(&lt;selector&gt;)</code>——匹配的元素不匹配括号内的选择器。括号内的选择器必须是基础选择器，它只能指定元素本身，无法用于排除祖先元素，同时不允许包含另一个排除选择器。</li>
<li>:empty——匹配的元素必须没有子元素。注意，如果元素包含空格就无法由该选择器匹配，因为空格在DOM中属于文本节点。</li>
<li>:focus——匹配通过鼠标点击、触摸屏幕或者按Tab键导航而获得焦点的元素。</li>
<li>:hover——匹配鼠标指针正悬停在其上方的元素。</li>
<li>:root——匹配文档根元素。</li>
</ul>
<hr>
<p>伪元素选择器</p>
<ul>
<li>::before——创建一个伪元素，使其成为匹配元素的第一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定content属性才能让元素出现，例如：.menu::before。</li>
<li>::after——创建一个伪元素，使其成为匹配元素的最后一个子元素。类似::before。</li>
<li>::first-letter——用于指定匹配元素的第一个文本字符的样式，例如：h2::first-letter。</li>
<li>::first-line——用于指定匹配元素的第一行文本的样式。</li>
<li>::selection——用于指定用户使用鼠标高亮选择的任意文本的样式。通常用于改变选中文本的background-color。只有少数属性可以使用，包括color、background-color、cursor、text-decoration。</li>
</ul>
<hr>
<p>属性选择器<br>
用于根据HTML属性匹配元素。其优先级与一个类选择器(0,1,0)相等。</p>
<ul>
<li><code>[attr]</code>——匹配的元素拥有指定属性attr，无论属性值是什么</li>
<li><code>[attr=&quot;value&quot;]</code>——匹配的元素拥有指定属性attr，且属性值等于指定的字符串值</li>
<li><code>[attr^=&quot;value&quot;]</code>——“开头”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值的开头是指定的字符串值，例如：<code>a[href^=&quot;https&quot;]</code>。</li>
<li><code>[attr$=&quot;value&quot;]</code>——“结尾”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值的结尾是指定的字符串值，例如：<code>a[href$= &quot;.pdf&quot;]</code>。</li>
<li><code>[attr*=&quot;value&quot;]</code>——“包含”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值包含指定的字符串值，例如：<code>[class*=&quot;sprite-&quot;]</code>。</li>
<li><code>[attr~=&quot;value&quot;]</code>——“空格分隔的列表”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值是一个空格分隔的值列表，列表中的某个值等于指定的字符串值</li>
<li><code>[attr|=&quot;value&quot;]</code>——匹配的元素拥有指定属性attr，且属性值要么等于指定的字符串值，要么以该字符串开头且紧跟着一个连字符。适用于语言属性，因为该属性有时候会指定一种语言的子集(比如墨西哥西班牙语，es-MX，或者普通的西班牙语，es)，例如：<code>[lang|=&quot;es&quot;]</code>。</li>
</ul>
<h3 id="浏览器的开发者工具"> 浏览器的开发者工具</h3>
<h4 id="样式"> 样式</h4>
<ul>
<li>element.style 为行内样式</li>
<li>靠近顶部的样式会覆盖下面的样式。</li>
<li>被覆盖的样式上划了删除线。</li>
<li>右侧显示了每个规则集的样式表和在源代码中行号。</li>
<li>顶部的筛选框可以选择特定的声明，同时隐藏其他声明。</li>
<li>按住shift，再点击颜色前的方框，可以改变颜色的表示法</li>
</ul>
<h4 id="element"> Element</h4>
<ul>
<li>选择指定元素，右键菜单中可以设置强制元素进入:active,:hover等状态。</li>
</ul>
<h3 id="层叠"> 层叠</h3>
<p>当声明冲突时，层叠会依据三种条件解决冲突。</p>
<ol>
<li>样式表的来源：样式是从哪里来的，有三级，浏览器默认样式(也称用户代理样式)，作者自定义样式(即开发者写的CSS)，作者的!important样式。后面的会覆盖前面的。</li>
<li>选择器优先级：行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。选择器最高优先级相同时，比其数量，数量多的优先级高。
<ul>
<li>伪类选择器(如：hover)和属性选择器(如[type=&quot;input&quot;])与一个类选择器的优先级相同。通用选择器(*)和组合器(&gt;、+、~)对优先级没有影响。</li>
</ul>
</li>
<li>源码顺序：样式在样式表里的声明顺序。晚出现的优先级更高。</li>
</ol>
<h3 id="继承-inherit-属性值"> 继承(inherit 属性值)</h3>
<ul>
<li>不是所有的属性都能被继承。默认情况下，只有特定的一些属性能被继承，通常是我们希望被继承的那些。</li>
<li>文本相关的属性：color、font、font-family、font-size、font-weight、font-variant、font-style、line-height、letter-spacing、text-align、text-indent、text-transform、white-space以及word-spacing。</li>
<li>列表属性：list-style、list-style-type、list-style-position以及list-style-image。</li>
<li>表格的边框属性border-collapse和border-spacing也能被继承。</li>
</ul>
<p>PS: initial属性，即CSS属性的初始值。可用于撤销某元素的样式。</p>
<h3 id="简写属性"> 简写属性</h3>
<p>简写属性是用于同时给多个属性赋值的属性。例如</p>
<ul>
<li>font：它指定了font-style、font-weight、font-size、font-height以及font-family。</li>
<li>background：它指定了background-color、background-image、background-size、background-repeat、background-position、background-origin、background-chip以及background-attachment。</li>
<li>border是border-width、border-style以及border-color的简写属性</li>
<li>border-width是上、右、下、左四个边框宽度的简写属性。</li>
</ul>
<p>大多数简写属性可以省略一些值，只指定我们关注的值。但被省略的值会被隐式地设置为初始值。<br>
通常元素的四个方向相关的属性声明顺序为上右下左，即顺时针方向。如果声明结束时四个属性值还剩有没指定的，则没有指定的一边会取其对边的值。指定三个值时，左边和右边都会使用第二个值。指定两个值时，上边和下边会使用第一个值，左边和右边使用第二个值。如果只指定一个值，那么四个方向都会使用这个值。</p>
<p>还有一些属性只支持最多指定两个值，这些属性包括background-position、box-shadow、text-shadow(虽然严格来讲它们并不是简写属性)。其声明顺序为先x,后y。即先水平方向，再垂直方向。</p>
<h2 id="相对单位"> 相对单位</h2>
<h3 id="em-rem"> em &amp; rem</h3>
<ul>
<li>em
<ul>
<li>对于font-size属性，em是根据继承的字号来计算的，即父元素的font-size。</li>
<li>对于非font-size属性，em是根据元素的font-size属性计算的。</li>
<li>em的复杂之处就在于同时用它指定一个元素的字号和其他属性。这时，浏览器必须先计算字号，然后使用这个计算值去算出其余的属性值。这两类属性可以拥有一样的声明值，但是计算值不一样。</li>
<li>em的好处。可以定义一个元素的大小，然后只需要改变字号就能整体缩放元素。padding、height、width、border-radius等属性用em很方便。</li>
<li>对于嵌套结构，如果都使用em单位，则字体大小会逐级放大或缩小，要避免此情况，应使用rem单位。</li>
</ul>
</li>
<li>rem
<ul>
<li>根据根元素的 font-size 属性计算</li>
<li>html是根元素。根节点有一个伪类选择器:root。</li>
<li>对大多数浏览器来说，默认的字号为16px。准确地说，medium关键字的值是16px。</li>
</ul>
</li>
<li>百分数 基数为父元素的 px 值</li>
</ul>
<p>tips:拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性。</p>
<h3 id="媒体查询"> 媒体查询</h3>
<div><pre><code><span>:root</span> <span>{</span>
    <span>font-size</span><span>:</span> 0.75em<span>;</span>
<span>}</span>

<span>/* 作用于宽度 > 800px的屏幕，生效时，因源码顺序，会覆盖前面的样式 */</span>
<span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 800px<span>)</span></span> <span>{</span>
    <span>:root</span> <span>{</span>
    <span>font-size</span><span>:</span> 0.875em<span>;</span>
    <span>}</span>
<span>}</span>

<span>/* 作用于宽度 > 1200px的屏幕，生效时，因源码顺序，会覆盖前面的样式 */</span>
<span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 1200px<span>)</span></span> <span>{</span>
    <span>:root</span> <span>{</span>
    <span>font-size</span><span>:</span> 1em<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="视口单位"> 视口单位</h3>
<p>视口——浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏。</p>
<ul>
<li>vh：视口高度的1/100。</li>
<li>vw：视口宽度的1/100。</li>
<li>vmin：视口宽、高中较小的一方的1/100。</li>
<li>vmax：视口宽、高中较大的一方的1/100。</li>
</ul>
<p>相对视口单位有一个不起眼的用途，就是设置字号，这样做的好处在于元素能够在这两种大小之间平滑地过渡，即不会在某个断点突然改变。当视口大小改变时，元素会逐渐过渡。但只使用vw或vh，字号会比较大，所以通常会结合em一起使用。<br>
calc()函数可以对两个及其以上的值进行基本运算。当要结合不同单位的值时，calc()特别实用。它支持四则运算。加号和减号两边必须有空白，如calc(.5em + 1vh)。</p>
<h3 id="无单位的数值"> 无单位的数值</h3>
<p>有些属性允许无单位的值(即一个不指定单位的数)。</p>
<ul>
<li>支持这种值的属性包括line-height、z-index、font-weight(700等于bold,400等于normal，等等)。</li>
<li>任何长度单位都可以用无单位的值0，因为这些情况下单位不影响计算值，0px、0%、0em均相等。</li>
<li>警告:一个无单位的0只能用于长度值和百分比，比如内边距、边框和宽度等，而不能用于角度值，比如度，或者时间相关的值，比如秒。</li>
</ul>
<p>继承的怪异行为</p>
<ul>
<li>当一个元素的值定义为长度时，子元素会继承它的计算值。当使用em等单位定义行高时，它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，并且继承了line-height属性，就会造成意想不到的结果，比如文字重叠。</li>
<li>使用无单位的数值时，继承的是声明值，即在每个继承子元素上会重新算它的计算值。这样得到的结果几乎总是我们想要的。我们可以用一个无单位的数值给body设置行高，之后就不用修改了，除非有些地方想要不一样的行高。</li>
</ul>
<h3 id="自定义属性-css变量"> 自定义属性(css变量)</h3>
<div><pre><code><span>:root</span> <span>{</span>
    <span>--main-color</span><span>:</span> white<span>;</span> <span>/* 变量声明，无实际效果 */</span>
    <span>--main-bg</span><span>:</span> #fff<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>变量必须在一个声明块内声明。</li>
<li>变量名前面必须有两个连字符(--)，用来跟CSS属性区分，剩下的部分可以随意命名。</li>
<li>变量声明本身什么也没做，我们使用时才能看到效果。</li>
<li>使用变量需使用var()函数，其第二个参数，指定了备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值。</li>
<li>注意：如果var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。比如，如果在padding: var(--brand-color)中的变量算出来是一个颜色，它就是一个非法的内边距值。这种情况下，内边距会设置为0。</li>
<li><strong>自定义属性的声明能够层叠和继承</strong>，可以在多个选择器中定义相同的变量，则该变量在网页的不同地方有不同的值。</li>
</ul>
<p>用JS访问和修改自定义属性。</p>
<div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span><span>></span></span><span><span>
    <span>let</span> rootElement <span>=</span> document<span>.</span>documentElement<span>;</span>
    <span>let</span> styles <span>=</span> <span>getComputedStyle</span><span>(</span>rootElement<span>)</span><span>;</span>
    <span>let</span> mainColor <span>=</span> styles<span>.</span><span>getPropertyValue</span><span>(</span><span>'--main-bg'</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>String</span><span>(</span>mainColor<span>)</span><span>.</span><span>trim</span><span>(</span><span>)</span><span>)</span><span>;</span>

    rootElement <span>=</span> document<span>.</span>documentElement<span>;</span>
    rootElement<span>.</span>style<span>.</span><span>setProperty</span><span>(</span><span>'--main-bg'</span><span>,</span> <span>'#cdf'</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="盒模型"> 盒模型</h2>
<p><img src="/assets/img/box-model.png" alt="box-model" />
当给一个元素设置宽或高的时候，指定的是内容的宽或高，所有内边距、边框、外边距都是追加到该宽度上的。</p>
<h3 id="元素宽度问题"> 元素宽度问题</h3>
<p>在CSS中可以使用box-sizing属性调整盒模型的行为。</p>
<ul>
<li>box-sizing的默认值为content-box，这意味任何指定的宽或高都只会设置内容盒子的大小。</li>
<li>box-sizing设置为border-box后，height和width属性会设置内容、内边距以及边框的大小总和。</li>
</ul>
<p>全局修改盒模型为border-box(已是普遍做法了)</p>
<div><pre><code><span>:root</span> <span>{</span>
    <span>box-sizing</span><span>:</span> border-box<span>;</span>
<span>}</span>

<span>*,
::before,
::after</span> <span>{</span>
    <span>box-sizing</span><span>:</span> inherit<span>;</span> <span>/* 盒模型通常不会被继承，但是使用inherit关键字可以强制继承。 */</span>
<span>}</span>

<span>.third-party-component</span> <span>{</span>
    <span>box-sizing</span><span>:</span> content-box<span>;</span> <span>/* 如果带样式的第三方组件使用的是默认的盒模型，则恢复 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>给列之间加上间隙</p>
<div><pre><code><span>.main</span> <span>{</span>
    <span>float</span><span>:</span> left<span>;</span>
    <span>width</span><span>:</span> 70%<span>;</span>
    <span>background-color</span><span>:</span> #fff<span>;</span>
    <span>border-radius</span><span>:</span> .5em<span>;</span>
<span>}</span>

<span>.sidebar</span> <span>{</span>
    <span>float</span><span>:</span> left<span>;</span>
    <span>width</span><span>:</span> <span>calc</span><span>(</span>30% - 1.5em<span>)</span><span>;</span> <span>/* 从宽度中分1.5em给外边距以形成间隙 */</span>
    <span>margin-left</span><span>:</span> 1.5em<span>;</span>
    <span>padding</span><span>:</span> 1.5em<span>;</span>
    <span>background-color</span><span>:</span> #fff<span>;</span>
    <span>border-radius</span><span>:</span> .5em<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="元素高度问题"> 元素高度问题</h3>
<p>容器的高度由内容天然地决定，而不是容器自己决定。当明确设置一个元素的高度时，内容可能会溢出容器。当内容在限定区域放不下，渲染到父元素外面时，就会溢出。<br>
用overflow属性可以控制溢出内容的行为，该属性支持以下4个值。</p>
<ul>
<li>visible(默认值)——所有内容可见，即使溢出容器边缘。</li>
<li>hidden——溢出容器内边距边缘的内容被裁剪，无法看见。</li>
<li>scroll——容器出现滚动条，用户可以通过滚动查看剩余内容。在一些操作系统上，即使所有内容都可见，也会出现水平和垂直两种滚动条。不过，在这种情况下，滚动条不可滚动。</li>
<li>auto——只有内容溢出时容器才会出现滚动条。</li>
<li>可以用overflow-x属性单独控制水平方向的溢出，或者用overflow-y控制垂直方向溢出。这些属性支持overflow的所有值，然而同时给x和y指定不同的值，往往会产生难以预料的结果。</li>
</ul>
<h4 id="等高列"> 等高列</h4>
<p>任意一列的内容增加，两列的高度都会增加，同时保持底部对齐。<br>
现代浏览器支持了CSS表格，可以轻松实现等高列，比如IE8+支持display: table,IE10+支持弹性盒子或者Flexbox，都默认支持等高列。</p>
<p>方案一：
用CSS表格布局替代浮动布局。给容器设置display: table，给每一列设置display:table-cell。</p>
<ol>
<li>不像block的元素，默认情况下，显示为table的元素宽度不会扩展到100%，因此需要明确指定宽度(width:100%)。</li>
<li>table-cell元素的外边距失效。</li>
<li>可以用表格元素的border-spacing属性来定义单元格的间距。该属性接受两个长度值：水平间距和垂直间距。但这会产生一个特殊的副作用，间距也会作用于表格的外边缘，导致水平方向无法对齐。</li>
<li>可使用负外边距解决，正的外边距会将容器的边缘往里推，而负的外边距则会将边缘往外拉。在表格容器外面包一个元素，将其左右外边距设置为−1.5em，从而抵消表格容器外侧1.5em的border-spacing。</li>
</ol>
<p>方案二：
给容器设置display: flex，它就变成了一个弹性容器(flex container)，子元素默认等高。你可以给子元素设置宽度和外边距，尽管加起来可能超过100%, Flexbox也能妥善处理。</p>
<h4 id="min-height-max-height"> min-height, max-height</h4>
<ul>
<li>min-height指定一个最小高度。元素至少等于你指定的高度，如果内容太多，浏览器就会允许元素自己扩展高度，以免内容溢出。</li>
<li>max-heght允许元素自然地增高到一个特定界限。如果到达这个界限，元素就不再增高，内容会溢出。</li>
<li>min-width, max-width同理</li>
</ul>
<h4 id="垂直居中内容"> 垂直居中内容</h4>
<p>关于vertical-align：该声明只会影响行内元素或者table-cell元素。</p>
<ul>
<li>对于行内元素，它控制着该元素跟同一行内其他元素之间的对齐关系。比如，可以用它控制一个行内的图片跟相邻的文字对齐。</li>
<li>对于显示为table-cell的元素，vertical-align控制了内容在单元格内的对齐。如果使用CSS表格布局，则可以用vertical-align来实现垂直居中。</li>
</ul>
<p>在容器里让内容居中最好的方式是根据特定场景考虑不同因素。做出判断前，先逐个询问自己以下几个问题，直到找到合适的解决办法。</p>
<ul>
<li>可以用一个自然高度的容器吗？给容器加上相等的上下内边距让内容居中。</li>
<li>容器需要指定高度或者避免使用内边距吗？对容器使用display: table-cell和vertical-align: middle。</li>
<li>可以用Flexbox吗？ 如果不需要支持IE9，可以用Flexbox居中内容。</li>
<li>容器里面的内容只有一行文字吗？设置一个大的行高，让它等于理想的容器高度。这样会让容器高度扩展到能够容纳行高。如果内容不是行内元素，可以设置为inline-block。</li>
<li>容器和内容的高度都知道吗？将内容绝对定位。</li>
<li>不知道内部元素的高度？用绝对定位结合变形(transform)。</li>
<li>还不确定的话，参考howtocenterincss网站。</li>
</ul>
<h3 id="负外边距"> 负外边距</h3>
<p>不同于内边距和边框宽度，外边距可以设置为负值。负外边距有一些特殊用途，比如让元素重叠或者拉伸到比容器还宽。
<img src="/assets/img/minus-margin.png" alt="minus-margin" />
负外边距的具体行为取决于设置在元素的哪边，如图所示。如果设置左边或顶部的负外边距，元素就会相应地向左或向上移动，导致元素与它前面的元素重叠，如果设置右边或者底部的负外边距，并不会移动元素，而是将它后面的元素拉过来。给元素底部加上负外边距并不等同于给它下面的元素顶部加上负外边距。</p>
<h3 id="外边距折叠"> 外边距折叠</h3>
<p>当顶部和/或底部的外边距相邻时，就会重叠，产生单个外边距。这种现象被称作折叠。折叠外边距的大小等于相邻外边距中的最大值。即使两个元素不是相邻的兄弟节点也会产生外边距折叠。在没有其他CSS的影响下，所有相邻的顶部和底部外边距都会折叠。<br>
PS：只有上下外边距会产生折叠，左右外边距不会折叠。折叠外边距就像“个人空间”。如果在公交车站站着两个人，他们每个人都认为较为舒适的个人空间应为3英尺，那么他们就会乐意间隔3英尺，而不必间隔6英尺才让双方满意。</p>
<h3 id="容器内堆叠元素的间距"> 容器内堆叠元素的间距</h3>
<p>容器的内边距和内容的外边距之间的相互作用处理起来很棘手。</p>
<p>例如：容器有1.5em的padding,想将容器内的多个块级元素隔开一个间隙，使用margin-top:.5em。元素之间确实隔开了，但容器顶部1.5em的padding加上第一个元素的.5em margin会导致容器顶部空间过大。</p>
<p>解决方法为：使用兄弟选择器。.button-link+.button-link，这不会选择第一个子元素。<br>
更通用的方法为：猫头鹰选择器。<code>*+*</code>。这会选中页面上有着相同父级的非第一个子元素。</p>
<h2 id="渲染"> 渲染</h2>
<p>浏览器计算好了页面上哪些样式应用于哪些元素上之后，需要把这些样式转化成屏幕上的像素，这个过程叫作渲染(rending)。渲染可以分为三个阶段：布局、绘制和合成。</p>
<h3 id="布局"> 布局</h3>
<p>在第一个阶段布局中，浏览器需要计算每个元素将在屏幕上占多大空间。因为文档流的工作方式，所以一个元素的大小和位置可以影响页面上无数其他元素的大小和位置。</p>
<p>任何时候改变一个元素的宽度或高度，或者调整位置属性(比如top或者left)，元素的布局都会重新计算。如果使用JavaScript在DOM中插入或者移除元素，也会重新计算布局。一旦布局发生改变，浏览器就必须 <strong>重排(reflow)</strong> 页面，重新计算所有其他被移动或者缩放的元素的布局。</p>
<h3 id="绘制"> 绘制</h3>
<p>布局之后是绘制。这个过程就是填充像素：描绘文本，着色图片、边框和阴影。这不会真正显示在屏幕上，而是在内存中绘制。页面各部分生成了很多的<strong>图层(layers)</strong>。</p>
<p>如果改变某个元素的背景颜色，就必须<strong>重新绘制</strong>它。但因为更改背景颜色不会影响到页面上任何元素的位置和大小，所以这种变化不需要重新计算布局。</p>
<p>某些条件下，页面元素会被提取到自己的图层。这时候，它会从页面的其他图层中独立出来单独绘制。浏览器把这个图层发送到计算机的GPU进行绘制，而不是像主图层那样使用主CPU绘制。这就是硬件加速(hardware acceleration)。</p>
<h3 id="合成"> 合成</h3>
<p>在合成(composite)阶段，浏览器收集所有绘制完成的图层，并把它们提取为最终显示在屏幕上的图像。合成过程需要按照特定顺序进行，以确保图层出现重叠时，正确的图层显示在其他图层之上。</p>
<p><strong>opacity和transform</strong>这两个属性如果发生改变，需要的渲染时间就会非常少。当我们修改元素的这两个属性之一时，浏览器就会把元素提升到其自己的绘制图层并使用GPU加速。因为元素存在于自己的图层，所以整个图像变化过程中主图层将不会发生变化，也无须重复的重绘。</p>
<p>因此，处理过渡或者动画的时候，尽量只改变transform和opacity属性。如果有需要，可以修改那些只导致重绘而不会重新布局的属性。只有在没有其他替代方案的时候，再去修改那些影响布局的属性。</p>
<h2 id="css属性建议书写顺序"> css属性建议书写顺序</h2>
<table>
<thead>
<tr>
<th>显示属性</th>
<th>自身属性</th>
<th>文本属性和其他修饰</th>
</tr>
</thead>
<tbody>
<tr>
<td>display</td>
<td>width</td>
<td>font</td>
</tr>
<tr>
<td>visibility</td>
<td>height</td>
<td>text-align</td>
</tr>
<tr>
<td>position</td>
<td>margin</td>
<td>text-decoration</td>
</tr>
<tr>
<td>float</td>
<td>padding</td>
<td>vertical-align</td>
</tr>
<tr>
<td>clear</td>
<td>border</td>
<td>white-space</td>
</tr>
<tr>
<td>list-style</td>
<td>overflow</td>
<td>color</td>
</tr>
<tr>
<td>top</td>
<td>min-width</td>
<td>background</td>
</tr>
</tbody>
</table>
<p>从左到右。</p>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/box-model.png" type="image/png"/>
    </item>
    <item>
      <title>CSS 模块化</title>
      <link>https://kigane.github.io/note/js/css-modular/</link>
      <guid>https://kigane.github.io/note/js/css-modular/</guid>
      <source url="https://kigane.github.io/rss.xml">CSS 模块化</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="模块化css"> 模块化CSS</h2>
<p>是指把页面分割成不同的组成部分，这些组成部分可以在多种上下文中重复使用，并且互相之间没有依赖关系。最终目的是，当我们修改其中一部分CSS时，不会对其他部分产生意料之外的影响。</p>
<h3 id="基础样式"> 基础样式</h3>
<p>每个样式表的开头都要写一些给整个页面使用的通用规则，模块化CSS也不例外。这些规则通常被称为基础样式，其他的样式是构建在这些基础样式之上的。</p>
<details><summary>https://necolas.github.io/normalize.css/</summary>
<div><pre><code><span>/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */</span>

<span>/* Document
   ========================================================================== */</span>

<span>/**
 * 1. Correct the line height in all browsers.
 * 2. Prevent adjustments of font size after orientation changes in iOS.
 */</span>

<span>html</span> <span>{</span>
  <span>line-height</span><span>:</span> 1.15<span>;</span> <span>/* 1 */</span>
  <span>-webkit-text-size-adjust</span><span>:</span> 100%<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/* Sections
   ========================================================================== */</span>

<span>/**
 * Remove the margin in all browsers.
 */</span>

<span>body</span> <span>{</span>
  <span>margin</span><span>:</span> 0<span>;</span>
<span>}</span>

<span>/**
 * Render the `main` element consistently in IE.
 */</span>

<span>main</span> <span>{</span>
  <span>display</span><span>:</span> block<span>;</span>
<span>}</span>

<span>/**
 * Correct the font size and margin on `h1` elements within `section` and
 * `article` contexts in Chrome, Firefox, and Safari.
 */</span>

<span>h1</span> <span>{</span>
  <span>font-size</span><span>:</span> 2em<span>;</span>
  <span>margin</span><span>:</span> 0.67em 0<span>;</span>
<span>}</span>

<span>/* Grouping content
   ========================================================================== */</span>

<span>/**
 * 1. Add the correct box sizing in Firefox.
 * 2. Show the overflow in Edge and IE.
 */</span>

<span>hr</span> <span>{</span>
  <span>box-sizing</span><span>:</span> content-box<span>;</span> <span>/* 1 */</span>
  <span>height</span><span>:</span> 0<span>;</span> <span>/* 1 */</span>
  <span>overflow</span><span>:</span> visible<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd `em` font sizing in all browsers.
 */</span>

<span>pre</span> <span>{</span>
  <span>font-family</span><span>:</span> monospace<span>,</span> monospace<span>;</span> <span>/* 1 */</span>
  <span>font-size</span><span>:</span> 1em<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/* Text-level semantics
   ========================================================================== */</span>

<span>/**
 * Remove the gray background on active links in IE 10.
 */</span>

<span>a</span> <span>{</span>
  <span>background-color</span><span>:</span> transparent<span>;</span>
<span>}</span>

<span>/**
 * 1. Remove the bottom border in Chrome 57-
 * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
 */</span>

<span>abbr[title]</span> <span>{</span>
  <span>border-bottom</span><span>:</span> none<span>;</span> <span>/* 1 */</span>
  <span>text-decoration</span><span>:</span> underline<span>;</span> <span>/* 2 */</span>
  <span>text-decoration</span><span>:</span> underline dotted<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/**
 * Add the correct font weight in Chrome, Edge, and Safari.
 */</span>

<span>b,
strong</span> <span>{</span>
  <span>font-weight</span><span>:</span> bolder<span>;</span>
<span>}</span>

<span>/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd `em` font sizing in all browsers.
 */</span>

<span>code,
kbd,
samp</span> <span>{</span>
  <span>font-family</span><span>:</span> monospace<span>,</span> monospace<span>;</span> <span>/* 1 */</span>
  <span>font-size</span><span>:</span> 1em<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/**
 * Add the correct font size in all browsers.
 */</span>

<span>small</span> <span>{</span>
  <span>font-size</span><span>:</span> 80%<span>;</span>
<span>}</span>

<span>/**
 * Prevent `sub` and `sup` elements from affecting the line height in
 * all browsers.
 */</span>

<span>sub,
sup</span> <span>{</span>
  <span>font-size</span><span>:</span> 75%<span>;</span>
  <span>line-height</span><span>:</span> 0<span>;</span>
  <span>position</span><span>:</span> relative<span>;</span>
  <span>vertical-align</span><span>:</span> baseline<span>;</span>
<span>}</span>

<span>sub</span> <span>{</span>
  <span>bottom</span><span>:</span> -0.25em<span>;</span>
<span>}</span>

<span>sup</span> <span>{</span>
  <span>top</span><span>:</span> -0.5em<span>;</span>
<span>}</span>

<span>/* Embedded content
   ========================================================================== */</span>

<span>/**
 * Remove the border on images inside links in IE 10.
 */</span>

<span>img</span> <span>{</span>
  <span>border-style</span><span>:</span> none<span>;</span>
<span>}</span>

<span>/* Forms
   ========================================================================== */</span>

<span>/**
 * 1. Change the font styles in all browsers.
 * 2. Remove the margin in Firefox and Safari.
 */</span>

<span>button,
input,
optgroup,
select,
textarea</span> <span>{</span>
  <span>font-family</span><span>:</span> inherit<span>;</span> <span>/* 1 */</span>
  <span>font-size</span><span>:</span> 100%<span>;</span> <span>/* 1 */</span>
  <span>line-height</span><span>:</span> 1.15<span>;</span> <span>/* 1 */</span>
  <span>margin</span><span>:</span> 0<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/**
 * Show the overflow in IE.
 * 1. Show the overflow in Edge.
 */</span>

<span>button,
input</span> <span>{</span> <span>/* 1 */</span>
  <span>overflow</span><span>:</span> visible<span>;</span>
<span>}</span>

<span>/**
 * Remove the inheritance of text transform in Edge, Firefox, and IE.
 * 1. Remove the inheritance of text transform in Firefox.
 */</span>

<span>button,
select</span> <span>{</span> <span>/* 1 */</span>
  <span>text-transform</span><span>:</span> none<span>;</span>
<span>}</span>

<span>/**
 * Correct the inability to style clickable types in iOS and Safari.
 */</span>

<span>button,
[type="button"],
[type="reset"],
[type="submit"]</span> <span>{</span>
  <span>-webkit-appearance</span><span>:</span> button<span>;</span>
<span>}</span>

<span>/**
 * Remove the inner border and padding in Firefox.
 */</span>

<span>button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner</span> <span>{</span>
  <span>border-style</span><span>:</span> none<span>;</span>
  <span>padding</span><span>:</span> 0<span>;</span>
<span>}</span>

<span>/**
 * Restore the focus styles unset by the previous rule.
 */</span>

<span>button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring</span> <span>{</span>
  <span>outline</span><span>:</span> 1px dotted ButtonText<span>;</span>
<span>}</span>

<span>/**
 * Correct the padding in Firefox.
 */</span>

<span>fieldset</span> <span>{</span>
  <span>padding</span><span>:</span> 0.35em 0.75em 0.625em<span>;</span>
<span>}</span>

<span>/**
 * 1. Correct the text wrapping in Edge and IE.
 * 2. Correct the color inheritance from `fieldset` elements in IE.
 * 3. Remove the padding so developers are not caught out when they zero out
 *    `fieldset` elements in all browsers.
 */</span>

<span>legend</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span> <span>/* 1 */</span>
  <span>color</span><span>:</span> inherit<span>;</span> <span>/* 2 */</span>
  <span>display</span><span>:</span> table<span>;</span> <span>/* 1 */</span>
  <span>max-width</span><span>:</span> 100%<span>;</span> <span>/* 1 */</span>
  <span>padding</span><span>:</span> 0<span>;</span> <span>/* 3 */</span>
  <span>white-space</span><span>:</span> normal<span>;</span> <span>/* 1 */</span>
<span>}</span>

<span>/**
 * Add the correct vertical alignment in Chrome, Firefox, and Opera.
 */</span>

<span>progress</span> <span>{</span>
  <span>vertical-align</span><span>:</span> baseline<span>;</span>
<span>}</span>

<span>/**
 * Remove the default vertical scrollbar in IE 10+.
 */</span>

<span>textarea</span> <span>{</span>
  <span>overflow</span><span>:</span> auto<span>;</span>
<span>}</span>

<span>/**
 * 1. Add the correct box sizing in IE 10.
 * 2. Remove the padding in IE 10.
 */</span>

<span>[type="checkbox"],
[type="radio"]</span> <span>{</span>
  <span>box-sizing</span><span>:</span> border-box<span>;</span> <span>/* 1 */</span>
  <span>padding</span><span>:</span> 0<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/**
 * Correct the cursor style of increment and decrement buttons in Chrome.
 */</span>

<span>[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button</span> <span>{</span>
  <span>height</span><span>:</span> auto<span>;</span>
<span>}</span>

<span>/**
 * 1. Correct the odd appearance in Chrome and Safari.
 * 2. Correct the outline style in Safari.
 */</span>

<span>[type="search"]</span> <span>{</span>
  <span>-webkit-appearance</span><span>:</span> textfield<span>;</span> <span>/* 1 */</span>
  <span>outline-offset</span><span>:</span> -2px<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/**
 * Remove the inner padding in Chrome and Safari on macOS.
 */</span>

<span>[type="search"]::-webkit-search-decoration</span> <span>{</span>
  <span>-webkit-appearance</span><span>:</span> none<span>;</span>
<span>}</span>

<span>/**
 * 1. Correct the inability to style clickable types in iOS and Safari.
 * 2. Change font properties to `inherit` in Safari.
 */</span>

<span>::-webkit-file-upload-button</span> <span>{</span>
  <span>-webkit-appearance</span><span>:</span> button<span>;</span> <span>/* 1 */</span>
  <span>font</span><span>:</span> inherit<span>;</span> <span>/* 2 */</span>
<span>}</span>

<span>/* Interactive
   ========================================================================== */</span>

<span>/*
 * Add the correct display in Edge, IE 10+, and Firefox.
 */</span>

<span>details</span> <span>{</span>
  <span>display</span><span>:</span> block<span>;</span>
<span>}</span>

<span>/*
 * Add the correct display in all browsers.
 */</span>

<span>summary</span> <span>{</span>
  <span>display</span><span>:</span> list-item<span>;</span>
<span>}</span>

<span>/* Misc
   ========================================================================== */</span>

<span>/**
 * Add the correct display in IE 10+.
 */</span>

<span>template</span> <span>{</span>
  <span>display</span><span>:</span> none<span>;</span>
<span>}</span>

<span>/**
 * Add the correct display in IE 10.
 */</span>

<span>[hidden]</span> <span>{</span>
  <span>display</span><span>:</span> none<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br></div></div></details>
<h3 id="简单的模块组织规则"> 简单的模块组织规则</h3>
<ul>
<li>
<p>模块的选择器由单个类名构成，这非常重要。这样通过给元素添加类名，就可以把这些样式复用到很多场景，比如针对表单输入给用户反馈，提供醒目的帮助文字，或者提醒用户注意免责声明条款等。使用相同的组件，就能产生一套风格一致的UI。</p>
</li>
<li>
<p>要把一个模块所有的代码集中放在同一个地方，这样一个接一个的模块就会组成我们最终的样式表。</p>
</li>
<li>
<p>通过定义一个以模块名称开头的新类名来创建一个修饰符(也叫变体类)。常用的写法是使用两个连字符来表示修饰符，比如message--error。双连字符的写法很容易区分哪部分是模块名称，哪部分是修饰符。</p>
</li>
<li>
<p>当模块需要有不同的外观或者表现的时候，就创建一个可以直接应用到指定元素的修饰符类。比如，写．dropdown--dark，而不是写成page-header.dropdown。通过这种方式，模块本身，并且只能是它本身，可以决定自己的样式表现。其他模块不能进入别的模块内部去修改它。这样一来，深色下拉列表并没有绑定到深层嵌套的HTML结构上，也就可以在页面上需要的地方随意使用。</p>
</li>
<li>
<p>对于多元素模块，如媒体对象。给主容器添加media类名来匹配模块名称。对于容器内的图片和正文，可以使用类名media__image和media__body。这些类名以模块名称开头，后跟双下划线，然后是子元素的名称。</p>
</li>
<li>
<p>模块封装的一个非常重要的原则--单一职责原则（Single Responsibility Principle）。有一条经验：“如果你不得不使用并（或者和）这个词来表述模块的职责，那你可能正在描述多项职责。” 尽可能让一个模块只负责一项职责。</p>
</li>
<li>
<p>应该尽量让需要定位的元素关联到同一个模块内的其他元素。只有这样，我们把模块放在另一个有定位的容器里的时候，才不会弄乱样式。</p>
</li>
<li>
<p>状态类（state class）代表着模块在当前状态下的表现。通常在模块里使用JavaScript动态地添加或移除它。按照惯例，状态类一般以is-或者has-开头。这样状态类的目的就会比较明显，它们表示模块当前状态下的一些特征或者即将发生的变化。状态类的代码要和模块的其他代码放在一起。使用JavaScript动态更改模块表现的时候，要使用状态类去触发改变。</p>
</li>
</ul>
<h3 id="预处理器"> 预处理器</h3>
<p>所有的预处理器（比如Sass或者LESS）都提供了把分散的CSS文件合并成一个文件的功能。我们可以用多个文件和多个目录来组织样式，最后提供一个文件给浏览器。这样可以减少浏览器发起的网络请求数，开发者也可以把代码文件拆分成易于维护的大小。
//TODO</p>
<h3 id="工具类"> 工具类</h3>
<p>有时候，我们需要用一个类来对元素做一件简单明确的事，比如让文字居中、让元素左浮动，或者清除浮动。这样的类被称为工具类（utility class）。工具类是唯一应该使用important注释的地方。事实上，工具类应该优先使用它。这样的话，不管在哪里用到工具类，都可以生效。</p>
<p>工具类的作用立竿见影。在页面上做点小事儿的时候不需要创建一个完整的模块，这种情况下可以用一个工具类来实现。但是不要滥用工具类。对于大部分网站，最多十几个工具类就够用了。</p>
<details><summary>示例</summary>
<div><pre><code><span>.text-center</span> <span>{</span>
  <span>text-align</span><span>:</span> center <span>!important</span><span>;</span>
<span>}</span>

<span>.float-left</span> <span>{</span>
  <span>float</span><span>:</span> left<span>;</span>
<span>}</span>

<span>.clearfix::before,
.clearfix::after</span> <span>{</span>
    <span>content</span><span>:</span> <span>" "</span><span>;</span>
    <span>display</span><span>:</span> table<span>;</span>
<span>}</span>

<span>.clearfix::after</span> <span>{</span>
    <span>clear</span><span>:</span> both<span>;</span>
<span>}</span>

<span>.hidden</span> <span>{</span>
  <span>display</span><span>:</span> none <span>!important</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>
<h2 id="模式库"> 模式库</h2>
<p>把模块清单整合成一组文档，在大型项目中已经成为通用做法。这组文档被称为模式库（pattern library）或者样式指南（style guide）。模式库不是网站或者应用程序的一部分，它是单独的一组HTML页面，用来展示每个CSS模块。模式库是你和你的团队在建站的时候使用的一个开发工具。</p>
<h3 id="kss"> KSS</h3>
<p>一个模式库构建工具。</p>
<ol>
<li>创建项目文件夹</li>
<li>npm init -y 初始化项目</li>
<li>npm install --save-dev kss 安装KSS</li>
<li>配置KSS配置文件</li>
</ol>
<ul>
<li>新建kss-config.json</li>
<li>在package.json中添加一条构建命令 <code>&quot;build&quot;: &quot;kss --config kss-config.json&quot;</code></li>
</ul>
<ol start="5">
<li>编写KSS文档</li>
<li>npm run build 构建KSS模式库</li>
</ol>
<details><summary>kss-config.json</summary>
<div><pre><code><span>{</span>
  <span>"title"</span><span>:</span> <span>"My pattern library"</span><span>,</span>
  <span>"source"</span><span>:</span> <span>[</span>
    <span>"./css"</span> <span>// KSS将扫描的CSS源文件路径</span>
    <span>// 如果使用了预处理器，比如SASS或者Less，源文件目录应该指向SASS或者Less文件，</span>
    <span>// 但是css字段应该指向编译生成的CSS样式表。</span>
  <span>]</span><span>,</span>
  <span>"destination"</span><span>:</span>  <span>"docs/"</span><span>,</span> <span>// 生成的模式库文件路径</span>
  <span>"css"</span><span>:</span> <span>[</span>
    <span>"../css/styles.css"</span> <span>// 相对于destination路径的css文件路径</span>
  <span>]</span><span>,</span>
  <span>"js"</span><span>:</span> <span>[</span>
    <span>"../js/docs.js"</span> <span>// 相对于destination路径的js文件路径</span>
  <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></details>
<h3 id="编写kss文档"> 编写KSS文档</h3>
<p>KSS会按照特定的方式在样式表中搜寻注释。注释中包含了标题（通常是模块名称）、描述信息、示例HTML代码和用来表示该模块在目录中位置的Styleguide注释。这几个部分之间通过空白行彼此间隔，便于KSS区分它们。严格来讲，只有最后的Styleguide注释是KSS必需的，如果没有这一行，KSS就会忽略整个注释块。</p>
<div><pre><code><span>/*
Dropdown  // 文档标题

// 一些描述，使用Markdown语法
A dropdown menu. Clicking the toggle button opens
and closes the drawer.

Use JavaScript to toggle the `is-open` class in
order to open and close the dropdown.

Markup: // 用来举例说明模块的用法。KSS把这些HTML转化成模式库，以便读者预览效果，复制粘贴。
&lt;div>
  &lt;button>Open menu&lt;/button>
  &lt;div>
    Drawer contents
  &lt;/div>
&lt;/div>

Styleguide Dropdown // 在KSS目录中出现的名字，最多可有三级，写法为 one.two.three。可用于分组
*/</span>
<span>.dropdown</span> <span>{</span>
  ...
<span>}</span>
...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><p>注意</p>
<p>要牢记HTML片段中不能有空白行，因为对KSS来讲，空白行就意味着markup这部分结束了。<br>
KSS生成新页面的时候不会主动删除旧页面。如果重命名或者移动源码中的一部分文档，docs目录下的相应文件还在原地，与新文件共存。</p>
</div>
<hr>
<p>KSS提供了阐述多重变体的方法，可以在模式库里把每个都渲染出来。<br>
<code>{{modifier_class}}</code>注释指明修饰符类所属的位置。Markup后面一段则为可用修饰符列表。</p>
<div><pre><code><span>/*
Buttons

Buttons are available in a number of sizes and
colors. You may mix and match any size with any
color.

Markup:
&lt;button>
  click here
&lt;/button>

.button--success  - A green success button
.button--danger   - A red danger button
.button--small    - A small button
.button--large    - A large button

Styleguide Buttons
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><hr>
<p>概览文件<br>
模式库的主页。在css目录下面新建一个名为homepage.md的文件。这是一个markdown格式的文件，用来整体介绍模式库。</p>
<div><p>注意</p>
<p>你可能会注意到目录中Overview链接仍然不能工作，因为现在是在磁盘上直接打开模式库文件，KSS把Overview链接指向了．/而不是index.html。要解决这个问题，我们需要通过HTTP服务器访问模式库，这样．/在浏览器里会链接到index.html。</p>
</div>
<hr>
<p>JS<br>
有些模块需要JavaScript配合一起工作。这时候，要为页面添加一些简单的JavaScript来演示模块的行为。没必要在模式库里引入一个功能齐全的JavaScript库。大多数情况下，切换不同的状态类就够了。<br>
KSS会把js数组里列出的所有脚本文件都添加到页面上。我们可以把代码写到这些脚本文件中，为模块提供最基本的功能。</p>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>var</span> dropdowns <span>=</span> document<span>.</span><span>querySelectorAll</span><span>(</span><span>'.dropdown__toggle'</span><span>)</span><span>;</span>
  <span>Array</span><span>.</span>prototype<span>.</span><span>forEach</span><span>.</span><span>call</span><span>(</span>dropdowns<span>,</span> <span>function</span><span>(</span><span>dropdown</span><span>)</span> <span>{</span>
    dropdown<span>.</span><span>addEventListener</span><span>(</span><span>'click'</span><span>,</span> <span>function</span> <span>(</span><span>event</span><span>)</span> <span>{</span>
      event<span>.</span>target<span>.</span>parentNode<span>.</span>classList<span>.</span><span>toggle</span><span>(</span><span>'is-open'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CSS布局</title>
      <link>https://kigane.github.io/note/js/css-layout/</link>
      <guid>https://kigane.github.io/note/js/css-layout/</guid>
      <source url="https://kigane.github.io/rss.xml">CSS布局</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="浮动布局"> 浮动布局</h2>
<p>要实现将图片移动到网页一侧，并且让文字围绕图片的效果，浮动是唯一的方法。这也是设计浮动的初衷。</p>
<h3 id="双容器模式"> 双容器模式</h3>
<p>通过将内容放置到两个嵌套的容器中，然后给内层的容器设置外边距，让它在外层容器中居中。</p>
<details><summary>示例代码</summary>
<p>双容器外层为body，内层为.container</p>
<div><pre><code><span><span>&lt;!</span><span>doctype</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
    <span>/* 全局设置为border-box */</span>
    <span>:root</span> <span>{</span>
      <span>box-sizing</span><span>:</span> border-box<span>;</span>
    <span>}</span>

    <span>*,
    ::before,
    ::after</span> <span>{</span>
      <span>box-sizing</span><span>:</span> inherit<span>;</span>
    <span>}</span>

    <span>body</span> <span>{</span>
      <span>background-color</span><span>:</span> #eee<span>;</span>
      <span>font-family</span><span>:</span> Helvetica<span>,</span> Arial<span>,</span> sans-serif<span>;</span>
    <span>}</span>

    <span>/* 猫头鹰选择器 */</span>
    <span>body * + *</span> <span>{</span>
      <span>margin-top</span><span>:</span> 1.5em<span>;</span>
    <span>}</span>

    <span>header</span> <span>{</span>
      <span>padding</span><span>:</span> 1em 1.5em<span>;</span>
      <span>color</span><span>:</span> #fff<span>;</span>
      <span>background-color</span><span>:</span> #0072b0<span>;</span>
      <span>border-radius</span><span>:</span> .5em<span>;</span>
      <span>margin-bottom</span><span>:</span> 1.5em<span>;</span>
    <span>}</span>

    <span>.main</span> <span>{</span>
      <span>padding</span><span>:</span> 0 1.5em<span>;</span>
      <span>background-color</span><span>:</span> #fff<span>;</span>
      <span>border-radius</span><span>:</span> .5em<span>;</span>
    <span>}</span>

    <span>.container</span> <span>{</span>
      <span>max-width</span><span>:</span> 1080px<span>;</span>
      <span>margin</span><span>:</span> 0 auto<span>;</span>
    <span>}</span>

  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>header</span><span>></span></span>
      <span><span><span>&lt;</span>h1</span><span>></span></span>Franklin Running Club<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;/</span>header</span><span>></span></span>

    <span><span><span>&lt;</span>main</span> <span>class</span><span><span>=</span><span>"</span>main clearfix<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>h2</span><span>></span></span>Running tips<span><span><span>&lt;/</span>h2</span><span>></span></span>

      <span><span><span>&lt;</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>img</span> <span>class</span><span><span>=</span><span>"</span>media-image<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>shoes.png<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media-body<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>h4</span><span>></span></span>Strength<span><span><span>&lt;/</span>h4</span><span>></span></span>
            <span><span><span>&lt;</span>p</span><span>></span></span>
              Strength training is an important part of
              injury prevention. Focus on your core<span title="&mdash;">&amp;mdash;</span>
              especially your abs and glutes.
            <span><span><span>&lt;/</span>p</span><span>></span></span>
          <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>img</span> <span>class</span><span><span>=</span><span>"</span>media-image<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>runner.png<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media-body<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>h4</span><span>></span></span>Cadence<span><span><span>&lt;/</span>h4</span><span>></span></span>
            <span><span><span>&lt;</span>p</span><span>></span></span>
              Check your stride turnover. The most efficient
              runners take about 180 steps per minute.
            <span><span><span>&lt;/</span>p</span><span>></span></span>
          <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>img</span> <span>class</span><span><span>=</span><span>"</span>media-image<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>runner.png<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media-body<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>h4</span><span>></span></span>Change it up<span><span><span>&lt;/</span>h4</span><span>></span></span>
            <span><span><span>&lt;</span>p</span><span>></span></span>
              Don't run the same every time you hit the
              road. Vary your pace, and vary the distance
              of your runs.
            <span><span><span>&lt;/</span>p</span><span>></span></span>
          <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>

        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>img</span> <span>class</span><span><span>=</span><span>"</span>media-image<span>"</span></span> <span>src</span><span><span>=</span><span>"</span>shoes.png<span>"</span></span><span>></span></span>
          <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>media-body<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>h4</span><span>></span></span>Focus on form<span><span><span>&lt;/</span>h4</span><span>></span></span>
            <span><span><span>&lt;</span>p</span><span>></span></span>
              Run tall but relaxed. Your feet should hit
              the ground beneath your hips, not out in
              front of you.
            <span><span><span>&lt;/</span>p</span><span>></span></span>
          <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>

      <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;/</span>main</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br></div></div></details>
<h3 id="容器折叠"> 容器折叠</h3>
<p>浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。这会造成容器折叠问题(容器内所有元素都浮动了，容器的高度就撑不开)。</p>
<p>解决方案1<br>
因为浮动元素的外边距不会折叠到清除浮动容器的外部，非浮动元素的外边距则会正常折叠。所以h2和.container的外边距折叠了，h2的内容紧贴在容器顶部。</p>
<div><pre><code><span>.clearfix::after</span> <span>{</span>
    <span>display</span><span>:</span> block<span>;</span> <span>/* clear只对块级元素有效。 */</span>
    <span>content</span><span>:</span> <span>" "</span><span>;</span> <span>/* 设置content让伪元素出现在文档中 */</span>
    <span>clear</span><span>:</span> both<span>;</span> <span>/* clear: both声明让该元素移动到浮动元素的下面，而不是侧面。clear的值还可以设置为left或者right，这样只会相应地清除向左或者向右浮动的元素。因为空div本身没有浮动，所以容器就会扩展，直到包含它，因此也会包含该div上面的浮动元素。 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>解决方案2<br>
使用display: table能够包含外边距，是因为利用了CSS的一些特性。创建一个display: table元素，也就在元素内隐式创建了一个表格行和一个单元格。外边距无法通过单元格元素折叠，从而所有子元素的外边距都会包含在容器的顶部和底部之间。</p>
<div><pre><code><span>.clearfix::before,
.clearfix::after</span> <span>{</span>
    <span>display</span><span>:</span> table<span>;</span>
    <span>content</span><span>:</span> <span>" "</span><span>;</span>
<span>}</span>
<span>.clearfix::after</span> <span>{</span>
    <span>clear</span><span>:</span> both<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="浮动陷阱"> 浮动陷阱</h3>
<p>第一个元素下有很大一片空白。
<img src="/assets/img/float-trap.png" alt="浮动陷阱" /></p>
<p>要想修复这个问题很简单：清除第三个浮动元素上面的浮动。更通用的做法是，清除每行的第一个元素上面的浮动。</p>
<div><pre><code><span>.media</span> <span>{</span>
    <span>float</span><span>:</span> left<span>;</span>
    <span>margin</span><span>:</span> 0 1.5em 1.5em 0<span>;</span> <span>/* 猫头鹰选择器会导致第一个元素没有margin-top，从而第一行顶端对不齐。故重设 */</span>
    <span>width</span><span>:</span> <span>calc</span><span>(</span>50% - 1.5em<span>)</span><span>;</span> <span>/* 为margin留出空间 */</span>
    <span>padding</span><span>:</span> 1.5em<span>;</span>
    <span>background-color</span><span>:</span> #eee<span>;</span>
    <span>border-radius</span><span>:</span> 0.5em<span>;</span>
<span>}</span>

<span>/* 清除每行的第一个元素上面的浮动 */</span>
<span>.media:nth-child(odd)</span> <span>{</span>
    <span>clear</span><span>:</span> left<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="媒体对象"> 媒体对象</h3>
<p>图片在一侧，一段文字出现在图片的旁边。这是一种很典型的网页布局，称为“媒体对象”。<br>
块级格式化上下文(block formatting context, BFC)<br>
BFC是网页的一块区域，元素基于这块区域布局。虽然BFC本身是环绕文档流的一部分，但它将内部的内容与外部的上下文隔离开。这种隔离为创建BFC的元素做出了以下3件事情。</p>
<ol>
<li>包含了内部所有元素的上下外边距。它们不会跟BFC外面的元素产生外边距折叠。</li>
<li>包含了内部所有的浮动元素。</li>
<li>不会跟BFC外面的浮动元素重叠。</li>
</ol>
<hr>
<p>给元素添加以下的任意属性值都会创建BFC。</p>
<ul>
<li>float: left或right，不为none即可。</li>
<li>overflow:hidden、auto或scroll，不为visible即可。最简单，推荐使用。</li>
<li>display:inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥有这些属性的元素称为块级容器。</li>
<li>position:absolute或position: fixed。</li>
</ul>
<h3 id="网格系统"> 网格系统</h3>
<p>大部分流行的CSS框架包含了自己的网格系统。它们的实现细节各不相同，但是设计思想相同：在一个行容器里放置一个或多个列容器。列容器的类决定每列的宽度。</p>
<ul>
<li>通常网格系统的每行被划分为特定数量的列，一般是12个，但也可以是其他数。每行子元素的宽度可能等于1~12个列的宽度。</li>
<li>行元素负责清除浮动，设置负外边距调整列头尾对齐，等等。</li>
<li>列元素都浮动，用百分比宽度+不同类控制列宽(<code>.column-n{width:xx%}</code>)。column-</li>
</ul>
<h2 id="flexbox"> Flexbox</h2>
<ul>
<li>给元素添加display: flex，该元素变成了一个弹性容器(flex container)，它的直接子元素变成了弹性子元素(flex item)。</li>
<li>弹性子元素默认是在同一行按照从左到右的顺序并排排列。</li>
<li>弹性容器像块元素一样填满可用宽度，但是弹性子元素不一定填满其弹性容器的宽度。</li>
<li>弹性子元素高度相等，该高度由它们的内容决定。</li>
<li>子元素按照主轴线排列，主轴的方向为主起点(左)到主终点(右)。垂直于主轴的是副轴。方向从副起点(上)到副终点(下)。</li>
<li>Flexbox允许使用margin: auto来填充弹性子元素之间所有的可用空间</li>
<li>flex属性控制弹性子元素在主轴方向上的大小,在这里指的元素的宽度。flex属性是三个不同大小属性的简写：flex-grow、flex-shrink和flex-basis。
<ul>
<li>flex-basis：默认值为0%,即不占任何宽度。flex-basis定义了元素大小的基准值，即一个初始的“主尺寸”。flex-basis属性可以设置为任意的width值，包括px、em、百分比。它的初始值是auto，此时浏览器会检查元素是否设置了width属性值。如果有，则使用width的值作为flex-basis的值；如果没有，则用元素内容自身的大小。如果flex-basis的值不是auto, width属性会被忽略。</li>
<li>flex-grow：默认值为1。每个弹性子元素的flex-basis值计算出来后，它们(加上子元素之间的外边距)加起来会占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，可能会有留白。多出来的留白(或剩余宽度)会按照flex-grow(增长因子)的值分配给每个弹性子元素，flex-grow的值为<strong>非负整数</strong>。如果一个弹性子元素的flex-grow值为0，那么它的宽度不会超过flex-basis的值；如果某个弹性子元素的增长因子非0，那么这些元素会增长到所有的剩余空间被分配(按给定的权重分配)完，也就意味着弹性子元素会填满容器的宽度。</li>
<li>flex-shrink：默认值为1。lex-shrink属性与flex-grow遵循相似的原则。计算出弹性子元素的初始主尺寸后，它们的累加值可能会超出弹性容器的可用宽度。如果不用flex-shrink，就会导致溢出。每个子元素的flex-shrink值代表了它是否应该收缩以防止溢出。如果某个子元素为flex-shrink: 0，则不会收缩；如果值大于0，则会收缩至不再溢出。按照flex-shrink值的比例，值越大的元素收缩得越多。</li>
<li>PS:当flex-basis为0%时，内边距会改变弹性子元素的初始主宽度计算的方式。
<img src="/assets/img/flux-layout-example.png" alt="examples" /></li>
</ul>
</li>
<li>Flexbox的另一个重要功能是能用弹性容器的flex-direction属性切换主副轴方向。它的初始值(row)控制子元素按从左到右的方向排列；指定flex-direction: column能控制弹性子元素沿垂直方向排列(从上到下)。Flexbox还支持row-reverse让元素从右到左排列，column-reverse让元素从下到上排列</li>
</ul>
<h3 id="input"> input</h3>
<ul>
<li>input元素可以是文本和密码输入框以及很多类似的HTML5输入框，比如数字、邮箱、日期输入框。它还可以是看起来完全不一样的输入元素，即单选按钮和复选框。<code>input:not([type=checkbox]):not([type=radio])</code>可以排除单选按钮和复选框。</li>
<li>对input设置了display: block，让它们单独占据一行，还要将其宽度设置为100%。通常情况下，块级元素会自动填满可用宽度，但是input比较特殊，其宽度由size属性决定，而它表示不出滚动条的情况下大致能容纳的字符数量。如果不指定的话，该属性就会恢复为默认值。</li>
</ul>
<h3 id="更多属性"> 更多属性</h3>
<p>flex-container
<img src="/assets/img/flex-more1.png" alt="flex-container" />
flex-item
<img src="/assets/img/flex-more2.png" alt="flex-item" /></p>
<h2 id="网格布局"> 网格布局</h2>
<ul>
<li>跟Flexbox类似，网格布局也是作用于两级的DOM结构。设置为display: grid的元素成为一个网格容器(grid container)。它的子元素则变成网格元素(griditems)。容器会表现得像一个块级元素，100%填充可用宽度。</li>
<li>容器的grid-template-columns和grid-template-rows。这两个属性定义了网格每行每列的大小。新单位fr，代表每一列(或每一行)的分数单位(fraction unit)。这个单位跟Flexbox中flex-grow因子的表现一样。</li>
<li>容器的grid-gap属性定义了每个网格单元之间的间距。也可以用两个值分别指定垂直和水平方向的间距(比如grid-gap: 0.5em 1em)。</li>
</ul>
<hr>
<ul>
<li>网格的组成部分
<ul>
<li>网格线(grid line)——网格线构成了网格的框架。一条网格线可以水平或垂直，也可以位于一行或一列的任意一侧。如果指定了grid-gap的话，它就位于网格线上。</li>
<li>网格轨道(grid track)——一个网格轨道是两条相邻网格线之间的空间。网格有水平轨道(行)和垂直轨道(列)。</li>
<li>网格单元(grid cell)——网格上的单个空间，水平和垂直的网格轨道交叉重叠的部分。</li>
<li>网格区域(grid area)——网格上的矩形区域，由一个到多个网格单元组成。该区域位于两条垂直网格线和两条水平网格线之间。</li>
<li>repeat(num, pat1, ...)：将pat重复num次。类似宏。例如，repeat(4, auto) === auto auto auto auto。</li>
</ul>
</li>
<li>网格线编号从左上角为1开始递增，负数则指向从右下角开始的位置。</li>
<li>网格元素定位：
<ul>
<li>grid-column, grid-row：两个属性，有四个值，代表四个网格线，切出的封闭矩形即为元素占据的区域。例如：grid-column:1/3; grid-row:2/4;在九宫格中代表左下四个格子。</li>
<li>span n 表示扩展至n格。例如，grid-row:span 1 表示在水平网格轨道只占一格。</li>
</ul>
</li>
<li>另一种定位方式--使用命名的网格区域
<ul>
<li>grid-template-areas属性：值为一系列加引号字符串，每一个字符串代表网格的一行，字符串内用空格区分每一列。在CSS中画一个可视化的网格形象。句点，代表留空。必须每个网格都要命名。</li>
<li>例如<code>&quot;title title&quot;\n &quot;nav nav&quot;\n &quot;main aside1&quot;\n &quot;main aside2&quot;\n</code></li>
</ul>
</li>
<li>和Flex的对比：
<ul>
<li>Flexbox本质上是一维的，而网格是二维的。</li>
<li>Flexbox是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的。用网格给网页的主区域定位是因为我们希望内容能限制在它所在的网格内，但是对于网页上的其他元素，比如导航菜单，则允许内容对布局有更大的影响。也就是说，文字多的元素可以宽一些，文字少的元素则可以窄一些。同时这还是一个水平(一维)布局。因此，用Flexbox来处理这些元素更合适。</li>
</ul>
</li>
<li>当设计要求元素在两个维度上都对齐时，使用网格。当只关心一维的元素排列时，使用Flexbox。这意味着网格更适合用于整体的网页布局，而Flexbox更适合对网格区域内的特定元素布局。</li>
</ul>
<hr>
<ul>
<li>
<p>隐式网格(implicit grid)。使用grid-template-*属性定义网格轨道时，创建的是显式网格(explicit grid)，但如果网格元素放在声明的网格轨道之外，就会创建隐式轨道以扩展网格，直到包含该元素。</p>
</li>
<li>
<p>隐式网格轨道默认大小为auto，也就是它们会扩展到能容纳网格元素内容。可以给网格容器设置grid-auto-columns和grid-auto-rows，为隐式网格轨道指定一个大小(比如，grid-auto-columns: 1fr)。</p>
</li>
<li>
<p>有时候我们不想给一个网格轨道设置固定尺寸，但是又希望限制它的最小值和最大值。这时候需要用到minmax()函数。它指定两个值：最小尺寸和最大尺寸。浏览器会确保网格轨道的大小介于这两者之间。(如果最大尺寸小于最小尺寸，最大尺寸就会被忽略。)通过指定minmax(200px, 1fr)，浏览器确保了所有的轨道至少宽200px。</p>
</li>
<li>
<p>repeat()函数里的auto-fill关键字是一个特殊值。设置了之后，只要网格放得下，浏览器就会尽可能多地生成轨道，并且不会跟指定大小(minmax()值)的限制产生冲突。</p>
</li>
<li>
<p>auto-fill和minmax(200px, 1fr)加在一起，就会让网格在可用的空间内尽可能多地产生网格列，并且每个列的宽度不会小于200px。因为所有轨道的大小上限都为1fr(最大值)，所以所有的网格轨道都等宽。</p>
</li>
<li>
<p>如果网格元素不够填满所有网格轨道，auto-fill就会导致一些空的网格轨道。如果不希望出现空的网格轨道，可以使用auto-fit关键字代替auto-fill。它会让非空的网格轨道扩展，填满可用空间。</p>
</li>
</ul>
<hr>
<ul>
<li>当不指定网格上元素的位置时，元素会按照其布局算法自动放置。
<ul>
<li>默认情况下，布局算法会按元素在标记中的顺序将其逐列逐行摆放。</li>
<li>grid-auto-flow:row 如果一行放不下，算法会将它移动到下一行，寻找足够大的空间容纳它。</li>
<li>grid-auto-flow:column 如果一列放不下，算法会将它移动到下一列，寻找足够大的空间容纳它。</li>
<li>还可以额外加一个关键字dense(比如，grid-auto-flow: column dense)。它让算法紧凑地填满网格里的空白，尽管这会改变某些网格元素的顺序。</li>
</ul>
</li>
<li>默认情况下，每个网格元素都会扩展并填满整个网格区域，但是子元素不会，因此网格区域可能会出现多余的高度。一个简单的解决办法是用Flexbox。给图片标签加上flex-grow，强制拉伸图片填充空白区域。但是拉伸图片并不可取，因为这会改变图片的宽高比，导致图片变形。好在CSS为控制这一行为提供了一个特殊属性object-fit。默认情况下，一个img的object-fit属性值为fill，也就是说整个图片会缩放，以填满img元素。你也可以设置其他值改变默认行为。
<ul>
<li>cover：扩展图片，让它填满盒子(导致图片一部分被裁剪)。</li>
<li>contain：缩放图片，让它完整地填充盒子(导致盒子里出现空白)。
<img src="/assets/img/img-object-fit.png" alt="图片缩放" /></li>
</ul>
</li>
</ul>
<hr>
<p>对齐</p>
<ul>
<li>CSS给网格布局提供了三个调整属性：justify-content、justify-items、justify-self。这些属性控制了网格元素在水平方向上的位置。</li>
<li>还有三个对齐属性：align-content、align-items、align-self。这些属性控制网格元素在垂直方向上的位置。</li>
</ul>
<h3 id="特性查询"> 特性查询</h3>
<p><code>@supports (display:grid) {...}</code></p>
<ul>
<li>@supports规则后面跟着一个小括号包围的声明。如果浏览器理解这个声明，它就会使用大括号里面的所有样式规则。如果它不理解小括号里的声明，就不会使用这些样式规则。</li>
<li>@supports not(declaration)</li>
<li>@supports (declaration) or (declaration)</li>
<li>@supports (declaration) and (declaration)</li>
</ul>
<h2 id="定位"> 定位</h2>
<p>position属性的初始值是static。前面的章节里用的都是这个静态定位。如果把它改成其他值，我们就说元素就被定位了。而如果元素使用了静态定位，那么就说它未被定位。</p>
<p>前面介绍的布局方法是用各种操作来控制文档流的行为。定位则不同：它将元素彻底从文档流中移走。它允许你将元素放在屏幕的任意位置。还可以将一个元素放在另一个元素的前面或后面，彼此重叠。</p>
<h3 id="固定定位"> 固定定位</h3>
<p>给一个元素设置position: fixed就能将元素放在视口的任意位置。<br>
这需要搭配四种属性一起使用：top、right、bottom和left。这些属性的值决定了固定定位的元素与浏览器视口边缘的距离。比如，top: 3em表示元素的上边缘距离视口顶部3em。<br>
设置这四个值还隐式地定义了元素的宽高。比如指定left: 2em; right: 2em表示元素的左边缘距离视口左边2em，右边缘距离视口右边2em。因此元素的宽度等于视口总宽度减去4em。top、bottom和视口高度也是这样的关系。</p>
<details><summary>模态框背景</summary>
<p>用隐式定义的宽高拉伸空div，再设置背景色。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>modal-backdrop<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.modal-backdrop</span> <span>{</span>
  <span>position</span><span>:</span> fixed<span>;</span>
  <span>top</span><span>:</span> 0<span>;</span>
  <span>right</span><span>:</span> 0<span>;</span>
  <span>bottom</span><span>:</span> 0<span>;</span>
  <span>left</span><span>:</span> 0<span>;</span>
  <span>background-color</span><span>:</span> <span>rgba</span><span>(</span>0<span>,</span> 0<span>,</span> 0<span>,</span> 0.5<span>)</span><span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>
<h3 id="绝对定位"> 绝对定位</h3>
<ul>
<li>固定定位让元素相对视口定位，此时视口被称作元素的包含块(containingblock)。绝对定位的行为也是如此，只是它的包含块不一样。绝对定位不是相对视口，而是相对最近的<strong>祖先定位元素</strong>。</li>
<li>如果祖先元素都没有定位，那么绝对定位的元素会基于初始包含块(initial containing block)来定位。初始包含块跟视口一样大，固定在网页的顶部。</li>
</ul>
<details><summary>关闭按钮</summary>
<p>对于这种Close按钮，用户通常期望看到一个类似于x的图形化显示，如何做到？<br>
你可能首先想到将按钮里的文字close换成x，但是这会导致可访问性的问题：辅助的屏幕阅读器会读按钮里的文字。因此要给这个按钮一些有意义的提示。在使用CSS之前，HTML本身必须有意义。<br>
相反，你可以用CSS隐藏close，并显示x。总共需要两步。</p>
<ol>
<li>将按钮的文字挤到外面，并隐藏溢出内容。   text-indent:xxem+overflow:hidden</li>
<li>将按钮的::after伪元素的content属性设置为x，并让伪元素绝对定位到按钮中间。<br>
PS:乘法符号的Unicode字符更对称，也更好看。HTML字符&amp;times；可以显示为这个字符，但在CSS的content属性里，必须写成转义的Unicode数字：\00D7。</li>
</ol>
</details>
<h3 id="相对定位"> 相对定位</h3>
<p>相对定位将元素从初始位置移走，但是其他元素不受影响(好像被移走的元素还在原来的位置一样)。<br>
跟固定或者绝对定位不一样，不能用top、right、bottom和left改变相对定位元素的大小。这些值只能让元素在上、下、左、右方向移动。可以用top或者bottom，但它们不能一起用(bottom会被忽略)。同理，可以用left或right，但它们也不能一起用(right会被忽略)。<br>
可以用这些属性调整相对元素的位置，把它挤到某个位置，但这只是相对定位的一个冷门用法。更常见的用法是使用position: relative给它里面的绝对定位元素创建一个包含块。</p>
<h3 id="层叠上下文和z-index"> 层叠上下文和z-index</h3>
<p>浏览器将HTML解析为DOM的同时还创建了另一个树形结构，叫作渲染树(render tree)。它代表了每个元素的视觉样式和位置。同时还决定浏览器绘制元素的顺序。</p>
<ul>
<li>顺序很重要，因为如果元素刚好重叠，后绘制的元素就会出现在先绘制的元素前面。</li>
<li>通常情况下(使用定位之前)，元素在HTML里出现的顺序决定了绘制的顺序。</li>
<li>定位元素时，这种行为会改变。浏览器会先绘制所有非定位的元素，然后绘制定位元素。默认情况下，所有的定位元素会出现在非定位元素前面。</li>
<li>通常情况下，模态框要放在网页内容的最后，body关闭标签之前。以防止模态框被其他定位元素遮挡。</li>
<li>z-index属性的值可以是任意整数(正负都行)。z表示的是笛卡儿x-y-z坐标系里的深度方向。拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z-index的元素出现在静态元素后面。
<ul>
<li>z-index只在定位元素上生效，不能用它控制静态元素。</li>
<li>给一个定位元素加上z-index可以创建层叠上下文。</li>
</ul>
</li>
<li>层叠上下文之外的元素无法叠放在层叠上下文内的两个元素之间。例如a有层叠上下文，本身z-index为2，其内有z-index为100的元素，b元素将a完全遮住，z-index为4。渲染出的结果只能看到b，a内的任何元素都会为遮挡。(可以这么理解：2.100 &lt; 4)</li>
<li>所有层叠上下文内的元素会按照以下顺序，从后到前叠放
<ul>
<li>层叠上下文的根</li>
<li>z-index为负的定位元素(及其子元素)</li>
<li>非定位元素</li>
<li>z-index为auto的定位元素(及其子元素)</li>
<li>z-index为正的定位元素(及其子元素)</li>
</ul>
</li>
</ul>
<h3 id="粘性定位"> 粘性定位</h3>
<p>它是相对定位和固定定位的结合体：正常情况下，元素会随着页面滚动，当到达屏幕的特定位置时，如果用户继续滚动，它就会“锁定”在这个位置。最常见的用例是侧边栏导航。</p>
<div><pre><code><span><span><span>&lt;</span>aside</span> <span>class</span><span><span>=</span><span>"</span>col-sidebar<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>affix<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>submenu<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/<span>"</span></span><span>></span></span>Home<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/coffees<span>"</span></span><span>></span></span>Coffees<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/brewers<span>"</span></span><span>></span></span>Brewers<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/specials<span>"</span></span><span>></span></span>Specials<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
      <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/about<span>"</span></span><span>></span></span>About us<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;/</span>ul</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>aside</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.affix</span> <span>{</span>
  <span>position</span><span>:</span> sticky<span>;</span>
  <span>top</span><span>:</span> 1em<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>top值设置了元素最终固定的位置：距离视口的顶部1em。<br>
粘性元素永远不会超出父元素的范围，所以本例中affix不会超出col-sidebar的范围。当滚动页面的时候，col-sidebar会一直正常滚动，但是affix会在滚动到特定位置时停下来。如果继续滚动得足够远，粘性元素还会恢复滚动。这种情况只在父元素的底边到达粘性元素的底边时发生。<br>
注意，只有当父元素的高度大于粘性元素时才会让粘性元素固定</p>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/float-trap.png" type="image/png"/>
    </item>
    <item>
      <title>CSS 预处理器</title>
      <link>https://kigane.github.io/note/js/css-sass/</link>
      <guid>https://kigane.github.io/note/js/css-sass/</guid>
      <source url="https://kigane.github.io/rss.xml">CSS 预处理器</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="sass"> Sass</h2>
<p>预处理器的工作原理是把我们写的源文件转译成输出文件，即常规CSS样式表。</p>
<h3 id="安装"> 安装</h3>
<ol>
<li>新建项目目录并进入</li>
<li>npm init -y 初始化一个新的npm项目，创建package.json文件。</li>
<li>npm install --save-dev node-sass 安装node-sass包，并把它作为开发依赖写入package.json。在Windows系统中，需要先安装node-gyp包。(-g全局安装)</li>
</ol>
<div><p>选择语法</p>
<p>Sass支持两种语法：Sass和SCSS。它们的语言特性一样，但Sass语法去掉了所有的大括号和分号，严格使用缩进来表示代码结构，写法类似python。SCSS语法使用大括号和分号，更像常规CSS。</p>
<p>SCSS文件使用．scss扩展名，Sass文件使用．sass扩展名。</p>
</div>
<h3 id="运行"> 运行</h3>
<ol>
<li>在项目目录新建两个子文件夹，分别叫作sass和build。源文件放在sass文件夹，Sass会使用这些文件来生成CSS文件，并放到build文件夹。</li>
<li>编辑package.json文件，在脚本中添加一条命令<code>&quot;sass&quot;: &quot;sass sass/index.scss build/styles.css&quot;</code>。这样就定义了一条sass命令，运行的时候会把sass/index.scss编译成build/styles.css这个新文件。</li>
<li>写代码，npm run sass，得到styles.css</li>
</ol>
<h3 id="核心特性"> 核心特性</h3>
<p>源scss</p>
<div><pre><code><span><span>$brand-blue</span></span><span>:</span> #0086b3<span>;</span>

<span>a:link </span><span>{</span>
    <span>color</span><span>:</span> <span>$brand-blue</span><span>;</span>
<span>}</span>

<span>.page-heading </span><span>{</span>
    <span>font-size</span><span>:</span> 1.6rem<span>;</span>
    <span>color</span><span>:</span> <span>$brand-blue</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>处理后生成的css</p>
<div><pre><code><span>a:link</span> <span>{</span>
  <span>color</span><span>:</span> #0086b3<span>;</span>
<span>}</span>

<span>.page-heading</span> <span>{</span>
  <span>font-size</span><span>:</span> 1.6rem<span>;</span>
  <span>color</span><span>:</span> #0086b3<span>;</span>
<span>}</span><span>/*# sourceMappingURL=index.css.map */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>源映射</p>
<p>源映射:一个特殊文件(.map)，计算机可以用它来追踪生成后的代码（在我们这里是CSS）中每一行对应的源代码中的那一行（Sass）。这个映射文件可以用在一些调试器中，包括浏览器的开发者工具。</p>
</div>
<h4 id="行内计算"> 行内计算</h4>
<p>Sass支持使用+、-、*、/和%进行行内计算。这样我们就可以从一个初始值获得多个值。这个特性在两个值相关但不同的时候特别有用。</p>
<h4 id="嵌套选择器"> 嵌套选择器</h4>
<p>Sass允许在代码块内嵌套选择器。你可以使用嵌套把有关联的代码分到一组。Sass会把外层声明块的选择器与嵌套选择器合并。默认情况下，外层的选择器会自动添加到编译代码的每个选择器前面，拼接的位置还会插入一个空格。要修改默认操作，可以使用&amp;符号代表外层选择器想要插入的位置。</p>
<div><pre><code><span>.site-nav </span><span>{</span>
    <span>display</span><span>:</span> flex<span>;</span>

    <span>> li </span><span>{</span>
        <span>margin-top</span><span>:</span> 0<span>;</span>

        <span><span>&amp;</span>.is-active </span><span>{</span>
            <span>display</span><span>:</span> block<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>/* 也可以在声明块内嵌套媒体查询 */</span>
<span>html </span><span>{</span>
    <span>font-size</span><span>:</span> 1rem<span>;</span>

    <span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 45em<span>)</span></span> <span>{</span>
        <span>font-size</span><span>:</span> 1.25rem<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>编译后</p>
<div><pre><code><span>.site-nav</span> <span>{</span>
  <span>display</span><span>:</span> flex<span>;</span>
<span>}</span>
<span>.site-nav > li</span> <span>{</span>
  <span>margin-top</span><span>:</span> 0<span>;</span>
<span>}</span>
<span>.site-nav > li.is-active</span> <span>{</span>
  <span>display</span><span>:</span> block<span>;</span>
<span>}</span>

<span>html</span> <span>{</span>
  <span>font-size</span><span>:</span> 1rem<span>;</span>
<span>}</span>
<span><span>@media</span> <span>(</span><span>min-width</span><span>:</span> 45em<span>)</span></span> <span>{</span>
  <span>html</span> <span>{</span>
    <span>font-size</span><span>:</span> 1.25rem<span>;</span>
  <span>}</span>
<span>}</span><span>/*# sourceMappingURL=index.css.map */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="局部文件-import"> 局部文件--@import</h4>
<p>局部文件可以允许你把样式分割成多个独立的文件，Sass会把这些文件拼接在一起生成一个文件。使用局部文件可以按照自己的想法随意组织文件，但最终只提供给浏览器一个文件，这样可以减少网络请求的数量。</p>
<p>将样式文件拆分为一系列局部文件，在index.scss中使用<code>@import &quot;path&quot;</code>引入，运行Sass的时候，局部文件会被编译，然后插入到@import规则指定的地方。相当于C的#include。</p>
<h4 id="混入-mixin"> 混入(mixin)</h4>
<p>混入是一小段CSS代码块，可以在样式表任意地方复用。使用@mixin规则来定义，使用@include规则来调用。例如</p>
<div><pre><code><span>@mixin</span> <span>clrfix </span><span>{</span>
    <span><span>&amp;</span>::before </span><span>{</span>
        <span>display</span><span>:</span> table<span>;</span>
        <span>content</span><span>:</span> <span>" "</span><span>;</span>
    <span>}</span>

    <span><span>&amp;</span>::after </span><span>{</span>
        <span>clear</span><span>:</span> both<span>;</span>
    <span>}</span>
<span>}</span>

<span>.media </span><span>{</span>
    <span>@include</span> clrfix<span>;</span>
    <span>background-color</span><span>:</span> #eee<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>编译后</p>
<div><pre><code><span>.media</span> <span>{</span>
  <span>background-color</span><span>:</span> #eee<span>;</span>
<span>}</span>
<span>.media::before</span> <span>{</span>
  <span>display</span><span>:</span> table<span>;</span>
  <span>content</span><span>:</span> <span>" "</span><span>;</span>
<span>}</span>
<span>.media::after</span> <span>{</span>
  <span>clear</span><span>:</span> both<span>;</span>
<span>}</span><span>/*# sourceMappingURL=index.css.map */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><hr>
<p>还可以定义带参数的混入，就像平时编程中使用的函数一样。</p>
<div><pre><code><span>@mixin</span> <span>alert-color</span><span>(</span><span>$color</span><span>,</span> <span>$bg-color</span><span>)</span> <span>{</span>
    <span>color</span><span>:</span> <span>$color</span><span>;</span>
    <span>background-color</span><span>:</span> <span>$bg-color</span><span>;</span>
<span>}</span>

<span>.media-info </span><span>{</span>
    <span>@include</span> <span>alert-color</span><span>(</span>blue<span>,</span> lightblue<span>)</span><span>;</span>
<span>}</span>
<span>.media-info </span><span>{</span>
    <span>@include</span> <span>alert-color</span><span>(</span>red<span>,</span> pink<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>编译后</p>
<div><pre><code><span>.media-info</span> <span>{</span>
  <span>color</span><span>:</span> blue<span>;</span>
  <span>background-color</span><span>:</span> lightblue<span>;</span>
<span>}</span>

<span>.media-info</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
  <span>background-color</span><span>:</span> pink<span>;</span>
<span>}</span><span>/*# sourceMappingURL=index.css.map */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="扩展-extend"> 扩展(extend)</h4>
<p>sass还支持@extend规则。和mixin类似，但编译方式有所不同。对于扩展，sass不会多次复制相同的声明，而是把选择器组合在一起，这样它们就会包含同样的规则。</p>
<div><pre><code><span>.message </span><span>{</span>
    <span>padding</span><span>:</span> .3em .5em<span>;</span>
    <span>border-radius</span><span>:</span> .5em<span>;</span>
<span>}</span>

<span>.message-info </span><span>{</span>
    <span>@extend</span> .message<span>;</span>
    <span>color</span><span>:</span> blue<span>;</span>
    <span>background-color</span><span>:</span> lightblue<span>;</span>
<span>}</span>

<span>.message-danger </span><span>{</span>
    <span>@extend</span> .message<span>;</span>
    <span>color</span><span>:</span> red<span>;</span>
    <span>background-color</span><span>:</span> pink<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>编译后</p>
<div><pre><code><span>.message, .message-danger, .message-info</span> <span>{</span>
  <span>padding</span><span>:</span> 0.3em 0.5em<span>;</span>
  <span>border-radius</span><span>:</span> 0.5em<span>;</span>
<span>}</span>

<span>.message-info</span> <span>{</span>
  <span>color</span><span>:</span> blue<span>;</span>
  <span>background-color</span><span>:</span> lightblue<span>;</span>
<span>}</span>

<span>.message-danger</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
  <span>background-color</span><span>:</span> pink<span>;</span>
<span>}</span><span>/*# sourceMappingURL=index.css.map */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>Sass复制了．message-info和．message-danger选择器，并上移到第一个规则集。这样做的好处是标记只需要引用一个类，无须两个都引入，从<code>&lt;divclass=&quot;message message-info&quot;&gt;</code>变成了<code>&lt;div class=&quot;message-info&quot;&gt;</code>。</p>
<div><p>提示</p>
<p>@extend的输出长度通常会比mixin短一些。这是显而易见的，也很容易想到@extend更好一些，因为它最终输出的样式表更小（因此网络传输速度更快）。但也要知道mixin产生的大量重复代码，使用gzip可以压缩得比较小。只要你的服务器使用gzip压缩处理过所有的网络传输（当然，也应该这么做），增加的这些重复代码通常会比预期小得多。</p>
</div>
<h4 id="颜色处理"> 颜色处理</h4>
<p>Sass还有个不错的特性，它有一堆处理颜色的函数。<a href="http://jackiebalzer.com/color" target="_blank" rel="noopener noreferrer">参考：AVisual Guide to Sass &amp; Compass Color Functions</a></p>
<h4 id="循环"> 循环</h4>
<p>使用<code>@for $var from start through/to end {}</code></p>
<ul>
<li>through 包括 end</li>
<li>to 不包括 end</li>
</ul>
<div><pre><code><span><span>$base-color</span></span><span>:</span> #036<span>;</span>

<span>@for</span> <span>$i</span> <span>from</span> 1 <span>through</span> <span>3 </span><span>{</span>
  <span>ul</span><span>:</span><span>nth-child</span><span>(</span>3n <span>+</span> <span>#{$i}</span><span>)</span> <span>{</span>
    <span>background-color</span><span>:</span> <span>lighten</span><span>(</span><span>$base-color</span><span>,</span> <span>$i</span> <span>*</span> 5%<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>@for</span> <span>$i</span> <span>from</span> <span>1 to 3 </span><span>{</span>
  <span>ol</span><span>:</span><span>nth-child</span><span>(</span>3n <span>+</span> <span>#{$i}</span><span>)</span> <span>{</span>
    <span>background-color</span><span>:</span> <span>lighten</span><span>(</span><span>$base-color</span><span>,</span> <span>$i</span> <span>*</span> 5%<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>编译后</p>
<div><pre><code><span>ul:nth-child(3n+1)</span> <span>{</span>
  <span>background-color</span><span>:</span> #004080<span>;</span>
<span>}</span>

<span>ul:nth-child(3n+2)</span> <span>{</span>
  <span>background-color</span><span>:</span> #004d99<span>;</span>
<span>}</span>

<span>ul:nth-child(3n+3)</span> <span>{</span>
  <span>background-color</span><span>:</span> #0059b3<span>;</span>
<span>}</span>

<span>ol:nth-child(3n+1)</span> <span>{</span>
  <span>background-color</span><span>:</span> #004080<span>;</span>
<span>}</span>

<span>ol:nth-child(3n+2)</span> <span>{</span>
  <span>background-color</span><span>:</span> #004d99<span>;</span>
<span>}</span><span>/*# sourceMappingURL=index.css.map */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><p>提示</p>
<p>sass中的<code>#{expr}</code>称为Interpolation，用于将sass中的expr值计算出来，嵌入CSS块中。通常用于属性，选择器，@规则，还有例子中的nth-child参数部分等等。而在属性值用<code>#{expr}</code>，等于没用。</p>
</div>
<div><pre><code><span>@mixin</span> <span>corner-icon</span><span>(</span><span>$name</span><span>,</span> <span>$top-or-bottom</span><span>,</span> <span>$left-or-right</span><span>)</span> <span>{</span>
  <span>.icon-<span>#{$name}</span> </span><span>{</span>
    <span>background-image</span><span>:</span> <span>url</span><span>(</span><span>"/icons/#{$name}.svg"</span><span>)</span><span>;</span>
    <span>position</span><span>:</span> absolute<span>;</span>
    <span><span>#{$top-or-bottom}</span></span><span>:</span> 0<span>;</span>
    <span><span>#{$left-or-right}</span></span><span>:</span> 0<span>;</span>
  <span>}</span>
<span>}</span>

<span>@include</span> <span>corner-icon</span><span>(</span><span>"mail"</span><span>,</span> top<span>,</span> left<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>css 小技巧</title>
      <link>https://kigane.github.io/note/js/css-tricks/</link>
      <guid>https://kigane.github.io/note/js/css-tricks/</guid>
      <source url="https://kigane.github.io/rss.xml">css 小技巧</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="背景与边框"> 背景与边框</h2>
<h3 id="透明边框"> 透明边框</h3>
<p>元素的背景默认会占据border+padding+content区域。即background-clip: border-box。<br>
要实现元素背景外有一圈透明边框，需要修改background-clip为padding-box。则背景只占据padding+content区域。再将边框设为透明即可。</p>
<h3 id="多重边框"> 多重边框</h3>
<p>box-shadow:一个正值的扩张半径加上两个为零的偏移量以及为零的模糊值，得到的“投影”其实就像一道实线边框。并且，它支持逗号分隔语法，我们可以创建任意数量的投影。</p>
<div><p>注意</p>
<ol>
<li>box-shadow不会影响布局。所以，需要通过margin或padding模拟边框占据的空间。</li>
<li>box-shadow不会响应鼠标事件，这可以通过使用内圈边框(加 inset 关键字)解决。</li>
</ol>
</div>
<hr>
<p>outline:如果只需要两层边框，那就可以先设置一层常规边框，再加上outline(描边)属性来产生外层的边框。相比于box-shadow只能产生实现边框，outline和border一样，有更多边框样式。<br>
outline-offset:控制outline和border的间距，可以取负值，实现简单的缝边效果。如果负值和border的宽度相同，则两个边框会重合，outline在上。</p>
<div><p>注意</p>
<p>outline不一定会贴合border-radius属性产生的圆角，因此如果元素是圆角的，它的描边可能还是直角的。这种行为被CSS工作组认为是一个bug，因此未来可能会改为贴合border-radius圆角。</p>
</div>
<h3 id="边框内圆角"> 边框内圆角</h3>
<p>使用两个容器，外层设置背景+padding，内层设置border-radius即可。</p>
<h3 id="条纹背景"> 条纹背景</h3>
<p>backgound-img: linear-gradient(...)</p>
<ul>
<li>如果多个色标具有相同的位置，它们会产生一个无限小的过渡区域，过渡的起止色分别是第一个和最后一个指定值。从效果上看，颜色会在那个位置突然变化，而不是一个平滑的渐变过程。</li>
<li>如果某个色标的位置值比整个列表中在它之前的色标的位置值都要小，则该色标的位置值会被设置为它前面所有色标位置值的最大值。</li>
</ul>
<div><pre><code><span>backgound-img</span><span>:</span> <span>linear-gradient</span><span>(</span>to right<span>,</span> black 30%<span>,</span> white 0<span>,</span> white 70%<span>,</span> black 0<span>)</span>  <span>/* 黑白黑 */</span>
</code></pre>
<div><span>1</span><br></div></div><hr>
<p>斜向条纹</p>
<div><pre><code><span>background-image</span><span>:</span> <span>repeating-linear-gradient</span><span>(</span>-45deg<span>,</span> black<span>,</span> black 10px<span>,</span> azure 0<span>,</span> azure 20px<span>)</span><span>;</span>
<span>/*
相当于
linear-gradient(-45deg, 
black, black 10px, azure 0, azure 20px
black 20px, black 30px, azure 0, azure 40px
black 40px, black 50px, azure 0, azure 60px
...)
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="布局"> 布局</h2>
<p>https://1linelayouts.glitch.me/</p>
<h3 id="紧贴底部的页脚"> 紧贴底部的页脚</h3>
<p>想要的效果是，页头和页脚的高度由其内部因素来决定，而内容区块的高度应该可以自动伸展并占满所有的可用空间。</p>
<div><pre><code><span>/*
&lt;div>
    &lt;header>&lt;h1>Site Name&lt;/h1>&lt;/header>
    &lt;main>
        &lt;p>haha There should have some content&lt;/p>
        &lt;p>haha There should have some content&lt;/p>
        &lt;p>haha There should have some content&lt;/p>
    &lt;/main>
    &lt;footer>
        &lt;p>copyright &amp;copy; 2021&lt;/p>
    &lt;/footer>
&lt;/div>
*/</span>

<span>.sf-container</span> <span>{</span>
    <span>display</span><span>:</span> flex<span>;</span>
    <span>flex-direction</span><span>:</span> column<span>;</span>
    <span>min-height</span><span>:</span> 98vh<span>;</span>
<span>}</span>

<span>main</span> <span>{</span>
    <span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="oneline-css"> oneline css</h2>
<h3 id="水平-垂直居中"> 水平，垂直居中</h3>
<div><pre><code><span>.parent</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>place-items</span><span>:</span>center<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="the-deconstructed-pancake"> The Deconstructed Pancake</h3>
<div><pre><code><span>.parent</span> <span>{</span>
    <span>display</span><span>:</span> flex<span>;</span>
    <span>flex-wrap</span><span>:</span> wrap<span>;</span>
    <span>justify-content</span><span>:</span> center<span>;</span>
<span>}</span>

<span>.box</span> <span>{</span>
    <span>flex</span><span>:</span> 1 1 150px<span>;</span> <span>/*  Stretching: */</span>
    <span>/* flex: 0 1 150px;   No stretching: */</span>
    <span>margin</span><span>:</span> 5px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="sidebar"> sidebar</h3>
<p>左侧边栏最小150px，最大25%。其余空间由内容占据。</p>
<div><pre><code><span>.parent</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>grid-template-columns</span><span>:</span> <span>minmax</span><span>(</span>150px<span>,</span> 25%<span>)</span> 1fr<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="pancake-stack"> Pancake Stack</h3>
<p>display:grid中的auto表示元素扩展到能容纳网格元素内容。<br>
fr类似flex中的增长因子。</p>
<div><pre><code><span>.parent</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>grid-template-rows</span><span>:</span> auto 1fr auto<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="经典圣杯布局"> 经典圣杯布局</h3>
<div><pre><code><span>.parent</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>grid-template</span><span>:</span> auto 1fr auto / auto 1fr auto<span>;</span>
<span>}</span>
  
<span>header</span> <span>{</span>
    <span>padding</span><span>:</span> 2rem<span>;</span>
    <span>grid-column</span><span>:</span> 1 / 4<span>;</span>
<span>}</span>

<span>.left-side</span> <span>{</span>
    <span>grid-column</span><span>:</span> 1 / 2<span>;</span>
<span>}</span>

<span>main</span> <span>{</span>
    <span>grid-column</span><span>:</span> 2 / 3<span>;</span>
<span>}</span>

<span>.right-side</span> <span>{</span>
    <span>grid-column</span><span>:</span> 3 / 4<span>;</span>
<span>}</span>

<span>footer</span> <span>{</span>
    <span>grid-column</span><span>:</span> 1 / 4<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="_12-span-网格布局"> 12-span(网格布局)</h3>
<div><pre><code><span>.parent</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>12<span>,</span> 1fr<span>)</span><span>;</span>
<span>}</span>
  
<span>.span-12</span> <span>{</span>
    <span>grid-column</span><span>:</span> 1 / span 12<span>;</span>
<span>}</span>

<span>.span-6</span> <span>{</span>
    <span>grid-column</span><span>:</span> 1 / span 6<span>;</span>
<span>}</span>

<span>.span-4</span> <span>{</span>
    <span>grid-column</span><span>:</span> 4 / span 4<span>;</span>
<span>}</span>

<span>.span-2</span> <span>{</span>
    <span>grid-column</span><span>:</span> 3 / span 2<span>;</span>
<span>}</span>

<span>/* centering text */</span>
<span>.section</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>place-items</span><span>:</span> center<span>;</span>
    <span>text-align</span><span>:</span> center
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="ram"> RAM</h3>
<ul>
<li>auto-fill 会尽可能多的产生网格列，因此，和repeat，minmax合用时，当容器特别宽时，可能会有多余的轨道空出来。</li>
<li>auto-fit 同auto-fill，但当容器特别宽时已有元素或轨道会扩展，直到占满容器宽度。</li>
<li>当容器宽度较小时，两者表现相同。</li>
</ul>
<div><pre><code><span>.parent</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>grid-gap</span><span>:</span> 1rem<span>;</span>
    <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>auto-fit<span>,</span> <span>minmax</span><span>(</span>150px<span>,</span> 1fr<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="回到顶部"> 回到顶部</h2>
<ul>
<li>利用a标签href为#时会自动会到顶部的特性。</li>
<li>css中设置 <code>* { scroll-behavior:smooth }</code></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>JS 基础</title>
      <link>https://kigane.github.io/note/js/js-base/</link>
      <guid>https://kigane.github.io/note/js/js-base/</guid>
      <source url="https://kigane.github.io/rss.xml">JS 基础</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="变量"> 变量</h2>
<p>按照ECMA-262的定义，JavaScript的变量只是在特定时间用于保存特定值的一个名字而已。</p>
<h3 id="变量基础"> 变量基础</h3>
<h4 id="类型"> 类型</h4>
<p>ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。</p>
<ul>
<li>基本类型值指的是简单的数据段：包括 Undefined、Null、Boolean、Number和String 这五种。</li>
<li>引用类型值指那些可能由多个值构成的对象。引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。(创建的对象只不给你直接访问的方式，对对象的所有的操作都是通过指针进行的)</li>
</ul>
<h4 id="值传递"> 值传递</h4>
<p>JavaScript中，变量的赋值，函数的传参都只有一种方式--按值传递。基本类型不必多说。引用类型的“值传递”实际上类似于C/C++中的按指针传递，就是将指针的值复制一份。</p>
<h4 id="类型检测"> 类型检测</h4>
<p>typeof操作符是确定一个变量是字符串、数值、布尔值，还是undefined的最佳工具。对于对象，返回Object。对于函数(实现了<code>[[Call]]</code>方法的对象)，返回Function。</p>
<p>instanceof操作符。用法为：<code>result = variable instanceof Constructor</code>。
如果变量是给定引用类型的实例，就根据它的原型链来识别，即检查variable的原型链中是否存在Constructor.prototype，有则返回true。</p>
<p>根据规定，所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。</p>
<h3 id="执行环境及作用域"> 执行环境及作用域</h3>
<p>执行环境（execution context，也称“环境”）定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p>
<p>全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。</p>
<ul>
<li>在Web浏览器中，全局执行环境被认为是window对象。</li>
<li>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</li>
</ul>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。用于保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（找不到就报错）。
内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数(作用域链是个单向链表🤔)。
<strong>函数参数也被当作变量来对待</strong>，因此其访问规则与执行环境中的其他变量相同。</p>
<h3 id="垃圾收集"> 垃圾收集</h3>
<p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。主要有两种策略</p>
<h4 id="标记清除-mark-and-sweep"> 标记清除（mark-and-sweep）</h4>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后仍有标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<h4 id="引用计数-reference-counting"> 引用计数（reference counting）</h4>
<p>释放那些引用次数为零的值所占用的内存。需要特别小心“循环引用”问题。</p>
<h4 id="性能"> 性能</h4>
<p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。
垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个<strong>临界值</strong>，垃圾收集器就会运行。
如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。(比固定临界值性能好很多)</p>
<h4 id="内存管理"> 内存管理</h4>
<p>一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用</p>
<h2 id="函数"> 函数</h2>
<p>函数声明</p>
<div><pre><code><span>function</span> <span>funcName</span><span>(</span><span>args</span><span>)</span><span>{</span>
    <span>// function body</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>函数表达式</p>
<div><pre><code><span>var</span> <span>func1</span> <span>=</span> <span>function</span><span>(</span><span>args</span><span>)</span><span>{</span>
    <span>// function body</span>
<span>}</span><span>;</span> <span>// 匿名函数 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>一个典型错误</p>
<div><pre><code><span>if</span> <span>(</span>condition<span>)</span>
<span>{</span>
    <span>function</span> <span>sayHi</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"Hi"</span><span>)</span><span>;</span><span>}</span><span>;</span>
<span>}</span>
<span>else</span>
<span>{</span>
    <span>function</span> <span>sayHi</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"Hello"</span><span>)</span><span>;</span><span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>表面上看，以上代码表示在condition为true时，使用一个sayHi()的定义；否则，就使用另一个定义。实际上，这在ECMAScript中属于无效语法，JavaScript引擎会尝试修正错误，将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略condition; Firefox会在condition为true时返回第一个声明。这里用函数表达式就没问题了</p>
<div><pre><code><span>var</span> func<span>;</span>
<span>if</span> <span>(</span>condition<span>)</span>
<span>{</span>
    <span>func</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"Hi"</span><span>)</span><span>;</span><span>}</span><span>;</span>
<span>}</span>
<span>else</span>
<span>{</span>
    <span>func</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"Hello"</span><span>)</span><span>;</span><span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="递归"> 递归</h3>
<p>经典例子+经典错误</p>
<div><pre><code><span>function</span> <span>factorial</span><span>(</span><span>num</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span>num <span>&lt;=</span> <span>1</span><span>)</span><span>{</span><span>return</span> num<span>;</span><span>}</span>
    <span>else</span><span>{</span> <span>return</span> num <span>*</span> <span>factorial</span><span>(</span>num<span>-</span><span>1</span><span>)</span><span>;</span><span>}</span>
    <span>// return num * arguments.callee(num - 1) 即可。</span>
<span>}</span>

<span>var</span> <span>F</span> <span>=</span> factorial<span>;</span>
factorial <span>=</span> <span>null</span><span>;</span>
<span>F</span><span>(</span><span>5</span><span>)</span><span>;</span> <span>// TypeError: factorial is not a function</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>因为，F(5)内部调用的还是factorial(4)，但factorial已经被设为null了。所以在编写递归函数时，应该尽可能使用arguments.callee(arguments.callee是一个指向正在执行的函数的指针)。</p>
<p>但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果</p>
<div><pre><code><span>var</span> factorial <span>=</span> <span>(</span><span>function</span> <span>f</span><span>(</span><span>num</span><span>)</span><span>{</span>
        <span>if</span> <span>(</span>num <span>&lt;=</span> <span>1</span><span>)</span><span>{</span><span>return</span> num<span>;</span><span>}</span>
        <span>else</span><span>{</span> <span>return</span> num <span>*</span> <span>f</span><span>(</span>num<span>-</span><span>1</span><span>)</span><span>;</span><span>}</span>
    <span>}</span><span>)</span><span>;</span>
<span>var</span> <span>F</span> <span>=</span> factorial<span>;</span>
factorial <span>=</span> <span>null</span><span>;</span>
<span>F</span><span>(</span><span>5</span><span>)</span><span>;</span> <span>// 120</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="闭包"> 闭包</h3>
<p><strong>闭包是指有权访问另一个函数作用域中的变量的函数</strong>。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<p>当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。</p>
<p>在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。<strong>当外部函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中</strong>。</p>
<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。虽然像V8等优化后的JavaScript引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包。</p>
<h4 id="经典错误"> 经典错误</h4>
<div><pre><code><span>function</span> <span>createFunc</span><span>(</span><span>)</span><span>{</span>
    <span>var</span> result <span>=</span> <span>new</span> <span>Array</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span>
    <span>{</span>
        result<span>[</span>i<span>]</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>return</span> i<span>}</span><span>;</span>
    <span>}</span>
    <span>return</span> result<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>表面上看，似乎每个函数都应该返自己的索引值，即位置0的函数返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10。因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。
闭包只能取得包含函数中任何变量的最后一个值。</p>
<h4 id="this-对象"> this 对象</h4>
<p>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window。(当然，可以用call, apply修改this对象)</p>
<p><strong>每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</strong></p>
<div><pre><code><span>var</span> name <span>=</span> <span>"The Window"</span><span>;</span>
<span>var</span> object <span>=</span> <span>{</span>
    name<span>:</span> <span>"the object"</span><span>,</span>
    <span>getName</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>this</span><span>.</span>name<span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
object<span>.</span><span>getName</span><span>(</span><span>)</span> <span>// "the object" </span>

<span>var</span> object1 <span>=</span> <span>{</span>
    name<span>:</span> <span>"the object1"</span><span>,</span>
    <span>getName</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>
        <span>return</span> <span>function</span><span>(</span><span>)</span><span>{</span>
            <span>return</span> <span>this</span><span>.</span>name<span>;</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
object1<span>.</span><span>getName</span><span>(</span><span>)</span><span>(</span><span>)</span> <span>// "The Window"</span>

<span>var</span> object2 <span>=</span> <span>{</span>
    name<span>:</span> <span>"the object2"</span><span>,</span>
    <span>getName</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span>
        <span>var</span> that <span>=</span> <span>this</span><span>;</span> <span>// 使用闭包保存了this</span>
        <span>return</span> <span>function</span><span>(</span><span>)</span><span>{</span>
            <span>return</span> that<span>.</span>name<span>;</span>
        <span>}</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
object2<span>.</span><span>getName</span><span>(</span><span>)</span><span>(</span><span>)</span> <span>// "the object2" </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h4 id="闭包引起的内存泄露"> 闭包引起的内存泄露</h4>
<div><pre><code><span>function</span> <span>assignHandler</span><span>(</span><span>)</span><span>{</span>
    <span>var</span> elem <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"some-id"</span><span>)</span><span>;</span>
    elem<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
        <span>alert</span><span>(</span>elem<span>.</span>id<span>)</span><span>;</span>
    <span>}</span><span>;</span> <span>// elem-->DOM元素, DOM元素的onclick是指向闭包，闭包中又有elem。因此产生了循环引用。</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>解决方法是</p>
<div><pre><code><span>function</span> <span>assignHandler</span><span>(</span><span>)</span><span>{</span>
    <span>var</span> elem <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"some-id"</span><span>)</span><span>;</span>
    <span>var</span> id <span>=</span> elem<span>.</span>id<span>;</span>
    elem<span>.</span><span>onclick</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
        <span>alert</span><span>(</span>id<span>)</span><span>;</span>
    <span>}</span><span>;</span> 
    elem <span>=</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="模仿块级作用域"> 模仿块级作用域</h3>
<p>用作块级作用域（通常称为私有作用域）的匿名函数的语法如下：</p>
<div><pre><code><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
    <span>// 这里是块级作用域</span>
<span>}</span><span>)</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号(不能这样<code>function(){}()</code>)。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，只要像上面这样给它加上一对圆括号即可。</p>
<p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。例如</p>
<div><pre><code><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
    <span>var</span> now <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>now<span>.</span><span>getMonth</span><span>(</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> now<span>.</span><span>getDate</span><span>(</span><span>)</span> <span>==</span> <span>1</span><span>)</span><span>{</span>
        <span>alert</span><span>(</span><span>"Happy New Year!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="私有变量和单例模式"> 私有变量和单例模式</h3>
<p>严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。</p>
<p>// TODO</p>
<h3 id="scoped"> <code>[[scoped]]</code></h3>
<p><code>[[scoped]]</code>是Chorme开发者工具内部使用的私有属性，显示了函数可访问的变量(即函数的作用域中的变量)。</p>
<div><pre><code><span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> foo <span>=</span> <span>'foo'</span><span>;</span>
  <span>var</span> obj <span>=</span> <span>{</span>
    <span>bar</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>return</span> foo<span>;</span>
    <span>}</span>
  <span>}</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>obj<span>)</span><span>;</span>
<span>}</span>
<span>a</span><span>(</span><span>)</span><span>;</span>

<span>// obj.bar</span>
<span>// [[Scopes]]: Scopes[2]</span>
<span>// 0: Closure (a)</span>
<span>//   foo: "foo"</span>
<span>// 1: Global</span>
<span>//   (all global variables)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JS 对象</title>
      <link>https://kigane.github.io/note/js/js-object/</link>
      <guid>https://kigane.github.io/note/js/js-object/</guid>
      <source url="https://kigane.github.io/rss.xml">JS 对象</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值，对象或函数。”<br>
简单地说，对象就是一个散列表，包含一系列 key-value 对，其中值可以是数据或函数。</p>
<h2 id="理解对象"> 理解对象</h2>
<p>ECMAScript 中有两类属性(property)：数据属性和访问器属性。<br>
属性的特征由 ECMA 定义的内部特性(attribute)描述。</p>
<h3 id="数据属性的特性"> 数据属性的特性</h3>
<ol>
<li><code>[[Configurable]]</code>：表示
<ul>
<li>能否通过 delete 删除属性从而可以重新定义属性</li>
<li>能否修改属性的特性</li>
<li>能否把属性修改为访问器属性</li>
</ul>
</li>
<li><code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。</li>
<li><code>[[Writable]]</code>：表示能否修改属性的值。</li>
<li><code>[[Value]]</code>：保存这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined。<br>
对于使用字面量直接在对象上定义的属性(<code>var obj = {name: 'jack'}</code>)，<code>[[Configurable]]</code>,<code>[[Enumerable]]</code>,<code>[[Writable]]</code>默认为 true,<code>[[Value]]</code>为设置的值。</li>
</ol>
<h3 id="访问器属性的特性"> 访问器属性的特性</h3>
<p>访问器属性不包含数据值；它们包含一对 getter 和 setter 函数（都非必需）。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性必须用Object.defineProperty()来定义。
访问器属性有如下4个特性。</p>
<ol>
<li><code>[[Configurable]]</code>：表示
<ul>
<li>能否通过 delete 删除属性从而可以重新定义属性</li>
<li>能否修改属性的特性</li>
<li>能否把属性修改为数据属性</li>
</ul>
</li>
<li><code>[[Enumerable]]</code>：表示能否通过 for-in 循环返回属性。</li>
<li><code>[[Get]]</code>：在读取属性时调用的函数。默认值为undefined。</li>
<li><code>[[Set]]</code>：在写入属性时调用的函数。默认值为undefined。
访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。</li>
</ol>
<h3 id="object-defineproperty"> Object.defineProperty()</h3>
<p>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable&amp;value或者get&amp;set。设置其中的一或多个值，可以修改对应的特性值。</p>
<p>设置访问器属性时，可以同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。</p>
<div><p>注意</p>
<p>在调用 Object.defineProperty() 方法时，如果不指定，configurable、enumerable 和 writable 特性的默认值都是 false。而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了，因为它已经不可配置了🤣。通常不用特意将configurable设为true，因为很少会有修改特性的需求。</p>
</div>
<p>ECMAScript 5又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个参数是要添加和修改其属性的对象，第二个参数是一个对象，其属性与第一个对象中要添加或修改的属性一一对应。</p>
<div><pre><code><span>var</span> book <span>=</span> <span>{</span><span>}</span>

Object<span>.</span><span>defineProperties</span><span>(</span>book<span>,</span> <span>{</span>
    _year<span>:</span> <span>{</span>
        writable<span>:</span> <span>true</span><span>,</span>
        value<span>:</span> <span>2000</span>
    <span>}</span><span>,</span>
    edition<span>:</span> <span>{</span>
        writable<span>:</span> <span>true</span><span>,</span>
        value<span>:</span> <span>0</span>
    <span>}</span><span>,</span>
    year<span>:</span> <span>{</span>
        <span>get</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>_year
        <span>}</span><span>,</span>
        <span>set</span><span>:</span> <span>function</span><span>(</span><span>y</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>_year <span>=</span> year
            <span>this</span><span>.</span>edition<span>++</span>
        <span>}</span>
    <span>}</span>
<span>}</span><span>)</span>

<span>// 对book用for-in循环，啥也打印不出来。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>使用ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value。<br>
Object.getOwnPropertyDescriptors(obj)，取得obj的所有属性描述符。</p>
<h2 id="创建对象"> 创建对象</h2>
<p>Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：会产生大量的重复代码。</p>
<div><pre><code><span>var</span> p1 <span>=</span> <span>{</span>
    name<span>:</span> <span>"wyz"</span><span>,</span>
    age<span>:</span> <span>21</span><span>,</span>
    <span>sayHi</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"says Hi"</span><span>)</span><span>}</span>
<span>}</span><span>;</span>
<span>var</span> p2 <span>=</span> <span>{</span>
    name<span>:</span> <span>"gtl"</span><span>,</span>
    age<span>:</span> <span>22</span><span>,</span>
    <span>sayHi</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"says Hi"</span><span>)</span><span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="工厂模式"> 工厂模式</h3>
<div><pre><code><span>function</span> <span>createPerson</span><span>(</span><span>name<span>,</span> age</span><span>)</span>
<span>{</span>
    <span>var</span> o <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
    o<span>.</span>name <span>=</span> name<span>;</span>
    o<span>.</span>age <span>=</span> age<span>;</span>
    o<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"says Hi"</span><span>)</span><span>}</span><span>;</span>
    <span>return</span> o<span>;</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>createPerson</span><span>(</span><span>"wyz"</span><span>,</span> <span>21</span><span>)</span><span>;</span> 
<span>var</span> p2 <span>=</span> <span>createPerson</span><span>(</span><span>"gtl"</span><span>,</span> <span>22</span><span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>工厂模式虽然解决了创建多个相似对象代码重复的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数模式"> 构造函数模式</h3>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span>
<span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>this</span><span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"says Hi"</span><span>)</span><span>}</span><span>;</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"wyz"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"gtl"</span><span>,</span> <span>22</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>注意到构造函数 Person() 的特点</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
</ul>
<p>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）🤔 ；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p>
<div><p>提示</p>
<p>p1和p2都有一个名为sayHi()的方法，但那两个方法不是同一个Function的实例。即 p1.sayHi != p2.sayHi</p>
</div>
<h3 id="原型模式"> 原型模式</h3>
<p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的<strong>所有实例共享</strong>的属性和方法。</p>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>)</span><span>{</span><span>}</span>
<span>Person</span><span>.</span>prototype<span>.</span>name <span>=</span> <span>"wyz"</span><span>;</span>
<span>Person</span><span>.</span>prototype<span>.</span>age <span>=</span> <span>21</span><span>;</span>
<span>Person</span><span>.</span>prototype<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span><span>}</span><span>;</span>

<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
p1<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>;</span> <span>// "wyz"</span>
<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
p2<span>.</span>name <span>=</span> <span>"gtl"</span><span>;</span>
p2<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>;</span> <span>// "gtl"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><p>提示</p>
<p>理解ECMAScript中原型对象的性质：</p>
<ol>
<li>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为<strong>该函数创建一个prototype属性</strong>，这个属性指向(可以理解为指针😏)函数的原型对象。所有原型对象都会默认获得一个constructor属性，这个属性是一个指向prototype属性所属函数的指针（Person.prototype.constructor == Person）。而通过这个构造函数对象，我们还可继续为原型对象添加其他属性和方法。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。</li>
<li>当调用构造函数创建一个新实例后，该<strong>实例的内部将包含一个指针，指向构造函数的原型对象</strong>(p1.__proto__ == Person.prototype)。ECMA-262第5版中管这个指针叫<code>[[Prototype]]</code>。虽然在脚本中没有标准的方式访问<code>[[Prototype]]</code>，但Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__；而在其他实现中，这个属性对脚本则是完全不可见的。</li>
<li>ECMAScript 5增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回<code>[[Prototype]]</code>的值。😂</li>
</ol>
</div>
<h4 id="更简单的原型语法"> 更简单的原型语法</h4>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
<span>var</span> p1 <span>=</span> <span>Person</span><span>(</span><span>)</span><span>;</span> <span>// 把这一行移动到 Person.prototype 赋值后就没问题了</span>
<span>Person</span><span>.</span>prototype <span>=</span> <span>{</span>、
    <span>// constructor: Person, // 最好也加上这行</span>
    name<span>:</span> <span>"wyz"</span><span>,</span>
    age<span>:</span> <span>21</span><span>,</span>
    <span>sayHi</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span><span>}</span>
<span>}</span>
p1<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>;</span> <span>// error p1.__proto__ 指向的老对象没有 sayHi 函数</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>此时，instanceof操作符会返回正确的结果。</p>
<div><p>特别小心</p>
<p>因为 Person.prototype 和 p1.__proto__ 都是指针。经过这样&quot;简单&quot;的赋值之后， Person.prototype 指向新的对象，而 p1.__proto__ 仍然指向原来的原型对象💀。并且，新的对象的 constructor 等于 Object 而不是 Person 了，而且 constructor 的特性 <code>[[enumarable]]</code> 也从默认的 false 变成了 true。</p>
</div>
<h4 id="查找对象属性"> 查找对象属性</h4>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。<br>
也就是说，如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。(就近原则😏)</p>
<div><p>提示</p>
<p>使用hasOwnProperty()方法(从Object继承来的)可以检测一个属性是存在于实例中(返回true)，还是存在于原型中。(加了Own的都只能操作实例本身的属性😄)</p>
</div>
<p>要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5的Object.keys()方法。
如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</p>
<h4 id="原型的动态性"> 原型的动态性</h4>
<p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此</p>
<h4 id="原型模式的缺点"> 原型模式的缺点</h4>
<p>原型模式的最大问题是由其共享的本性所导致的。
原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。</p>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
<span>Person</span><span>.</span>prototype <span>=</span> <span>{</span>
    name<span>:</span> <span>"wyz"</span><span>,</span>
    age<span>:</span> <span>21</span><span>,</span>
    friends<span>:</span> <span>[</span><span>"cl"</span><span>,</span> <span>"gtl"</span><span>]</span><span>,</span>
    <span>sayHi</span><span>:</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span><span>}</span>
<span>}</span>
<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
p1<span>.</span>friends<span>.</span><span>push</span><span>(</span><span>"jiege"</span><span>)</span><span>;</span>
<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span>alert</span><span>(</span>p2<span>.</span>friends<span>)</span><span>;</span> <span>// "cl", "glt", "jiege"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="组合使用构造函数模式和原型模式"> 组合使用构造函数模式和原型模式</h3>
<p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。
这样，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。👏</p>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span>
<span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
<span>}</span>

<span>Person</span><span>.</span>prototype <span>=</span> <span>{</span>
    constructor<span>:</span> Person<span>,</span>
    <span>sayHi</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"wyz"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"gtl"</span><span>,</span> <span>22</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="动态原型模式"> 动态原型模式</h3>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span>
<span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>

    <span>if</span> <span>(</span><span>typeof</span> <span>this</span><span>.</span>sayHi <span>!=</span> <span>"function"</span><span>)</span>
    <span>{</span>
        <span>Person</span><span>.</span>prototype<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"says Hi"</span><span>)</span><span>}</span><span>;</span>
    <span>}</span>
    <span>...</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"wyz"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"gtl"</span><span>,</span> <span>22</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if语句检查每个属性和每个方法；只要检查其中一个即可。</p>
<h3 id="寄生构造函数"> 寄生构造函数</h3>
<p>这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象</p>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span>
<span>{</span>
    <span>var</span> o <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span> <span>// 得到扩充版Object对象(或Array对象等)</span>
    o<span>.</span>name <span>=</span> name<span>;</span>
    o<span>.</span>age <span>=</span> age<span>;</span>
    o<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"says Hi"</span><span>)</span><span>}</span><span>;</span>
    <span>return</span> o<span>;</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"wyz"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"gtl"</span><span>,</span> <span>22</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。</p>
<p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。</p>
<p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。</p>
<h3 id="稳妥构造函数模式"> 稳妥构造函数模式</h3>
<p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。与寄生构造函数模式类似，区别在于实例不用new操作符构造(因此方法不引用this对象)，而且只定义方法，不定义属性。</p>
<div><pre><code><span>function</span> <span>Person</span><span>(</span><span>name<span>,</span> age</span><span>)</span>
<span>{</span>
    <span>var</span> o <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
    <span>// 这里可以定义私有变量和函数。私有变量很安全，只有私有函数能访问。</span>
    o<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span>name<span>)</span><span>}</span><span>;</span>
    <span>return</span> o<span>;</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>Person</span><span>(</span><span>"wyz"</span><span>,</span> <span>21</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>变量p1中保存的是一个稳妥对象，而除了调用sayHi()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。</p>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p>
<h2 id="继承"> 继承</h2>
<h3 id="原型链"> 原型链</h3>
<p>ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
基本模式如下</p>
<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>BaseClass</span><span>(</span><span>)</span><span>{</span><span>this</span><span>.</span>baseProp <span>=</span> <span>"base"</span><span>;</span><span>}</span>
<span>BaseClass</span><span>.</span>prototype<span>.</span><span>baseFunc</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    <span>return</span> <span>this</span><span>.</span>baseProp<span>;</span>
<span>}</span><span>;</span>

<span>function</span> <span>DerivedClass</span><span>(</span><span>)</span><span>{</span><span>this</span><span>.</span>derivedProp <span>=</span> <span>"derived"</span><span>;</span><span>}</span><span>;</span>
<span>// 继承了BaseClass</span>
<span>DerivedClass</span><span>.</span>prototype <span>=</span> <span>new</span> <span>BaseClass</span><span>(</span><span>)</span><span>;</span> <span>// 替换原型必须在添加方法前，否则白加。</span>
<span>DerivedClass</span><span>.</span>prototype<span>.</span><span>derivedFunc</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    <span>return</span> <span>this</span><span>.</span>derivedProp<span>;</span>
<span>}</span><span>;</span>

<span>var</span> instance <span>=</span> <span>new</span> <span>DerivedClass</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>instance<span>.</span><span>baseFunc</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// "base"</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>本例的原型链大概长这样😆
instance.__proto__--&gt;DerivedClass.prototype(即new BaseClass())--&gt;BaseClass.prototype--&gt;Object.prototype</p>
<p>原型链的第一个问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。</p>
<p>原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<h3 id="借用构造函数-constructor-stealing"> 借用构造函数(constructor stealing)</h3>
<p>这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。</p>
<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>Base</span><span>(</span><span>)</span><span>{</span>
    <span>this</span><span>.</span>colors <span>=</span> <span>[</span><span>"red"</span><span>,</span> <span>"green"</span><span>,</span> <span>"blue"</span><span>]</span><span>;</span>
<span>}</span><span>;</span>

<span>function</span> <span>Derived</span><span>(</span><span>)</span><span>{</span>
    <span>// 继承。用 apply(this)也行</span>
    <span>Base</span><span>.</span><span>call</span><span>(</span><span>this</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>var</span> instance1 <span>=</span> <span>new</span> <span>Derived</span><span>(</span><span>)</span><span>;</span>
instance1<span>.</span>colors<span>.</span><span>push</span><span>(</span><span>"black"</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>instance1<span>.</span>colors<span>)</span><span>;</span><span>// 多一个 "black"</span>
<span>var</span> instance2 <span>=</span> <span>new</span> <span>Derived</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>instance1<span>.</span>colors<span>)</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。</p>
<p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code><span>function</span> <span>Base</span><span>(</span><span>name</span><span>)</span><span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
<span>}</span><span>;</span>

<span>function</span> <span>Derived</span><span>(</span><span>)</span><span>{</span>
    <span>// 继承。用 apply(this)也行</span>
    <span>Base</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> <span>"wyz"</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
<span>}</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>这还不够。</p>
<h3 id="组合继承"> 组合继承</h3>
<div><pre><code><span>function</span> <span>Base</span><span>(</span><span>name</span><span>)</span><span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>colors <span>=</span> <span>[</span><span>"red"</span><span>,</span> <span>"green"</span><span>,</span> <span>"blue"</span><span>]</span><span>;</span>
<span>}</span><span>;</span>
<span>Base</span><span>.</span>prototype<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span><span>}</span><span>;</span>

<span>function</span> <span>Derived</span><span>(</span><span>name<span>,</span> age</span><span>)</span><span>{</span>
    <span>// 继承属性</span>
    <span>Base</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>)</span><span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
<span>}</span><span>;</span>
<span>// 继承方法</span>
<span>Derived</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Base</span><span>(</span><span>)</span><span>;</span>
<span>Derived</span><span>.</span>prototype<span>.</span>constructor <span>=</span> Derived<span>;</span>
<span>// 子类定义新方法</span>
<span>Derived</span><span>.</span>prototype<span>.</span><span>printAge</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>age<span>;</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>使用借用构造函数继承属性，使用原型链继承方法。👏👏👏</p>
<h3 id="原型式继承"> 原型式继承</h3>
<div><pre><code><span>function</span> <span>object</span><span>(</span><span>o</span><span>)</span>
<span>{</span>
    <span>function</span> <span>F</span><span>(</span><span>)</span><span>{</span><span>}</span><span>;</span>
    <span>F</span><span>.</span>prototype <span>=</span> o<span>;</span>
    <span>return</span> <span>new</span> <span>F</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。
克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。</p>
<p>ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。</p>
<p>在只想<strong>让一个对象与另一个对象保持类似</strong>的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h3 id="寄生式继承"> 寄生式继承</h3>
<div><pre><code><span>function</span> <span>another</span><span>(</span><span>original</span><span>)</span>
<span>{</span>
    clone <span>=</span> <span>object</span><span>(</span>original<span>)</span><span>;</span>
    clone<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>"Hi"</span><span>)</span><span>}</span><span>;</span>
    <span>return</span> clone<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>another() 返回的对象原型是original，并添加了额外的sayHi()函数。其实就是把添加函数的行为硬编码到函数中去了。</p>
<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
<h3 id="寄生组合式继承"> 寄生组合式继承</h3>
<p>前面说过，组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。<strong>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数</strong>：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性</p>
<p>好在我们已经找到了解决这个问题方法——寄生组合式继承。所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示。</p>
<div><pre><code><span>function</span> <span>inheritPrototype</span><span>(</span><span>Derived<span>,</span> Base</span><span>)</span><span>{</span>
    <span>var</span> prototype <span>=</span> <span>object</span><span>(</span><span>Base</span><span>.</span>prototype<span>)</span><span>;</span>    <span>// 创建对象</span>
    prototype<span>.</span>constructor <span>=</span> Derived<span>;</span> <span>//增强对象</span>
    <span>Derived</span><span>.</span>prototype <span>=</span> prototype<span>;</span>   <span>// 指定对象</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>应用方法</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>function</span> <span>Base</span><span>(</span><span>name</span><span>)</span><span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>colors <span>=</span> <span>[</span><span>"red"</span><span>,</span> <span>"green"</span><span>,</span> <span>"blue"</span><span>]</span><span>;</span>
<span>}</span><span>;</span>
<span>Base</span><span>.</span>prototype<span>.</span><span>sayHi</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>alert</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span><span>}</span><span>;</span>

<span>function</span> <span>Derived</span><span>(</span><span>name<span>,</span> age</span><span>)</span><span>{</span>
    <span>Base</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>)</span><span>;</span>
    <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
<span>}</span><span>;</span>
<span>// 继承方法</span>
<span>inheritPrototype</span><span>(</span>Derived<span>,</span> Base<span>)</span><span>;</span> <span>// 这里省了一个 new Base()</span>
<span>// 子类定义新方法</span>
<span>Derived</span><span>.</span>prototype<span>.</span><span>printAge</span> <span>=</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>age<span>;</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>Derived</span><span>.</span>prototype<span>.</span>__proto__ <span>==</span> <span>Base</span><span>.</span>prototype<span>)</span><span>// true</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
]]></content:encoded>
    </item>
    <item>
      <title>BOM&amp;DOM&amp;Event</title>
      <link>https://kigane.github.io/note/js/js-bom-dom/</link>
      <guid>https://kigane.github.io/note/js/js-bom-dom/</guid>
      <source url="https://kigane.github.io/rss.xml">BOM&amp;DOM&amp;Event</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="bom"> BOM</h2>
<ul>
<li>window
<ul>
<li>window对象是JS的全局对象，所有全局作用域的变量和函数，都会变成window对象的属性和方法。</li>
<li>全局变量和定义在window对象上的属性间的唯一差别是，全局变量不能delete，而window对象上的属性可以。</li>
<li>访问未声明的全局变量会抛出错误，而访问未声明的window对象属性会返回undefined。</li>
<li>页面中每个frame都有自己的window对象，每个window对象都有一个name属性，<code>window.frames[name]</code>可以访问指定frame</li>
<li>window.top对象始终指向最外层的frame，即浏览器窗口。</li>
<li>window.parent指向外层的frame</li>
<li>window.self === window</li>
<li>window.open(url, windowOrFrameName, features, replaceInHistory) 在windowOrFrameName上打开新的url，如果windowOrFrameName不存在，用指定的features创建新窗口。被open的窗口的window.opener指向原窗口，原窗口对被open的窗口一无所知。</li>
<li>对话框：alert, confirm, prompt</li>
</ul>
</li>
<li>location
<ul>
<li>window.location === document.location</li>
<li>location.href 完整的url。</li>
<li>location.host hostname:port</li>
<li>location.hostname</li>
<li>location.port</li>
<li>location.pathname</li>
<li>location.search 以?开头的查询字符串</li>
<li>location.hash url中#+后面部分。除了该属性，修改其他属性都会导致浏览器重新加载。</li>
<li>location.replace(url) 加载新url，原url不会添加到历史记录中。</li>
<li>location.reload(bImpose) 重新加载(false: 可能从缓存中加载，true: 从服务器重新加载)</li>
</ul>
</li>
<li>navigator
<ul>
<li>navigator.cookieEnabled</li>
<li>navigator.userAgent &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36 Edg/93.0.961.38&quot;</li>
</ul>
</li>
<li>history
<ul>
<li>history.back() 回退一页</li>
<li>history.forward() 前进一页</li>
<li>history.go(num) num&gt;0时前进，反之后退。</li>
</ul>
</li>
</ul>
<h3 id="间歇调用和超时调用"> 间歇调用和超时调用</h3>
<ul>
<li>setTimeout(CallBackFn, time-ms) 经过time-ms后将当前任务添加到任务队列中。如果队列为空，则立即执行，否则，等待。</li>
<li>setInterval(CallBackFn, time-ms)</li>
<li>两个函数都会返回一个id标识符，可以调用相应的clearTimeout(id), clearInterval(id)取消调用。</li>
<li>两个函数都是在全局作用域中执行的。无论在哪里调用。</li>
<li>通常很少用setInterval，因为后一个间歇调用可能会在前一个间歇调用结束前启动。</li>
</ul>
<div><pre><code><span>var</span> num <span>=</span> <span>0</span>
<span>var</span> max <span>=</span> <span>10</span>

<span>function</span> <span>incrementNum</span><span>(</span><span>)</span> <span>{</span>
    num<span>++</span>
    <span>if</span> <span>(</span>num <span>&lt;</span> max<span>)</span> <span>{</span>
        <span>setTimeout</span><span>(</span>incrementNum<span>,</span> <span>500</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>alert</span><span>(</span><span>"Done"</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>setTimeout</span><span>(</span>incrementNum<span>,</span> <span>500</span><span>)</span>

<span>// 相当于setInterval(incrementNum, 500)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="event"> Event</h2>
<h3 id="事件流"> 事件流</h3>
<p>事件流描述的是从页面接受事件的顺序。</p>
<ul>
<li>事件冒泡：事件开始时由嵌套最深的元素接收，然后逐级向上传播。</li>
<li>事件捕获：事件开始时由window对象接收，然后逐级向下传播到嵌套最深的元素。</li>
<li>DOM2级事件：规定事件流包括三个阶段
<ul>
<li>事件捕获阶段 1</li>
<li>处于目标阶段 2</li>
<li>事件冒泡阶段 3</li>
</ul>
</li>
</ul>
<h3 id="事件处理程序"> 事件处理程序</h3>
<p>即响应某个事件的函数。</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>Button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>Click Me<span>"</span></span> <span><span>onclick</span><span><span>=</span><span>"</span><span><span>showMessage</span><span>(</span><span>)</span></span><span>"</span></span></span><span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>这里showMessage为事件处理程序调用的函数。在该函数内部，this为事件的目标元素(本例中为input)。</li>
<li>在这个函数作用域内，可以像访问局部变量一样访问document和元素本身的成员。如果当前元素是一个表单元素(在form内)，则作用域中还会包含form元素。</li>
<li>在html中指定事件处理程序可能会有时差问题，即html元素渲染好了，但showMessage函数还不可用，即JS还没执行到。</li>
<li>DOM0级事件处理程序：用JS选中DOM对象中的指定元素，再将一个函数赋给事件处理程序(例如，el.onclick)。</li>
<li>DOM2级事件处理程序：使用
<ul>
<li>addEventListener(eventName, EventCallBackFn, isCapture)</li>
<li>removeEventListener(eventName, EventCallBackFn, isCapture)</li>
<li>isCapture为true，表示在捕获阶段处理事件，为false表示在冒泡阶段处理事件。</li>
<li>remove时的参数必须和add时的参数一模一样。如果add时使用的是匿名函数，则无法remove。</li>
<li>这种方式可以为同一个事件设置多个处理函数。按照添加顺序触发。</li>
</ul>
</li>
</ul>
<h3 id="事件对象"> 事件对象</h3>
<p>浏览器会将event对象传入事件处理程序中。</p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>类型</th>
<th>只读</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>String</td>
<td>Y</td>
<td>事件的类型</td>
</tr>
<tr>
<td>target</td>
<td>Element</td>
<td>Y</td>
<td>事件的目标。(最上层元素？)</td>
</tr>
<tr>
<td>currentTarget</td>
<td>Element</td>
<td>Y</td>
<td>当前正在处理事件的元素。事件处理程序中的this。</td>
</tr>
<tr>
<td>eventPhase</td>
<td>Integer</td>
<td>Y</td>
<td>表明事件处理程序的阶段</td>
</tr>
<tr>
<td>bubbles</td>
<td>Boolean</td>
<td>Y</td>
<td>表明事件是否冒泡</td>
</tr>
<tr>
<td>detail</td>
<td>Integer</td>
<td>Y</td>
<td>事件相关细节信息</td>
</tr>
<tr>
<td>cancelable</td>
<td>Boolean</td>
<td>Y</td>
<td>表明是否可以取消事件的默认行为</td>
</tr>
<tr>
<td>preventDefault()</td>
<td>Function</td>
<td>Y</td>
<td>如果cancelable为true，取消事件的默认行为。</td>
</tr>
<tr>
<td>defaultPrevented</td>
<td>Boolean</td>
<td>Y</td>
<td>为true，说明已经调用了preventDefault()</td>
</tr>
<tr>
<td>stopImmediatePropagation()</td>
<td>Function</td>
<td>Y</td>
<td>取消事件进一步捕获或冒泡，同时阻止任何事件被调用。</td>
</tr>
<tr>
<td>stopPropagation()</td>
<td>Function</td>
<td>Y</td>
<td>如果bubbles为true，取消事件进一步捕获或冒泡。</td>
</tr>
<tr>
<td>trusted</td>
<td>Boolean</td>
<td>Y</td>
<td>为true表明是浏览器生成的，为false表示由JS生成的</td>
</tr>
</tbody>
</table>
<h3 id="事件类型"> 事件类型</h3>
<h4 id="ui事件"> UI事件</h4>
<ul>
<li>load
<ul>
<li>当页面完全加载后（包括所有图像、JavaScript文件、CSS文件等外部资源），就会触发window上面的load事件。</li>
<li>EventUtil.addHandler(window, &quot;load&quot;, function(e) {...})。建议使用。</li>
<li>或在body元素中添加onload属性。</li>
<li>img元素也有load事件，在图片加载完成时触发。</li>
</ul>
</li>
<li>unload：在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件。而利用这个事件最多的情况是清除引用，以避免内存泄漏。</li>
<li>select：当用户选择文本框（<code>&lt;input&gt;</code>或<code>&lt;texterea&gt;</code>）中的一或多个字符时触发。</li>
<li>resize：当窗口或框架的大小变化时在window或框架上面触发。</li>
<li>scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。</li>
<li>resize和scroll触发频率很高。注意代码的简洁。</li>
</ul>
<h4 id="焦点事件"> 焦点事件</h4>
<ul>
<li>blur：在元素失去焦点时触发。这个事件不会冒泡。</li>
<li>focus：在元素获得焦点时触发。不冒泡</li>
<li>focusin：冒泡版focus</li>
<li>focusout：冒泡版blur</li>
</ul>
<h4 id="鼠标和滚轮事件"> 鼠标和滚轮事件</h4>
<ul>
<li>click：在用户单击主鼠标按钮或者按下回车键时触发。</li>
<li>dblclick：在用户双击主鼠标按钮时触发。</li>
<li>mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。</li>
<li>mouseup：在用户释放鼠标按钮时触发。
<ul>
<li>event.button:0表示主鼠标按钮，1表示中间的鼠标滚轮按钮,2表示次鼠标按钮。</li>
</ul>
</li>
<li>mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。</li>
<li>mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。从A元素移动到B元素上，会触发A的mouseout，B的mouseover，A的relatedTarget是B，B的relatedTarget是A。</li>
<li>mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。</li>
<li>事件触发顺序：mousedown-&gt;mouseup-&gt;click-&gt;mousedown-&gt;mouseup-&gt;click-&gt;dbclick</li>
<li>mousewheel：滚动鼠标滚轮时触发。与mousewheel事件对应的event对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性。当用户向前滚动鼠标滚轮时，wheelDelta是120的倍数；当用户向后滚动鼠标滚轮时，wheelDelta是-120的倍数。</li>
</ul>
<hr>
<ul>
<li>视口坐标位置：事件对象的clientX和clientY属性，表示事件发生时鼠标指针在视口中的水平和垂直坐标。</li>
<li>页面坐标位置：事件对象的pageX和pageY属性，能告诉你事件是在页面中的什么位置发生的。</li>
<li>屏幕坐标位置：事件对象的screenX和screenY属性，表示事件发生时鼠标指针相对于整个屏幕的水平和垂直坐标。</li>
<li>修饰键：事件对象的shiftKey、ctrlKey、altKey和metaKey属性，如果相应的键被按下了，则值为true。</li>
</ul>
<h4 id="键盘和文本事件"> 键盘和文本事件</h4>
<ul>
<li>keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。</li>
<li>keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件。</li>
<li>keyup：当用户释放键盘上的键时触发。</li>
<li>textInput：这个事件是对keypress的补充，用意是在将文本显示给用户之前更容易拦截文本。在文本插入文本框之前会触发textInput事件。
<ul>
<li>任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才能触发textInput事件。</li>
<li>textInput事件只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发（例如退格键）。</li>
<li>event.inputMethod
<ul>
<li>0，表示浏览器不确定是怎么输入的。</li>
<li>1，表示是使用键盘输入的。</li>
<li>2，表示文本是粘贴进来的。</li>
<li>3，表示文本是拖放进来的。</li>
<li>4，表示文本是使用IME输入的。</li>
<li>5，表示文本是通过在表单中选择某一项输入的。</li>
<li>6，表示文本是通过手写输入的（比如使用手写笔）。</li>
<li>7，表示文本是通过语音输入的。</li>
<li>8，表示文本是通过几种方法组合输入的。</li>
<li>9，表示文本是通过脚本输入的。</li>
</ul>
</li>
</ul>
</li>
<li>键盘事件与鼠标事件一样，都支持相同的修改键。而且，键盘事件的事件对象中也有shiftKey、ctrlKey、altKey和metaKey属性。</li>
</ul>
<p><img src="/assets/img/js-keycode.png" alt="KeyCode" />
keyCode: 即相应字符对应的ASCII码</p>
<h4 id="变动事件"> 变动事件</h4>
<ul>
<li>DOMSubtreeModified：在DOM结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。</li>
<li>DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。</li>
<li>DOMNodeRemoved：在节点从其父节点中被移除时触发。</li>
<li>DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted之后触发。</li>
<li>DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发。</li>
<li>DOMAttrModified：在特性被修改之后触发。</li>
<li>DOMCharacterDataModified：在文本节点的值发生变化时触发。</li>
</ul>
<h4 id="html5事件"> HTML5事件</h4>
<ul>
<li>contextmenu事件：右键单击时触发，使用event.preventDefalut()取消默认菜单。因为contextmenu事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。通常使用contextmenu事件来显示自定义的上下文菜单，而使用onclick事件处理程序来隐藏该菜单。</li>
<li>DOMContentLoaded事件：在形成完整的DOM树之后就会触发，不理会图像、JavaScript文件、CSS文件或其他资源是否已经下载完毕。</li>
<li>hashchange事件：HTML5新增了hashchange事件，以便在URL的参数列表（及URL中“#”号后面的所有字符串）发生变化时通知开发人员。之所以新增这个事件，是因为在Ajax应用中，开发人员经常要利用URL参数列表来保存状态或导航信息。</li>
</ul>
<h3 id="内存和性能"> 内存和性能</h3>
<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。</p>
<ol>
<li>每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。</li>
<li>必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。</li>
</ol>
<h4 id="事件委托"> 事件委托</h4>
<p>click、mousedown、mouseup、keydown、keyup和keypress事件适合采用事件委托技术。利用了事件冒泡，在事件冒泡到较高层次时统一处理，这样只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<div><pre><code><span>var</span> list <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"#app"</span><span>)</span>

EventUtil<span>.</span><span>addHandler</span><span>(</span>list<span>,</span> <span>"click"</span><span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span><span>{</span>
    event <span>=</span> EventUtil<span>.</span><span>getEvent</span><span>(</span>event<span>)</span><span>;</span>
    <span>var</span> target <span>=</span> EventUtil<span>.</span><span>getTarget</span><span>(</span>event<span>)</span>

    <span>switch</span> <span>(</span>target<span>.</span>id<span>)</span> <span>{</span>
        <span>case</span><span>:</span> <span>"aBtn"</span><span>:</span>
            document<span>.</span>title <span>=</span> <span>"I changed the document's title"</span>
            <span>break</span>
        <span>case</span> <span>"bBtn"</span><span>:</span>
            location<span>.</span>href <span>=</span> <span>"http://www.baidu.com"</span>
            <span>break</span>
        <span>case</span><span>:</span> <span>"cBtn"</span><span>:</span>
            <span>alert</span><span>(</span><span>"Hi"</span><span>)</span>
            <span>break</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="移除事件处理程序"> 移除事件处理程序</h4>
<p>内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成Web应用程序内存与性能问题的主要原因。</p>
<p>在两种情况下，可能会造成上述问题。</p>
<ol>
<li>从文档中移除带有事件处理程序的元素。这可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML替换页面中某一部分的时候。如果带有事件处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。(元素移除了，但事件处理程序还和元素保持着引用关系，浏览器很可能无法处理，而将元素和对事件处理程序的引用都保存在内存中，因而无法通过GC回收)</li>
<li>卸载页面的时候。如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了“刷新”按钮），内存中滞留的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。一般来说，最好的做法是在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序。在此，事件委托技术再次表现出它的优势——需要跟踪的事件处理程序越少，移除它们就越容易。</li>
</ol>
]]></content:encoded>
      <enclosure url="https://kigane.github.io/assets/img/js-keycode.png" type="image/png"/>
    </item>
    <item>
      <title>资源与工具</title>
      <link>https://kigane.github.io/note/js/resources/</link>
      <guid>https://kigane.github.io/note/js/resources/</guid>
      <source url="https://kigane.github.io/rss.xml">资源与工具</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="谷歌字体"> 谷歌字体</h2>
<p><a href="https://fonts.google.com/" target="_blank" rel="noopener noreferrer">谷歌字体网站</a><br>
选中字体后，点击select this style。在右边弹窗中复制<code>&lt;lilnk&gt;</code>部分到html中，复制<code>@import</code>部分到css中。要使用字体时，复制下方的CSS rules即可指定字体。</p>
<h2 id="font-awesome"> font-awesome</h2>
<p><a href="https://fontawesome.com/v5/cheatsheet" target="_blank" rel="noopener noreferrer">FontAwesome</a><br>
在index.html的head最后添加: <code>&lt;script src=&quot;https://kit.fontawesome.com/b9d02be592.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="serve"> serve</h2>
<p>npm i -g serve<br>
serve -s /path/to/dist</p>
<h2 id="json-serve"> json-serve</h2>
<p>npm i -g json-server<br>
json-server --watch db.json --port 5000</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js</title>
      <link>https://kigane.github.io/note/js/vue/</link>
      <guid>https://kigane.github.io/note/js/vue/</guid>
      <source url="https://kigane.github.io/rss.xml">Vue.js</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基础"> 基础</h2>
<h2 id="深入"> 深入</h2>
<h3 id="data"> data</h3>
<p>vue组件中data中定义的数组，对象，实际类型是Proxy，都使用了代理。</p>
<h3 id="全局变量"> 全局变量</h3>
<div><pre><code><span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span>
app<span>.</span>config<span>.</span>globalProperties<span>.</span>$foo <span>=</span> <span>'bar'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>或使用provide/inject<br>
父组件中用provide选项提供数据，子组件中用inject选项使用该数据。</p>
<div><pre><code><span>/*
Root
└─ TodoList
   ├─ TodoItem
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics
*/</span>

<span>const</span> app <span>=</span> Vue<span>.</span><span>createApp</span><span>(</span><span>{</span><span>}</span><span>)</span>

app<span>.</span><span>component</span><span>(</span><span>'todo-list'</span><span>,</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      todos<span>:</span> <span>[</span><span>'Feed a cat'</span><span>,</span> <span>'Buy tickets'</span><span>]</span>
    <span>}</span>
  <span>}</span><span>,</span>
  <span>provide</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
        user<span>:</span> <span>'John Doe'</span>
    <span>}</span>
  <span>}</span><span>,</span>
  template<span>:</span> <span><span>`</span><span>
    &lt;div>
      {{ todos.length }}
      &lt;!-- rest of the template -->
    &lt;/div>
  </span><span>`</span></span>
<span>}</span><span>)</span>

app<span>.</span><span>component</span><span>(</span><span>'todo-list-statistics'</span><span>,</span> <span>{</span>
  inject<span>:</span> <span>[</span><span>'user'</span><span>]</span><span>,</span>
  <span>created</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>Injected property: </span><span><span>${</span><span>this</span><span>.</span>user<span>}</span></span><span>`</span></span><span>)</span> <span>// > Injected property: John Doe</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id="router-link"> router-link</h3>
<ul>
<li>当router-link的目标路径可以和当前路径匹配(例如，当前/foo/bar，可以匹配/,/foo,/foo/bar三个目标路径)时，该router-link标签会自动添加类.router-link-active</li>
<li>当router-link的目标路径可以和当前路径完全匹配(一模一样)时，该router-link标签会自动添加类.router-link-exact-active</li>
<li>可以在router-link标签上加exact属性，这样只有在完全匹配时才会添加类.router-link-active。通常会用于to='/'的router-link</li>
<li><code>&lt;router-link to=&quot;/foo/bar&quot;&gt;&lt;/router-link&gt;</code> 普通的router-link写法</li>
<li><code>&lt;router-link :to=&quot;{name = 'Foo', params = {id : 'bar'}}&quot;&gt;&lt;/router-link&gt;</code> 转到已命名的路由的router-link写法</li>
<li>另一种动态链接写法</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>"</span>`/foo/${id}`<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>router-link</span><span>></span></span> 
</code></pre>
<div><span>1</span><br></div></div><h3 id="nested-router-view"> nested router-view</h3>
<p>Home组件中有一个router-view，这个router-view对应的组件中还有一个router-view。则内层router-view可以声明如下。</p>
<div><pre><code><span>{</span>
    path<span>:</span> <span>'/home'</span><span>,</span>
    name<span>:</span> <span>'Home'</span><span>,</span>
    <span>component</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'@/views/Home.vue'</span><span>)</span><span>,</span>
    children<span>:</span> <span>[</span>
      <span>{</span>
        path<span>:</span> <span>':id'</span><span>,</span> <span>// 匹配/home/:id</span>
        name<span>:</span> <span>'Main'</span><span>,</span>
        <span>component</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'@/views/Main.vue'</span><span>)</span><span>,</span>
        props<span>:</span> <span>true</span> <span>// 让Home组件中的router-link中的路径参数可以传入Main组件，用Main的props接收。</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="named-router-view"> named router-view</h3>
<p>普通的<code>&lt;router-view /&gt;</code>默认使用routes中的component指定的组件。如果一个页面要有多个router-view，每个router-view对应不同的组件，则需要为router-view指定name。</p>
<div><pre><code><span>&lt;</span>router<span>-</span>view <span>/</span><span>></span>
<span>&lt;</span>router<span>-</span>view name<span>=</span><span>'a'</span> <span>/</span><span>></span>
<span>&lt;</span>router<span>-</span>view name<span>=</span><span>'b'</span> <span>/</span><span>></span>

<span>// 在routes中，要为每个router-view指定好组件。</span>
<span>{</span>
  path<span>:</span> <span>'xxx'</span><span>,</span>
  name<span>:</span> <span>'yyy'</span><span>,</span>
  component<span>:</span> <span>{</span>
    <span>default</span><span>:</span> ComponentDefault<span>,</span>
    a<span>:</span> ComponentA<span>,</span>
    b<span>:</span> ComponentB<span>,</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="route路径参数-动态链接"> route路径参数(动态链接)</h3>
<div><pre><code><span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>
  routes<span>:</span> <span>[</span>
    <span>// dynamic segments start with a colon</span>
    <span>{</span> path<span>:</span> <span>'/user/:id'</span><span>,</span> component<span>:</span> User<span>,</span> props<span>:</span> <span>true</span> <span>}</span>
  <span>]</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>path中的:id称为dynamic segment。如果path匹配到了，则可以通过$route.params.id访问匹配到的id值。<br>
如果路由对象的props设为true，则可由component的props属性接收路径参数。</p>
<h3 id="如何获取事件的event对象"> 如何获取事件的event对象</h3>
<p><code>@event=&quot;onEvent($event)</code>，<code>$event</code>为原生DOM的事件对象。</p>
]]></content:encoded>
    </item>
    <item>
      <title>OpenGL基础</title>
      <link>https://kigane.github.io/note/opengl/</link>
      <guid>https://kigane.github.io/note/opengl/</guid>
      <source url="https://kigane.github.io/rss.xml">OpenGL基础</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
    </item>
    <item>
      <title>帧缓冲(FrameBuffer)</title>
      <link>https://kigane.github.io/note/opengl/gl-framebuffer/</link>
      <guid>https://kigane.github.io/note/opengl/gl-framebuffer/</guid>
      <source url="https://kigane.github.io/rss.xml">帧缓冲(FrameBuffer)</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<p>默认的帧缓冲是在你创建窗口的时候生成和配置的，包括颜色缓冲，深度缓冲，模板缓冲等。OpenGL支持自定义帧缓冲。将场景渲染到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果。</p>
<h2 id="创建帧缓冲"> 创建帧缓冲</h2>
<div><pre><code><span>unsigned</span> <span>int</span> fbo<span>;</span>
<span>glGenFramebuffers</span><span>(</span><span>1</span><span>,</span> <span>&amp;</span>fbo<span>)</span><span>;</span>
<span>glBindFramebuffer</span><span>(</span>GL_FRAMEBUFFER<span>,</span> fbo<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在绑定到GL_FRAMEBUFFER目标之后，所有的读取和写入帧缓冲的操作将会影响当前绑定的帧缓冲。现在的帧缓冲还不能使用，因为它还不完整，一个完整的帧缓冲需要满足以下的条件：</p>
<ul>
<li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li>
<li>至少有一个颜色附件(Attachment)。</li>
<li>所有的附件都必须是完整的（保留了内存）。</li>
<li>每个缓冲都应该有相同的样本数。</li>
</ul>
<p>我们需要为帧缓冲创建一些附件，并将附件附加到帧缓冲上。在完成所有的条件之后，我们可以以GL_FRAMEBUFFER为参数调用glCheckFramebufferStatus，检查帧缓冲是否完整。</p>
<div><pre><code><span>if</span><span>(</span><span>glCheckFramebufferStatus</span><span>(</span>GL_FRAMEBUFFER<span>)</span> <span>==</span> GL_FRAMEBUFFER_COMPLETE<span>)</span>
  <span>// 确实完整了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中。由于当前帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。因此，渲染到一个不同的帧缓冲被叫做离屏渲染(Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，即将它绑定到0</p>
<div><pre><code><span>glBindFramebuffer</span><span>(</span>GL_FRAMEBUFFER<span>,</span> <span>0</span><span>)</span><span>;</span>
<span>glDeleteFramebuffers</span><span>(</span><span>1</span><span>,</span> <span>&amp;</span>fbo<span>)</span><span>;</span> <span>// 不要的时候记得删了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="纹理附件"> 纹理附件</h2>
<p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，之后可以在着色器中很方便地使用它。</p>
<div><pre><code><span>unsigned</span> <span>int</span> texture<span>;</span>
<span>glGenTextures</span><span>(</span><span>1</span><span>,</span> <span>&amp;</span>texture<span>)</span><span>;</span>
<span>glBindTexture</span><span>(</span>GL_TEXTURE_2D<span>,</span> texture<span>)</span><span>;</span>

<span>glTexImage2D</span><span>(</span>GL_TEXTURE_2D<span>,</span> <span>0</span><span>,</span> GL_RGB<span>,</span> <span>800</span><span>,</span> <span>600</span><span>,</span> <span>0</span><span>,</span> GL_RGB<span>,</span> GL_UNSIGNED_BYTE<span>,</span> <span>NULL</span><span>)</span><span>;</span>

<span>glTexParameteri</span><span>(</span>GL_TEXTURE_2D<span>,</span> GL_TEXTURE_MIN_FILTER<span>,</span> GL_LINEAR<span>)</span><span>;</span>
<span>glTexParameteri</span><span>(</span>GL_TEXTURE_2D<span>,</span> GL_TEXTURE_MAG_FILTER<span>,</span> GL_LINEAR<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>和普通的纹理区别在于：glTexImage2D的宽高设置为视口的大小，且最后一个参数data设置为NULL。表示仅仅分配了内存而没有填充它。填充会在渲染场景到帧缓冲之后进行。</p>
<div><p>提示</p>
<p>如果你想将你的屏幕渲染到一个更小或更大的纹理上，需要在渲染场景到帧缓冲之前使用纹理的新维度作为参数再次调用glViewport，否则只有一小部分的纹理或屏幕会被渲染到这个纹理上。</p>
</div>
<div><pre><code><span>glFramebufferTexture2D</span><span>(</span>GL_FRAMEBUFFER<span>,</span> GL_COLOR_ATTACHMENT0<span>,</span> GL_TEXTURE_2D<span>,</span> texture<span>,</span> <span>0</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>glFramebufferTexture2D</p>
<ul>
<li>target：帧缓冲的目标</li>
<li>attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。</li>
<li>textarget：你希望附加的纹理类型</li>
<li>texture：要附加的纹理本身</li>
<li>level：多级渐远纹理的级别。我们将它保留为0。</li>
</ul>
<p>对于深度缓冲：附件类型设置为GL_DEPTH_ATTACHMENT。纹理的内部格式变为GL_DEPTH_COMPONENT。</p>
<p>对于模板缓冲：附件类型设置为GL_STENCIL_ATTACHMENT，并将纹理的内部格式设定为GL_STENCIL_INDEX。</p>
<p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每32位数值将包含24位的深度信息和8位的模板信息。附件类型使用GL_DEPTH_STENCIL_ATTACHMENT，纹理的内部格式使用GL_UNSIGNED_INT_24_8。例如</p>
<div><pre><code><span>glTexImage2D</span><span>(</span>
  GL_TEXTURE_2D<span>,</span> <span>0</span><span>,</span> GL_DEPTH24_STENCIL8<span>,</span> <span>800</span><span>,</span> <span>600</span><span>,</span> <span>0</span><span>,</span> 
  GL_DEPTH_STENCIL<span>,</span> GL_UNSIGNED_INT_24_8<span>,</span> <span>NULL</span>
<span>)</span><span>;</span>

<span>glFramebufferTexture2D</span><span>(</span>GL_FRAMEBUFFER<span>,</span> GL_DEPTH_STENCIL_ATTACHMENT<span>,</span> GL_TEXTURE_2D<span>,</span> texture<span>,</span> <span>0</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="渲染缓冲对象-renderbuffer-object-附件"> 渲染缓冲对象(Renderbuffer Object)附件</h2>
<p>和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，所以更快(因为使用原生格式，所以交换缓冲这样的操作很快)。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲中返回特定区域的像素，而非附件本身。</p>
<p>由于渲染缓冲对象通常都是只写的，所以经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试能否通过。当<strong>不需要从缓冲中采样的时候</strong>，通常都会选择渲染缓冲对象。</p>
<div><pre><code><span>unsigned</span> <span>int</span> rbo<span>;</span>
<span>glGenRenderbuffers</span><span>(</span><span>1</span><span>,</span> <span>&amp;</span>rbo<span>)</span><span>;</span>
<span>glBindRenderbuffer</span><span>(</span>GL_RENDERBUFFER<span>,</span> rbo<span>)</span><span>;</span>
<span>// 创建一个深度和模板渲染缓冲对象</span>
<span>glRenderbufferStorage</span><span>(</span>GL_RENDERBUFFER<span>,</span> GL_DEPTH24_STENCIL8<span>,</span> <span>800</span><span>,</span> <span>600</span><span>)</span><span>;</span>
<span>// 附加</span>
<span>glFramebufferRenderbuffer</span><span>(</span>GL_FRAMEBUFFER<span>,</span> GL_DEPTH_STENCIL_ATTACHMENT<span>,</span> GL_RENDERBUFFER<span>,</span> rbo<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="渲染到纹理"> 渲染到纹理</h2>
<p>要想绘制场景到一个纹理上，我们需要采取以下的步骤：</p>
<ol>
<li>将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景</li>
<li>绑定默认的帧缓冲</li>
<li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。</li>
</ol>
<h2 id="后期处理"> 后期处理</h2>
<p>既然整个场景都被渲染到了一个纹理上，我们可以简单地通过修改纹理数据创建出一些非常有意思的效果。</p>
<h3 id="反相"> 反相</h3>
<p>我们现在能够访问渲染输出的每个颜色，所以在片段着色器中返回这些颜色的反相(Inversion)并不是很难。我们将会从屏幕纹理中取颜色值，然后用1.0减去它，对它进行反相：</p>
<div><pre><code><span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    FragColor <span>=</span> <span>vec4</span><span>(</span><span>vec3</span><span>(</span><span>1.0</span> <span>-</span> <span>texture</span><span>(</span>screenTexture<span>,</span> TexCoords<span>)</span><span>)</span><span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="灰度"> 灰度</h3>
<p>移除场景中除了黑白灰以外所有的颜色，让整个图像灰度化(Grayscale)。很简单的实现方式是，取所有的颜色分量，将它们平均化：</p>
<div><pre><code><span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    FragColor <span>=</span> <span>texture</span><span>(</span>screenTexture<span>,</span> TexCoords<span>)</span><span>;</span>
    <span>float</span> average <span>=</span> <span>(</span>FragColor<span>.</span>r <span>+</span> FragColor<span>.</span>g <span>+</span> FragColor<span>.</span>b<span>)</span> <span>/</span> <span>3.0</span><span>;</span>
    FragColor <span>=</span> <span>vec4</span><span>(</span>average<span>,</span> average<span>,</span> average<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>但人眼会对绿色更加敏感一些，而对蓝色不那么敏感，所以为了获取物理上更精确的效果，我们需要使用加权的通道：</p>
<div><pre><code><span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    FragColor <span>=</span> <span>texture</span><span>(</span>screenTexture<span>,</span> TexCoords<span>)</span><span>;</span>
    <span>float</span> average <span>=</span> <span>0.2126</span> <span>*</span> FragColor<span>.</span>r <span>+</span> <span>0.7152</span> <span>*</span> FragColor<span>.</span>g <span>+</span> <span>0.0722</span> <span>*</span> FragColor<span>.</span>b<span>;</span>
    FragColor <span>=</span> <span>vec4</span><span>(</span>average<span>,</span> average<span>,</span> average<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="核效果"> 核效果</h3>
<p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。</p>
<p>核(Kernel)（或卷积矩阵(Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。</p>
<div><p>提示</p>
<p>大部分核将所有的权重加起来之后都应该会等于1，如果它们加起来不等于1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。</p>
</div>
<p>例如：</p>
<div><pre><code><span>const</span> <span>float</span> offset <span>=</span> <span>1.0</span> <span>/</span> <span>300.0</span><span>;</span>  

<span>void</span> <span>main</span><span>(</span><span>)</span>
<span>{</span>
    <span>vec2</span> offsets<span>[</span><span>9</span><span>]</span> <span>=</span> <span>vec2</span><span>[</span><span>]</span><span>(</span>
        <span>vec2</span><span>(</span><span>-</span>offset<span>,</span>  offset<span>)</span><span>,</span> <span>// 左上</span>
        <span>vec2</span><span>(</span> <span>0.0f</span><span>,</span>    offset<span>)</span><span>,</span> <span>// 正上</span>
        <span>vec2</span><span>(</span> offset<span>,</span>  offset<span>)</span><span>,</span> <span>// 右上</span>
        <span>vec2</span><span>(</span><span>-</span>offset<span>,</span>  <span>0.0f</span><span>)</span><span>,</span>   <span>// 左</span>
        <span>vec2</span><span>(</span> <span>0.0f</span><span>,</span>    <span>0.0f</span><span>)</span><span>,</span>   <span>// 中</span>
        <span>vec2</span><span>(</span> offset<span>,</span>  <span>0.0f</span><span>)</span><span>,</span>   <span>// 右</span>
        <span>vec2</span><span>(</span><span>-</span>offset<span>,</span> <span>-</span>offset<span>)</span><span>,</span> <span>// 左下</span>
        <span>vec2</span><span>(</span> <span>0.0f</span><span>,</span>   <span>-</span>offset<span>)</span><span>,</span> <span>// 正下</span>
        <span>vec2</span><span>(</span> offset<span>,</span> <span>-</span>offset<span>)</span>  <span>// 右下</span>
    <span>)</span><span>;</span>

    <span>float</span> kernel<span>[</span><span>9</span><span>]</span> <span>=</span> <span>float</span><span>[</span><span>]</span><span>(</span>
        <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span>
        <span>-</span><span>1</span><span>,</span>  <span>9</span><span>,</span> <span>-</span><span>1</span><span>,</span>
        <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span>
    <span>)</span><span>;</span>

    <span>vec3</span> sampleTex<span>[</span><span>9</span><span>]</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>9</span><span>;</span> i<span>++</span><span>)</span>
    <span>{</span>
        sampleTex<span>[</span>i<span>]</span> <span>=</span> <span>vec3</span><span>(</span><span>texture</span><span>(</span>screenTexture<span>,</span> TexCoords<span>.</span>st <span>+</span> offsets<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>vec3</span> col <span>=</span> <span>vec3</span><span>(</span><span>0.0</span><span>)</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>9</span><span>;</span> i<span>++</span><span>)</span>
        col <span>+=</span> sampleTex<span>[</span>i<span>]</span> <span>*</span> kernel<span>[</span>i<span>]</span><span>;</span>

    FragColor <span>=</span> <span>vec4</span><span>(</span>col<span>,</span> <span>1.0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="常见的核"> 常见的核</h3>
<div><pre><code><span>// 锐化</span>
<span>float</span> kernel<span>[</span><span>9</span><span>]</span> <span>=</span> <span>float</span><span>[</span><span>]</span><span>(</span>
        <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span>
        <span>-</span><span>1</span><span>,</span>  <span>9</span><span>,</span> <span>-</span><span>1</span><span>,</span>
        <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span>
    <span>)</span><span>;</span>

<span>// 模糊</span>
<span>float</span> kernel<span>[</span><span>9</span><span>]</span> <span>=</span> <span>float</span><span>[</span><span>]</span><span>(</span>
    <span>1.0</span> <span>/</span> <span>16</span><span>,</span> <span>2.0</span> <span>/</span> <span>16</span><span>,</span> <span>1.0</span> <span>/</span> <span>16</span><span>,</span>
    <span>2.0</span> <span>/</span> <span>16</span><span>,</span> <span>4.0</span> <span>/</span> <span>16</span><span>,</span> <span>2.0</span> <span>/</span> <span>16</span><span>,</span>
    <span>1.0</span> <span>/</span> <span>16</span><span>,</span> <span>2.0</span> <span>/</span> <span>16</span><span>,</span> <span>1.0</span> <span>/</span> <span>16</span>  
<span>)</span><span>;</span>

<span>// 边缘检测(Edge-detection)</span>
<span>float</span> kernel<span>[</span><span>9</span><span>]</span> <span>=</span> <span>float</span><span>[</span><span>]</span><span>(</span>
        <span>1</span><span>,</span>  <span>1</span><span>,</span>  <span>1</span><span>,</span>
        <span>1</span><span>,</span> <span>-</span><span>8</span><span>,</span>  <span>1</span><span>,</span>
        <span>1</span><span>,</span>  <span>1</span><span>,</span>  <span>1</span>
    <span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><p>提示</p>
<p>注意，核在对屏幕纹理的边缘进行采样的时候，由于还会对中心像素周围的8个像素进行采样，其实会取到纹理之外的像素。由于环绕方式默认是GL_REPEAT，所以在没有设置的情况下取到的是屏幕另一边的像素，而另一边的像素本不应该对中心像素产生影响，这就可能会在屏幕边缘产生很奇怪的条纹。为了消除这一问题，我们可以将屏幕纹理的环绕方式都设置为GL_CLAMP_TO_EDGE。这样子在取到纹理外的像素时，就能够重复边缘的像素来更精确地估计最终的值了。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>eigen库</title>
      <link>https://kigane.github.io/note/opengl/eigen/</link>
      <guid>https://kigane.github.io/note/opengl/eigen/</guid>
      <source url="https://kigane.github.io/rss.xml">eigen库</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="基础"> 基础</h2>
<p>eigen库是纯模板库。</p>
<h3 id="matrix"> Matrix</h3>
<ul>
<li><code>Matrix&lt;typename Scalar, int RowsAtCompileTime, int ColsAtCompileTime&gt;</code></li>
<li><code>typedef Matrix&lt;float, 4, 4&gt; Matrix4f;</code></li>
<li>成员变量
<ul>
<li>rows()</li>
<li>cols()</li>
<li>size() = rows() x cols()</li>
</ul>
</li>
</ul>
<h3 id="vector"> Vector</h3>
<ul>
<li>向量定义为特殊的矩阵。</li>
<li>默认为列向量，<code>typedef Matrix&lt;float, 3, 1&gt; Vector3f;</code></li>
<li>行向量，<code>typedef Matrix&lt;int, 1, 2&gt; RowVector2i;</code></li>
</ul>
<h3 id="特殊值dynamic"> 特殊值Dynamic</h3>
<ul>
<li>矩阵的维度在编译时不能确定时，用Dynamic表示。</li>
<li><code>typedef Matrix&lt;double, Dynamic, Dynamic&gt; MatrixXd;</code> 行列都未知</li>
<li><code>Matrix&lt;float, 3, Dynamic&gt;</code> 可以只有一维是未知的</li>
</ul>
<h3 id="构造器"> 构造器</h3>
<p>只分配内存，不会初始化。指定大小时先行后列。</p>
<h3 id="访问"> 访问</h3>
<p>矩阵和向量都可以使用小括号访问。向量还可以使用中括号访问，因为C++不允许中括号操作符有两个参数，所以矩阵不能用中括号访问。</p>
<h3 id="comma-initializer"> comma-initializer</h3>
<div><pre><code>Matrix3f m<span>;</span>
m <span>&lt;&lt;</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>;</span>
<span>/*
  1 2 3
  4 5 6
  7 8 9
*/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="算术运算"> 算术运算</h3>
<ul>
<li>矩阵维度必须相同，元素类型也必须相同。eigen不会自动做类型转换。</li>
<li>矩阵和标量的除法，标量必须是除数。</li>
<li>eigen在运算时返回的不是Matrix对象，而是&quot;experssion object&quot;，运算符重载中没有实际进行运算，最后赋值时统一进行，以便于计算的优化。</li>
<li>转置，共轭，伴随，逆
<ul>
<li>m.transpose()</li>
<li>m.transposeInPlace() eigen实现中a=a.transpose()不会正常工作，需要使用该方法。</li>
<li>m.conjugate()</li>
<li>m.adjoint() For real matrices, conjugate() is a no-operation, and so adjoint() is equivalent to transpose().</li>
<li>m.inverse()</li>
</ul>
</li>
<li>点积，叉积
<ul>
<li>v.dot(w) 点击可以使用任意维度的向量</li>
<li>v.cross(w) 叉积只能用于三维向量</li>
</ul>
</li>
<li>reduction operations
<ul>
<li>m.sum() 所有元素之和</li>
<li>m.prod() 所有元素之积</li>
<li>m.mean() 所有元素的均值</li>
<li>m.maxCoeff() 矩阵中的最大元素的值</li>
<li>m.maxCoeff(&amp;i, &amp;j) 矩阵中的最大元素的位置存储于i,j中。</li>
<li>m.minCoeff() 矩阵中的最小元素的值</li>
<li>m.minCoeff(&amp;i, &amp;j) 矩阵中的最小元素的位置存储于i,j中。</li>
<li>m.trace() 矩阵的迹。对角线元素之和</li>
</ul>
</li>
<li>Matrix3d.Random() 生成[-1, 1]之间的随机数填充矩阵。对于Dynamic的矩阵，需要制定行列数。</li>
</ul>
<h3 id="array"> Array</h3>
<p>不同于Matrix用于实现线性代数的运算。Array主要用于做一些逐元素的操作，比如向量的每个元素同时加上某个值，或两个向量逐元素相乘。</p>
<ul>
<li><code>Array&lt;typename Scalar, int RowsAtCompileTime, int ColsAtCompileTime&gt;</code></li>
<li><code>typedef Array&lt;float,Dynamic,1&gt; ArrayXf</code></li>
<li><code>typedef Array&lt;float,3,1&gt; Array3f</code></li>
<li><code>typedef Array&lt;double,Dynamic,Dynamic&gt; ArrayXXd</code></li>
<li><code>typedef Array&lt;double,3,3&gt; Array33d</code></li>
</ul>
<h3 id="block"> Block</h3>
<h4 id="matrix-2"> Matrix</h4>
<p>Block of size (p,q), starting at (i,j)</p>
<ul>
<li>matrix.block(i,j,p,q);</li>
<li><code>matrix.block&lt;p,q&gt;(i,j)</code>;</li>
</ul>
<h4 id="vector-2"> Vector</h4>
<p>Block containing the first n elements *</p>
<ul>
<li>vector.head(n);</li>
<li><code>vector.head&lt;n&gt;()</code>;
Block containing the last n elements *</li>
<li>vector.tail(n);</li>
<li><code>vector.tail&lt;n&gt;()</code>;
Block containing n elements, starting at position i *</li>
<li>vector.segment(i,n);</li>
<li><code>vector.segment&lt;n&gt;(i)</code>;</li>
</ul>
<h2 id="示例"> 示例</h2>
<div><pre><code><span><span>#</span><span>include</span> <span>&lt;iostream></span></span>
<span><span>#</span><span>include</span> <span>&lt;Eigen/Eigen></span></span>

<span>using</span> <span>namespace</span> std<span>;</span>
<span>using</span> <span>namespace</span> Eigen<span>;</span>

<span><span>#</span><span>define</span> <span>printe</span><span><span>(</span>x<span>)</span> cout <span>&lt;&lt;</span> endl <span>&lt;&lt;</span> x <span>&lt;&lt;</span> endl<span>;</span></span></span>

<span>void</span> <span>test1</span><span>(</span><span>)</span>
<span>{</span>
    Matrix2i mat<span>;</span>
    <span>mat</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>)</span> <span>=</span> <span>1</span><span>;</span>
    <span>mat</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> <span>=</span> <span>2</span><span>;</span>
    <span>mat</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span> <span>=</span> <span>3</span><span>;</span>
    <span>mat</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span>=</span> <span>4</span><span>;</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    <span>// 矩阵常见初始化操作</span>
    <span>// 方式一</span>
    mat<span>.</span><span>setZero</span><span>(</span><span>)</span><span>;</span>  <span>// 全设为0</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    mat<span>.</span><span>setOnes</span><span>(</span><span>)</span><span>;</span> <span>// 全设为1</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    mat<span>.</span><span>setIdentity</span><span>(</span><span>)</span><span>;</span> <span>// 单位矩阵</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    mat<span>.</span><span>setConstant</span><span>(</span><span>7</span><span>)</span><span>;</span> <span>// 全设为某个值</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    <span>// 方式二</span>
    mat <span>=</span> <span>MatrixXi</span><span>::</span><span>Zero</span><span>(</span><span>2</span><span>,</span> <span>2</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    mat <span>=</span> <span>MatrixXi</span><span>::</span><span>Ones</span><span>(</span><span>2</span><span>,</span> <span>2</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    mat <span>=</span> <span>MatrixXi</span><span>::</span><span>Identity</span><span>(</span><span>2</span><span>,</span> <span>2</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    mat <span>=</span> <span>MatrixXi</span><span>::</span><span>Constant</span><span>(</span><span>2</span><span>,</span> <span>2</span><span>,</span> <span>7</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>test2</span><span>(</span><span>)</span>
<span>{</span>
    <span>// block 操作</span>
    Matrix4i mat<span>;</span>
    <span>int</span> k <span>=</span> <span>1</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span>
    <span>{</span>
        <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>4</span><span>;</span> j<span>++</span><span>)</span>
        <span>{</span>
            <span>mat</span><span>(</span>i<span>,</span> j<span>)</span> <span>=</span> k<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    MatrixXi mat_partitions<span>;</span>
    mat_partitions <span>=</span> mat<span>.</span><span>block</span><span>(</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>)</span><span>;</span> <span>// 左上角2x2矩阵</span>
    <span>//mat_partitions = mat.block(1, 1, 2, 2); // 中间2x2矩阵</span>
    <span>printe</span><span>(</span>mat_partitions<span>)</span><span>;</span>

    mat<span>.</span><span>block</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>)</span> <span>=</span> <span>MatrixXi</span><span>::</span><span>Constant</span><span>(</span><span>2</span><span>,</span> <span>2</span><span>,</span> <span>9</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>mat<span>)</span><span>;</span>

    <span>printe</span><span>(</span>mat<span>.</span><span>row</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>

    <span>printe</span><span>(</span>mat<span>.</span><span>col</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>

    <span>// 使用向量构造对角矩阵</span>
    Vector3i vec<span>;</span>
    vec <span>&lt;&lt;</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>;</span>
    MatrixXi diag<span>;</span>
    diag <span>=</span> vec<span>.</span><span>asDiagonal</span><span>(</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>diag<span>)</span><span>;</span>
<span>}</span>

<span>void</span> <span>test3</span><span>(</span><span>)</span>
<span>{</span>
    Matrix2d A<span>;</span>
    A <span>&lt;&lt;</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>;</span>
    Matrix2d G<span>;</span>
    G <span>=</span> A<span>.</span><span>inverse</span><span>(</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>G<span>)</span><span>;</span>
    <span>printe</span><span>(</span>A <span>*</span> G<span>)</span><span>;</span>
    A<span>.</span><span>transposeInPlace</span><span>(</span><span>)</span><span>;</span>
    <span>printe</span><span>(</span>A<span>)</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>(</span><span>)</span>
<span>{</span> 
    <span>//test1();</span>
    <span>test2</span><span>(</span><span>)</span><span>;</span>
    <span>//test3();</span>
    cin<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>OpenCV</title>
      <link>https://kigane.github.io/note/opengl/opencv/</link>
      <guid>https://kigane.github.io/note/opengl/opencv/</guid>
      <source url="https://kigane.github.io/rss.xml">OpenCV</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介"> 简介</h2>
<p>OpenCV是一个图像处理库。图像矩阵类Mat主要有两个部分,header部分记录图像矩阵的描述性信息，如大小，元素储存方式等等，另外一部分是一个指针，指向矩阵存储的内存。有自动内存管理，且使用了引用计数系统，Mat的赋值，复制构造函数只会复制header部分，指针部分指向同一块内存，最后一个指向该内存的指针负责回收内存。其指定存储方式的格式为:<code>CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]</code>。Mat的输出格式可以用<code>format(mat, Formatter::FMT_PYTHON)</code>指定(<code>cout&lt;&lt;format(mat,...)</code>)。<br>
PS：OpenCV按BGR顺序存储RGB颜色。</p>
<h2 id="遍历图像矩阵"> 遍历图像矩阵</h2>
<ul>
<li>cv::Mat::isContinuous() 检查内存是否在同一行</li>
<li>检查图像是否加载成功可以看I.data是否为NULL，为NULL则加载失败。</li>
<li>遍历矩阵元素的方式
<ul>
<li>mat.depth()查看item的类型，mat.channels()查看元素的通道数。</li>
<li>mat.rows查看元素行数,mat.cols查看元素列数，mat.cols*mat.channels()是item总数。</li>
<li><code>mat.ptr&lt;typename&gt;(i)</code> 取得指向矩阵第i行行首的指针。</li>
<li><code>MatIterator_&lt;typename&gt; it</code> 不同类型的迭代器，推荐使用，在内存换行时有点优化。
<ul>
<li><code>mat.begin&lt;typename&gt;()</code> 取得位于矩阵开头的迭代器。常用的RGB3通道对应typename为Vec3b</li>
<li><code>mat.end&lt;typename&gt;()</code></li>
</ul>
</li>
</ul>
</li>
<li>cv::Mat::at(row,col) 取得第row行，第col列的元素的地址，并返回引用。</li>
<li>cv::LUT(src,lut,dest) <code>dest[i]=lut[src[i]+d]</code>。如果src是无符号类型，则d=0，有符号类型则d=128。最快。</li>
</ul>
<h2 id="图像操作"> 图像操作</h2>
<ul>
<li>Mat img = imread(filename); 默认为3通道</li>
<li>Mat img = imread(filename, IMREAD_GRAYSCALE); 单通道</li>
<li>imwrite(filename, img); 保存到文件</li>
<li>imshow(&quot;image&quot;, img); 显示图像</li>
<li>cvtColor(img, grey, COLOR_BGR2GRAY);  改变颜色空间。</li>
<li>src.convertTo(dst, CV_32F); 改变图像类型</li>
<li>Rect r(10, 10, 100, 100); Mat smallImg = img(r); 将Rect指定的区域储存为另一个图像</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>软件渲染器</title>
      <link>https://kigane.github.io/note/opengl/software-renderer/</link>
      <guid>https://kigane.github.io/note/opengl/software-renderer/</guid>
      <source url="https://kigane.github.io/rss.xml">软件渲染器</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="整理"> 整理</h2>
<ul>
<li>给定物体和相机位置</li>
<li>摆好位置</li>
<li>投影变换</li>
<li>视口变换</li>
<li>光栅化
<ul>
<li>采样</li>
<li>抗锯齿</li>
<li>z-buffer</li>
</ul>
</li>
<li>着色 重心插值</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Blog Home</title>
      <link>https://kigane.github.io/</link>
      <guid>https://kigane.github.io/</guid>
      <source url="https://kigane.github.io/rss.xml">Blog Home</source>
      <pubDate>Sun, 03 Oct 2021 02:18:05 GMT</pubDate>
    </item>
    <item>
      <title>论文十问</title>
      <link>https://kigane.github.io/thesis/</link>
      <guid>https://kigane.github.io/thesis/</guid>
      <source url="https://kigane.github.io/rss.xml">论文十问</source>
      <category>Thesis</category>
      <pubDate>Mon, 13 Dec 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li>论文试图解决什么问题？</li>
<li>这是否是一个新的问题？</li>
<li>这篇文章要验证一个什么科学假设？</li>
<li>有哪些相关研究？如何归类？谁是这一课题在领域内值得关注的研究员？</li>
<li>论文中提到的解决方案之关键是什么？</li>
<li>论文中的实验是如何设计的？</li>
<li>用于定量评估的数据集是什么？代码有没有开源？</li>
<li>论文中的实验及结果有没有很好地支持需要验证的科学假设？</li>
<li>这篇论文到底有什么贡献？</li>
<li>下一步呢？有什么工作可以继续深入？</li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>