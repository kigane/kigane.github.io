<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>i386 | My Documentations</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.b27f4404.css" as="style"><link rel="preload" href="/assets/js/app.ebdd7216.js" as="script"><link rel="preload" href="/assets/js/2.f48cadb2.js" as="script"><link rel="preload" href="/assets/js/28.414c523f.js" as="script"><link rel="prefetch" href="/assets/js/10.53cde7a9.js"><link rel="prefetch" href="/assets/js/11.f623d497.js"><link rel="prefetch" href="/assets/js/12.8e8512b9.js"><link rel="prefetch" href="/assets/js/13.42e6bb09.js"><link rel="prefetch" href="/assets/js/14.2cc5c62e.js"><link rel="prefetch" href="/assets/js/15.8fd8b16a.js"><link rel="prefetch" href="/assets/js/16.275f3a5b.js"><link rel="prefetch" href="/assets/js/17.73223cde.js"><link rel="prefetch" href="/assets/js/18.ab20de8e.js"><link rel="prefetch" href="/assets/js/19.69c2dab7.js"><link rel="prefetch" href="/assets/js/20.8ef1446a.js"><link rel="prefetch" href="/assets/js/21.de978305.js"><link rel="prefetch" href="/assets/js/22.1b3b76bd.js"><link rel="prefetch" href="/assets/js/23.16b23281.js"><link rel="prefetch" href="/assets/js/24.f8213530.js"><link rel="prefetch" href="/assets/js/25.2a70b083.js"><link rel="prefetch" href="/assets/js/26.a31d3153.js"><link rel="prefetch" href="/assets/js/27.13cef54c.js"><link rel="prefetch" href="/assets/js/29.22b1157a.js"><link rel="prefetch" href="/assets/js/3.f82e4ec7.js"><link rel="prefetch" href="/assets/js/30.435188ea.js"><link rel="prefetch" href="/assets/js/31.57b9d028.js"><link rel="prefetch" href="/assets/js/32.84497166.js"><link rel="prefetch" href="/assets/js/33.6102bcb5.js"><link rel="prefetch" href="/assets/js/34.4d2a62b5.js"><link rel="prefetch" href="/assets/js/35.78fb1d25.js"><link rel="prefetch" href="/assets/js/36.eea99416.js"><link rel="prefetch" href="/assets/js/37.ec5d01e3.js"><link rel="prefetch" href="/assets/js/38.a4d04114.js"><link rel="prefetch" href="/assets/js/39.1a0c266b.js"><link rel="prefetch" href="/assets/js/4.d1b6e8ed.js"><link rel="prefetch" href="/assets/js/40.07444e3b.js"><link rel="prefetch" href="/assets/js/41.76e921dd.js"><link rel="prefetch" href="/assets/js/42.3b2cf128.js"><link rel="prefetch" href="/assets/js/43.24de1fd7.js"><link rel="prefetch" href="/assets/js/44.1db9d67f.js"><link rel="prefetch" href="/assets/js/45.a05c4248.js"><link rel="prefetch" href="/assets/js/46.6bd8578f.js"><link rel="prefetch" href="/assets/js/47.49e818f3.js"><link rel="prefetch" href="/assets/js/48.29abdba1.js"><link rel="prefetch" href="/assets/js/49.2e8f7396.js"><link rel="prefetch" href="/assets/js/5.7d8c4629.js"><link rel="prefetch" href="/assets/js/50.ca7f27cb.js"><link rel="prefetch" href="/assets/js/6.3a2a2487.js"><link rel="prefetch" href="/assets/js/7.59c4f4c1.js"><link rel="prefetch" href="/assets/js/8.52bdec09.js"><link rel="prefetch" href="/assets/js/9.76c798b3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b27f4404.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/ChernoLogo.png" alt="My Documentations" class="logo"> <span class="site-name can-hide">My Documentations</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow down"></span></button> <button type="button" aria-label="Note" class="mobile-dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/algorithm/" class="nav-link">
  Algorithm
</a></li><li class="dropdown-item"><!----> <a href="/note/cs/" class="nav-link router-link-active">
  Computer Science
</a></li><li class="dropdown-item"><!----> <a href="/note/cpp/" class="nav-link">
  C/C++
</a></li><li class="dropdown-item"><!----> <a href="/note/opengl/" class="nav-link">
  OpenGL
</a></li><li class="dropdown-item"><!----> <a href="/note/js/" class="nav-link">
  JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/hazel/" class="nav-link">
  Hazel
</a></div> <a href="https://github.com/kigane/MyBlogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Note" class="dropdown-title"><span class="title">Note</span> <span class="arrow down"></span></button> <button type="button" aria-label="Note" class="mobile-dropdown-title"><span class="title">Note</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/algorithm/" class="nav-link">
  Algorithm
</a></li><li class="dropdown-item"><!----> <a href="/note/cs/" class="nav-link router-link-active">
  Computer Science
</a></li><li class="dropdown-item"><!----> <a href="/note/cpp/" class="nav-link">
  C/C++
</a></li><li class="dropdown-item"><!----> <a href="/note/opengl/" class="nav-link">
  OpenGL
</a></li><li class="dropdown-item"><!----> <a href="/note/js/" class="nav-link">
  JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="/hazel/" class="nav-link">
  Hazel
</a></div> <a href="https://github.com/kigane/MyBlogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/note/cs/" aria-current="page" class="sidebar-link">计算机概述</a></li><li><a href="/note/cs/isa-i386.html" aria-current="page" class="active sidebar-link">i386</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#基本编程模型" class="sidebar-link">基本编程模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#内存组织和分段-segmentation" class="sidebar-link">内存组织和分段(Segmentation)</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#数据类型" class="sidebar-link">数据类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#寄存器" class="sidebar-link">寄存器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#通用寄存器" class="sidebar-link">通用寄存器</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#段寄存器" class="sidebar-link">段寄存器</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#指令格式" class="sidebar-link">指令格式</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#操作数选择-operand-selection" class="sidebar-link">操作数选择 Operand Selection</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#中断和异常-interrupts-and-exceptions" class="sidebar-link">中断和异常(Interrupts and Exceptions)</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#应用指令集" class="sidebar-link">应用指令集</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#数据移动指令" class="sidebar-link">数据移动指令</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#二元算术指令" class="sidebar-link">二元算术指令</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#十进制算数指令" class="sidebar-link">十进制算数指令</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#逻辑指令" class="sidebar-link">逻辑指令</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#控制转移指令" class="sidebar-link">控制转移指令</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#杂项指令" class="sidebar-link">杂项指令</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#_80386指令集说明" class="sidebar-link">80386指令集说明</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#操作数和地址的大小-operand-size-address-size" class="sidebar-link">操作数和地址的大小(Operand-Size, Address-Size)</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#指令格式-2" class="sidebar-link">指令格式</a></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#指令" class="sidebar-link">指令</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/cs/isa-i386.html#intel-和-at-t-格式汇编的语法差异" class="sidebar-link">Intel 和 AT&amp;T 格式汇编的语法差异</a></li></ul></li><li><a href="/note/cs/isa-riscv.html" class="sidebar-link">riscv</a></li><li><a href="/note/cs/gdb-cheatsheet.html" class="sidebar-link">gdb</a></li><li><a href="/note/cs/shell-cheatsheet.html" class="sidebar-link">shell</a></li><li><a href="/note/cs/vim.html" class="sidebar-link">vim</a></li><li><a href="/note/cs/git.html" class="sidebar-link">git</a></li><li><a href="/note/cs/regex.html" class="sidebar-link">正则表达式</a></li><li><a href="/note/cs/linux.html" class="sidebar-link">Linux - Ubantu</a></li><li><a href="/note/cs/ECF.html" class="sidebar-link">异常控制流</a></li><li><a href="/note/cs/VM.html" class="sidebar-link">虚拟内存</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="基本编程模型"><a href="#基本编程模型" class="header-anchor">#</a> 基本编程模型</h2> <h3 id="内存组织和分段-segmentation"><a href="#内存组织和分段-segmentation" class="header-anchor">#</a> 内存组织和分段(Segmentation)</h3> <p>物理内存由8-bit的字节组成的序列构成。每个字节有一个唯一的地址，范围<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>2</mn><mrow><mn>3</mn><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[0, 2^{32}-1]</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span>，共4GB。</p> <p>内存组织模型有两种</p> <ul><li>flat address space 由大小为4GB的单个数组组成</li> <li>segmented address space 由16383(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>1</mn><mn>4</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{14}-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>)个线性地址空间集合组成，每个地址空间最多4GB。
<ul><li>内存空间最大为64TB(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>4</mn><mn>6</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{46}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">4</span><span class="mord mathrm">6</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>B)。称为逻辑地址空间</li> <li>可以看作最多16383个一维子空间的集合，每个子空间就是一个Segment。子空间的地址是连续的。</li> <li>逻辑地址空间的指针由两个部分组成
<ul><li>16bits的segment selector，用于确定Segment</li> <li>32bits的offset，用于确定Segment内的字节。</li></ul></li></ul></li></ul> <p>详见第5章。</p> <h3 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h3> <p>操作数(Operand)的基础数据类型</p> <ul><li>Byte 8bits</li> <li>Word 16bits</li> <li>DoubleWord 32bits</li></ul> <p>注意：Word的地址不必对齐到偶数地址，DoubleWord的地址不必对齐到能被4整除的地址。这样数据结构的弹性最大，内存利用率最高。但使用32-bits的总线传输效率会较低。为了更好的传输性能，数据结构应该要设计为尽量对齐。</p> <hr> <p>操作数(Operand)的基础数据类型只有三种，但根据使用指令的不同，可以识别出额外的基础数据类型</p> <ul><li>Integer: 用二进制补码表示。最高有效位(MSB)为符号位。</li> <li>Ordinal: 用二进制原码表示。无符号位。</li> <li>Near Pointer: 32-bit 逻辑地址。用于flat model或Segment内部。</li> <li>Far Pointer: 48-bit 逻辑地址。仅用于segmented model。</li> <li>String: Byte,Word,DoubleWord的连续序列。</li> <li>Bit field: bit的连续序列。最大32位。起始bit任意。</li> <li>Bit string: bit的连续序列。起始bit任意。最大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>3</mn><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{32}-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>bits。</li> <li>BCD: 每个字节表示一个十进制数字，0-3这4个bit表示一个数字(只有0-9有意义)。4-7个4个bit在乘除中必须为0，在加减中可以是任意值。</li> <li>Packed BCD:每个字节表示两个十进制数字。每半个字节表示一个数字。</li></ul> <h2 id="寄存器"><a href="#寄存器" class="header-anchor">#</a> 寄存器</h2> <p>80386共有16个寄存器，可分为3类</p> <ul><li>通用寄存器(General registers) 8个32-bit寄存器，主要用于保存操作数</li> <li>段寄存器(Segment registers) 这6个寄存器决定了在任一时刻，那个segment是可寻址的。</li> <li>状态和指令寄存器(Status and instruction registers) 用于记录和改变处理器的状态。</li></ul> <h3 id="通用寄存器"><a href="#通用寄存器" class="header-anchor">#</a> 通用寄存器</h3> <p><img src="/assets/img/general-registers.png" alt="通用寄存器"></p> <p>其中</p> <ul><li>EAX, EDX, ECX, EBX, EBP, ESI, EDI, ESP是32位寄存器;</li> <li>AX, DX, CX, BX, BP, SI, DI, SP是16位寄存器;</li> <li>AL, DL, CL, BL, AH, DH, CH, BH是8位寄存器.</li></ul> <p>某些指令会使用特定的寄存器，如：双精度浮点乘除运算，I/O，字符串指令，循环，栈操作等等。</p> <h3 id="段寄存器"><a href="#段寄存器" class="header-anchor">#</a> 段寄存器</h3> <p><img src="/assets/img/other-registers.png" alt="其他寄存器">
完整的程序通常由许多不同的模块组成，每个模块包括指令和数据。 但是，在程序执行期间的任一时刻，实际使用到的仅为程序模块的小子集。 80386架构通过提供直接访问当前模块环境的指令和数据的机制来利用这一点，必要时可以访问额外的段。</p> <p>执行中的程序可以在任一时刻立即访问六个内存段。这六个内存段分别用寄存器CS,SS,DS,ES,FS,GS标识，每个段寄存器唯一确定一个特定的程序段，并可以高速访问。</p> <ul><li>CS(Code Segment) 对应保存当前执行的指令序列所在的段。CS的值只能通过控制转移指令(e.g JMP,CALL)，中断或异常隐式改变。</li> <li>SS(Stack Segment) 子程序调用，参数，过程激活记录通常会在栈上分配内存。所有的栈操作都会使用SS来定位栈。不像CS, SS寄存器可以显式加载，因此程序员可以动态定义栈。</li> <li>DS，ES，FS和GS寄存器指定四个数据段，每个数据段都可由当前执行的程序寻址。对四个单独的数据区域的可访问性有助于程序有效地访问不同类型的数据结构。有些程序可能需要访问不止4个数据段，此时需要在程序执行期间改变这4个寄存器的值。这需要程序在访问特定数据时，需要先加载正确的段寄存器。</li></ul> <p>处理器将基址与由段寄存器选择的段地址相关联。即先通过段寄存器找到相应的段，再用32-bit基址在段内寻址。</p> <h4 id="栈的实现"><a href="#栈的实现" class="header-anchor">#</a> 栈的实现</h4> <p>栈操作相关寄存器</p> <ul><li>SS 一个系统可以有多个栈，每个栈大小最多可达4GB。由SS直接寻址的栈，通常被称为“当前”栈。SS自动用于所有栈操作，由处理器处理。</li> <li>ESP ESP始终指向栈的栈顶(栈是从高地址向低地址扩展的，所以栈顶的地址最小)。ESP被PUSH,POP,子程序调用和返回，中断隐式引用。</li> <li>EBP EBP指向当前过程确定的栈帧的基址(栈帧的最高地址，不会随栈的变换而改变)。因此适用于访问栈中的元素。</li></ul> <h4 id="标志寄存器-eflags"><a href="#标志寄存器-eflags" class="header-anchor">#</a> 标志寄存器--EFLAGS</h4> <p><img src="/assets/img/EFLAGS.png" alt="EFLAGS">
标志可以分为3组</p> <ul><li>Status flags：用于让某个指令的结果影响下一个指令。算数指令使用前6个
<ul><li>CF(Carry Flag): 有进位或借位发生是设置，否则清除。</li> <li>PF(Parity Flag): 如果结果的低8bit有偶数个1，则设置，否则清除。</li> <li>AF(Adjust Flag): 用于BCD数据运算。如果AL的低4位有进位或借位则设置，否则清除。</li> <li>ZF(Zoro Flag): 如果结果为0则设置，否则清除。</li> <li>SF(Sign Flag): 结果的最高有效位。</li> <li>OF(Overflow Flag): 溢出标志。(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>⊕</mo><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>C</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_n \oplus C_{n-1},C_n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">⊕</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是最高位是否溢出，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">C_{n-1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是次高位是否溢出)</li> <li>TF(Trap Flag): 陷阱标志。Debug时用到。</li></ul></li> <li>Control flags：
<ul><li>DF(Direction Flag): 当字符串指令自减时设置(即从高地址向低地址处理字符串时)，反之清除。</li></ul></li> <li>System flags：</li></ul> <hr> <h4 id="指令指针"><a href="#指令指针" class="header-anchor">#</a> 指令指针</h4> <p>程序计数器(PC) -- EIP (Extended Instruction Pointer) 指向要执行的指令</p> <h3 id="指令格式"><a href="#指令格式" class="header-anchor">#</a> 指令格式</h3> <p>指令=操作+操作数类型&amp;操作数位置</p> <p><strong>指令中常见元素</strong></p> <ul><li>Prefix 在指令之前的1-2个字节，修改指令的操作。
<ul><li>Segment override 显式指定指定应该使用的段寄存器，覆盖默认的。</li> <li>Address size 产生16或32位地址</li> <li>Operand size 产生16或32位操作数</li> <li>Repeat 字符串指令使用该前缀，让该指令作用于string的每个元素。</li></ul></li> <li>Opcode 操作码。确定指令的操作</li> <li>Register specifier 一条指令可以指定1-2个寄存器操作数。寄存器指示符要么和Opcode在一个字节(+rb,+rw...)，要么和Address mode在一个字节。</li> <li>Addressing-mode specifier 决定操作数是寄存器还是内存位置。如果是内存位置，决定是否使用位移，基址寄存器，索引寄存器和缩放因子。</li> <li>SIB byte (scale, index, base) 当addressing-mode specifier暗示要使用索引寄存器来计算操作数的地址时，指令中会包含一个SIB字节来编码基址寄存器，索引寄存器和缩放因子。</li> <li>Displacement 当addressing-mode specifier暗示要使用位移来计算操作数的地址时，位移会编码在指令中。位移是一个<strong>有符号整数</strong>，通常8-bit就足够，按需要可以扩展到16-bit，32-bit。</li> <li>Immediate operand 立即数，就是指令的直接操作数。可以是8,16,32位。为了以防万一有8bit操作数和32/16-bit操作数合并的操作，通常会自动扩展。</li></ul> <h3 id="操作数选择-operand-selection"><a href="#操作数选择-operand-selection" class="header-anchor">#</a> 操作数选择 Operand Selection</h3> <p>操作数是指令操纵的数据，一个指令可以有0或多个操作数。操作数可以位于</p> <ul><li>指令本身(立即数)</li> <li>寄存器</li> <li>内存</li> <li>I/O端口</li></ul> <p>对于有操作数的指令，操作数可以是隐式的，显式的，或者既有隐式操作数又有显式操作数。例如</p> <ul><li>AAM(Ascii Adjust for mutiplication) 作用于AX寄存器。隐式，</li> <li>XCHG EAX,EBX 显式</li> <li>PUSH COUNTER 显式+隐式 内存变量COUNTER拷贝到栈中</li></ul> <hr> <p><strong>大多数指令有隐式操作数。所有的算数操作数都会更新EFLAGS。</strong></p> <hr> <p>指令可以显示引用1-2个操作数。有两个操作数的指令，其结果一定会覆盖其中一个操作数，称为目标操作数(dest)，另一个则称源操作数(src)。有两个显式操作数的指令，一个操作数为内存(M)或寄存器(R),另一个操作数一定是寄存器或立即数(Immediate)允许的操作有</p> <ul><li>R-to-R</li> <li>R-to-M</li> <li>M-to-R</li> <li>I-to-R</li> <li>I-to-M</li></ul> <p>M-M模式在字符串处理指令中存在，但两个操作数都是隐式表示的。Push,Pop也有点特殊。</p> <p>I: 指令中的有符号数字字面量
R: 对应各个寄存器</p> <p>Memory Operand<br>
数据操纵指令在处理内存操作数时，必须指明包含该操作数的段(segment)和操作数在段中的位置(offset)。然而，为了速度和指令编码的简练，将段选择器(segment selector)放在高速的段寄存器中。因此数据操纵指令只需要指明offset即可。<br>
内存寻址</p> <ul><li>大多数数据操纵指令访问内存时都显式包含一个指示寻址方法的字节modR/M字节。通常跟在opcode后。如果操作数为内存地址，则最终地址LA = SR + (B,I,s,D的各种组合)，其中(B:基址寄存器，I:索引寄存器，s:缩放因子，D:位移)。当用到索引寄存器的时候，modR/M字节后会跟着一个字节，指示使用的索引寄存器和缩放因子。</li> <li>某些特殊的寻址
<ul><li>LA = SR + D 某些MOV指令，隐式使用EAX，offset写在指令中。</li> <li>字符串操作
<ul><li>使用 DS:ESI 寻址，如MOVS, CMPS, OUTS, LODS, SCAS</li> <li>使用 ES:EDI 寻址，如MOVS, CMPS, INS, STOS</li></ul></li> <li>栈操作，使用 SS:ESP 寻址。 如PUSH, POP, PUSHA, PUSHAD, POPA, POPAD, PUSHF, PUSHFD, POPF, POPFD, CALL, RET, IRET, IRETD以及异常和中断。</li></ul></li></ul> <h4 id="默认的段寄存器选择规则"><a href="#默认的段寄存器选择规则" class="header-anchor">#</a> 默认的段寄存器选择规则</h4> <table><thead><tr><th>内存引用</th> <th>段寄存器</th> <th>规则</th></tr></thead> <tbody><tr><td>指令</td> <td>CS</td> <td>在预取(prefetch)指令时自动选择</td></tr> <tr><td>栈</td> <td>SS</td> <td>任何栈push,pop操作。以EBP/ESP为基址的寻址</td></tr> <tr><td>Local Data</td> <td>DS</td> <td>其他</td></tr> <tr><td>Dest Strings</td> <td>ES</td> <td>字符串指令的 dest</td></tr></tbody></table> <h4 id="有效地址计算"><a href="#有效地址计算" class="header-anchor">#</a> 有效地址计算</h4> <p><img src="/assets/img/effective-address.png" alt="有效地址计算"></p> <p>对以modR/M定义的内存操作数，在目标段内的有效地址由3个部分组成</p> <ul><li>指令中的位移元素。因为是编码在指令中，所以适合地址的固定部分
<ul><li>简单标量操作数的位置</li> <li>静态(static)分配的数组的开头</li> <li>record中某个item的offset</li></ul></li> <li>基址寄存器</li> <li>变址寄存器(可能会乘以缩放因子2, 4, 或 8，上图错了)
<ul><li>基址+变址适合动态决定的地址</li> <li>栈中的局部变量和过程参数</li> <li>records[i]</li> <li>二维数组中的一维数组的起始</li> <li>动态分配的数组地址</li></ul></li> <li>注意，ESP不能作为变址寄存器。EBP，ESP作为基址寄存器时，默认的段寄存器为SS。</li> <li>当数组元素大小为2,4,8时，由于scaling的存在，索引比较高效(不用分开移动或多次使用指令)。</li></ul> <p>常用的寻址组合，段寄存器省略</p> <ul><li>A = D 位移本身就是地址。通常用于static分配内存的操作数。</li> <li>A = B 寄存器中的值就是地址。某些变量。</li> <li>A = B + D
<ul><li>当索引的static array元素大小不是2,4,8B时。D为目标元素的offset。</li> <li>访问records数组中的某个item。B为某个record，D为item的offset</li></ul></li> <li>A = Ixs + D 当索引的static array元素大小是2,4,8B时。D为数组首地址。</li> <li>A = B + I + D
<ul><li>二维数组，D为m[0][0]，</li> <li>访问records数组中的某个item。B为records[0]，D为item的offset</li></ul></li> <li>A = B + Ixs+ D 最一般的寻址格式
<ul><li>在汇编代码中写作 displacement(R[base_reg], R[index_reg], scale_factor)</li> <li>其它寻址格式都可以看作这种一般格式的特例</li></ul></li></ul> <h3 id="中断和异常-interrupts-and-exceptions"><a href="#中断和异常-interrupts-and-exceptions" class="header-anchor">#</a> 中断和异常(Interrupts and Exceptions)</h3> <p>80386有两个机制来打断程序执行</p> <ul><li>异常：是对在程序执行期间CPU检测到的特定条件作出回应的同步事件(synchronous event)。</li> <li>中断：是外部设备需要注意时触发的异步事件(asynchronous event)</li></ul> <p>异常和中断很类似，都会引起处理器暂时暂停(suspend)当前程序的执行，并执行另一个优先级更高的程序。它们的主要区别在于引发原因。异常总是可重现的，只要以同样的程序和数据再次执行。而中断通常独立于当前执行的程序。</p> <p>中断详见第9章。应用程序员通常不处理中断，只处理异常。系统程序员需要定义应用程序和异常机制之间的接口，并提供给应用程序员。</p> <p>//TODO</p> <p>Reserved Exceptions and Interrupts</p> <table><thead><tr><th>Vector Number</th> <th>Description</th></tr></thead> <tbody><tr><td>0</td> <td>Divide Error</td></tr> <tr><td>1</td> <td>Debug Exceptions</td></tr> <tr><td>2</td> <td>NMI Interrupt</td></tr> <tr><td>3</td> <td>Breakpoint</td></tr> <tr><td>4</td> <td>INTO Detected Overflow</td></tr> <tr><td>5</td> <td>BOUND Range Exceeded</td></tr> <tr><td>6</td> <td>Invalid Opcode</td></tr> <tr><td>7</td> <td>Coprocessor Not Available</td></tr> <tr><td>8</td> <td>Double Exception</td></tr> <tr><td>9</td> <td>Coprocessor Segment Overrun</td></tr> <tr><td>10</td> <td>Invalid Task State Segment</td></tr> <tr><td>11</td> <td>Segment Not Present</td></tr> <tr><td>12</td> <td>Stack Fault</td></tr> <tr><td>13</td> <td>General Protection</td></tr> <tr><td>14</td> <td>Page Fault</td></tr> <tr><td>15</td> <td>(reserved)</td></tr> <tr><td>16</td> <td>Coprocessor Error</td></tr> <tr><td>17-32</td> <td>(reserved)</td></tr></tbody></table> <h2 id="应用指令集"><a href="#应用指令集" class="header-anchor">#</a> 应用指令集</h2> <h3 id="数据移动指令"><a href="#数据移动指令" class="header-anchor">#</a> 数据移动指令</h3> <h4 id="通用数据移动指令"><a href="#通用数据移动指令" class="header-anchor">#</a> 通用数据移动指令</h4> <ul><li>MOV (move)</li> <li>XCHG (exchange) 交换两个操作数。不需要临时变量，可代替3条MOV指令。在实现semaphores(信号量)及类似的进程同步数据结构时很有用。如果有一个操作数是M，则XCHG自动激活LOCK信号。</li></ul> <h4 id="栈操作指令"><a href="#栈操作指令" class="header-anchor">#</a> 栈操作指令</h4> <ul><li>PUSH 降低ESP，再将源操作数放到ESP指的位置。通常用于过程调用时保存参数或在栈上保存临时变量。</li> <li>PUSHA (Push All Registers) 将八个通用寄存器的值存到栈中。顺序为EAX,EDX,ECX,EBX,OLD ESP,EBP,ESI,EDI。可以简化过程调用时保存寄存器的值操作。</li> <li>POP 将栈中保存的值放到目标操作数，再提高ESP。</li> <li>POPA 将栈中的个通用寄存器的值取出，并用这些值重设寄存器。但忽略OLD ESP。</li></ul> <h4 id="类型转换指令"><a href="#类型转换指令" class="header-anchor">#</a> 类型转换指令</h4> <ul><li>CWD (Convert Word to Doubleword)</li> <li>CDQ (Convert Doubleword to Quad-Word)</li> <li>CBW (Convert Byte to Word)</li> <li>CWDE (Convert Word to Doubleword Extended)</li> <li>只能操作EAX中的数据。可用于被除之前被除数的扩展。都是有符号扩展。</li></ul> <hr> <ul><li>MOVSX (Move with Sign Extension)</li> <li>MOVZX (Move with Zero Extension)</li> <li>可使用任何寄存器。另一个操作可以为M或R。</li></ul> <h3 id="二元算术指令"><a href="#二元算术指令" class="header-anchor">#</a> 二元算术指令</h3> <p>会影响CF,SF,OF,ZF四个flag。</p> <h4 id="加减指令"><a href="#加减指令" class="header-anchor">#</a> 加减指令</h4> <ul><li>ADD (Add Integers) 如果溢出，设置CF=1</li> <li>ADC (Add Integers with Carry)  如果CF=1，再+1。否则同ADD</li> <li>INC (Increment) +1。不影响CF</li> <li>SUB (Subtract Integers) 如果借位(borrow)，设置CF=1</li> <li>SBB (Subtract Integers with Borrow) 如果CF=1，再-1。否则同SUB</li> <li>DEC (Decrement) -1。不影响CF</li></ul> <h4 id="比较和取负指令"><a href="#比较和取负指令" class="header-anchor">#</a> 比较和取负指令</h4> <ul><li>CMP (Compare)  用dest-src，更新OF, SF, ZF, AF, PF, 和 CF 标志，但不会改变dest和src的值。</li> <li>NEG (Negate)  0-dest</li></ul> <h4 id="乘法指令"><a href="#乘法指令" class="header-anchor">#</a> 乘法指令</h4> <ul><li>MUL (Unsigned Integer Multiply) 源操作数和累加器(EAX/AX/AL)相乘，结果大小为操作数的两倍。如果结果的上半部分不为0，则将CF,OF设为1，否则设为0。</li> <li>IMUL (Signed Integer Multiply)
<ul><li>单操作数 和MUL一样，另一个乘数隐式为EAX/AX/AL。取决于操作数的大小。</li> <li>双操作数 其中一个操作数一定在通用寄存器中，结果也放在通用寄存器中。</li> <li>三操作数 一个必定是有符号立即数，一个在寄存器或内存中，剩下一个通常是通用寄存器，存储乘积。</li> <li>结果大小为操作数的两倍。如果结果的上半部分不为0，则将CF,OF设为1，否则设为0。</li> <li>双，三操作数的形式结果会被截断(truncate)到源操作数的长度。也因此兼容无符号数的乘，因为乘积的低半部分是相同的。</li></ul></li></ul> <h4 id="除法指令"><a href="#除法指令" class="header-anchor">#</a> 除法指令</h4> <p>如果除数为0或商超过EAX/AX/AL的表示范围，则触发一个异常(interrupt zero)<br>
DIV (Unsigned Integer Divide) 被除数隐式存储在EAX中。商不为整数时向0舍入。
IDIV (Signed Integer Divide) 同DIV。余数的符号同被除数。</p> <table><thead><tr><th>Divisor(SRC 除数)</th> <th>Dividend(被除数)</th> <th>Quotient(商)</th> <th>Remainder (余数)</th></tr></thead> <tbody><tr><td>Byte</td> <td>AX</td> <td>AL</td> <td>AH</td></tr> <tr><td>Word</td> <td>DX:AX</td> <td>AX</td> <td>DX</td></tr> <tr><td>Doubleword</td> <td>EDX:EAX</td> <td>EAX</td> <td>EDX</td></tr></tbody></table> <h3 id="十进制算数指令"><a href="#十进制算数指令" class="header-anchor">#</a> 十进制算数指令</h3> <h4 id="packed-bcd指令"><a href="#packed-bcd指令" class="header-anchor">#</a> packed BCD指令</h4> <ul><li>DAA (Decimal Adjust after Addition)</li> <li>DAS (Decimal Adjust after Subtraction)</li></ul> <h4 id="unpacked-bcd指令"><a href="#unpacked-bcd指令" class="header-anchor">#</a> unpacked BCD指令</h4> <ul><li>AAA (ASCII Adjust after Addition)</li> <li>AAS (ASCII Adjust after Subtraction)</li> <li>AAM (ASCII Adjust after Multiplication)</li> <li>AAD (ASCII Adjust before Division)</li></ul> <h3 id="逻辑指令"><a href="#逻辑指令" class="header-anchor">#</a> 逻辑指令</h3> <h4 id="布尔操作指令"><a href="#布尔操作指令" class="header-anchor">#</a> 布尔操作指令</h4> <ul><li>NOT 对一个R或M中的操作数取反码。不影响flags。</li> <li>AND/OR/XOR 操作数可以是R-R,R-M,I-R/M。会将OF，CF置零，AF的行为未定义，更新SF，ZF，PF。</li></ul> <h4 id="位测试和修改指令"><a href="#位测试和修改指令" class="header-anchor">#</a> 位测试和修改指令</h4> <p>首先将选中的bit的值符给CF，再将新值放到该bit上。</p> <table><thead><tr><th>Instruction</th> <th>Effect on CF</th> <th>Effect on Selected Bit</th></tr></thead> <tbody><tr><td>Bit (Bit Test)</td> <td>CF ← BIT</td> <td>(none)</td></tr> <tr><td>BTS (Bit Test and Set)</td> <td>CF ← BIT</td> <td>BIT ← 1</td></tr> <tr><td>BTR (Bit Test and Reset)</td> <td>CF ← BIT</td> <td>BIT ← 0</td></tr> <tr><td>BTC (Bit Test and Complement)</td> <td>CF ← BIT</td> <td>BIT ← NOT(BIT)</td></tr></tbody></table> <h4 id="位扫描指令"><a href="#位扫描指令" class="header-anchor">#</a> 位扫描指令</h4> <ul><li>BSF (Bit Scan Forward) 从0-7/15/31扫描。保存第一个set bit(即1，unset bit就是0)的索引位置。如果全为0，则set ZF。反之清除。另外，如果被扫描的操作数全为0，则结果未定义。</li> <li>BSR (Bit Scan Reverse) 反过来扫描。</li></ul> <h4 id="shift-rotate指令"><a href="#shift-rotate指令" class="header-anchor">#</a> shift&amp;rotate指令</h4> <h3 id="控制转移指令"><a href="#控制转移指令" class="header-anchor">#</a> 控制转移指令</h3> <h4 id="无条件转移指令"><a href="#无条件转移指令" class="header-anchor">#</a> 无条件转移指令</h4> <ul><li>JMP (Jump)
<ul><li>直接跳转 操作数写在指令中，且为有符号的立即数，表示相对位移(单位为Byte,Word,或DoubleWord)。计算的结果更新EIP。</li> <li>间接跳转 通过R或M指定应该执行的下一条指令的绝对地址。</li></ul></li> <li>CALL 激活另一个过程(其地址可以在某个通用寄存器中，也可以是编码在指令中的内存地址)，在栈中保存CALL指令的下一条指令的地址(即当前EIP的值)，供RET使用。</li> <li>RET (Return From Procedure) 从栈中恢复CALL保存的EIP的值。</li> <li>IRET (Return From Interrupt) 将控制返回到被中断过程。在恢复EIP之外，还会恢复中断机制存储在栈中的flags。</li></ul> <h4 id="条件转移指令"><a href="#条件转移指令" class="header-anchor">#</a> 条件转移指令</h4> <p>Unsigned Conditional Transfers</p> <table><thead><tr><th>Mnemonic</th> <th>Condition Tested</th> <th>&quot;Jump If...&quot;</th></tr></thead> <tbody><tr><td>JA/JNBE</td> <td>(CF or ZF) = 0</td> <td>above/not below nor equal</td></tr> <tr><td>JAE/JNB</td> <td>CF = 0 above or</td> <td>equal/not below</td></tr> <tr><td>JB/JNAE</td> <td>CF = 1 below/not</td> <td>above nor equal</td></tr> <tr><td>JBE/JNA</td> <td>(CF or ZF) = 1</td> <td>below or equal/not above</td></tr> <tr><td>JC</td> <td>CF = 1</td> <td>carry</td></tr> <tr><td>JE/JZ</td> <td>ZF = 1</td> <td>equal/zero</td></tr> <tr><td>JNC</td> <td>CF = 0</td> <td>not carry</td></tr> <tr><td>JNE/JNZ</td> <td>ZF = 0</td> <td>not equal/not zero</td></tr> <tr><td>JNP/JPO</td> <td>PF = 0</td> <td>not parity/parity odd</td></tr> <tr><td>JP/JPE</td> <td>PF = 1</td> <td>parity/parity even</td></tr></tbody></table> <hr> <p>Signed Conditional Transfers</p> <table><thead><tr><th>Mnemonic</th> <th>Condition Tested</th> <th>&quot;Jump If...&quot;</th></tr></thead> <tbody><tr><td>JG/JNLE</td> <td>((SF xor OF) or ZF) = 0</td> <td>greater/not less nor equal</td></tr> <tr><td>JGE/JNL</td> <td>(SF xor OF) = 0</td> <td>greater or equal/not less</td></tr> <tr><td>JL/JNGE</td> <td>(SF xor OF) = 1</td> <td>less/not greater nor equal</td></tr> <tr><td>JLE/JNG</td> <td>((SF xor OF) or ZF) = 1</td> <td>less or equal/not greater</td></tr> <tr><td>JNO</td> <td>OF = 0 not</td> <td>overflow</td></tr> <tr><td>JNS</td> <td>SF = 0 not</td> <td>sign (positive, including 0)</td></tr> <tr><td>JO</td> <td>OF = 1</td> <td>overflow</td></tr> <tr><td>JS</td> <td>SF = 1</td> <td>sign (negative)</td></tr></tbody></table> <h3 id="杂项指令"><a href="#杂项指令" class="header-anchor">#</a> 杂项指令</h3> <ul><li>LEA (Load Effective Address) LEA DEST SRC。将SRC(一定是M)的地址存放到DEST(一定是R)中。例如，LEA EBX, EBCDIC_TABLE意为将EBCDIC_TABLE的首地址存放到EBX中。</li> <li>NOP (No Operation) 用于内存对齐。</li> <li>XLAT (Translate) 将AL中的一个字节替换成用户指定的表中的一个字节。当执行XLAT时，EBX是表的首地址，AL中的值为表的索引。执行XLAT后，AL的内容变为表中指定位置的内容，EBX的值不变。因为AL只有8-bit，所以表最多256B。</li></ul> <h2 id="_80386指令集说明"><a href="#_80386指令集说明" class="header-anchor">#</a> 80386指令集说明</h2> <h3 id="操作数和地址的大小-operand-size-address-size"><a href="#操作数和地址的大小-operand-size-address-size" class="header-anchor">#</a> 操作数和地址的大小(Operand-Size, Address-Size)</h3> <ul><li>default: 指令中的D-bit，为0表示16-bit，为1表示32-bit。</li> <li>指令前缀: Operand-Size对应66H,Address-Size对应67H。其效果为对当前D-bit取反。(例如，有66H，D为0，则有效操作数大小为32-bit)</li> <li>栈的Address-Size: 在SS中的数据段的B-bit。为0表示16-bit，即使用SP，为1表示32-bit，即使用ESP。</li> <li>通常32-bit机器默认D-bit为1，指令如果出现66H前缀，表示要改变操作数大小为16-bit。</li></ul> <h3 id="指令格式-2"><a href="#指令格式-2" class="header-anchor">#</a> 指令格式</h3> <p><img src="/assets/img/80386-instruction-format.png" alt="指令格式"></p> <p>可用的指令前缀(H表示该数为16进制)</p> <ul><li>F3H REP prefix (used only with string instructions)</li> <li>F3H REPE/REPZ prefix (used only with string instructions)</li> <li>F2H REPNE/REPNZ prefix (used only with string instructions)</li> <li>F0H LOCK prefix</li></ul> <hr> <p>段覆盖指令前缀</p> <ul><li>2EH CS segment override prefix</li> <li>36H SS segment override prefix</li> <li>3EH DS segment override prefix</li> <li>26H ES segment override prefix</li> <li>64H FS segment override prefix</li> <li>65H GS segment override prefix</li> <li>66H Operand-size override</li> <li>67H Address-size override</li></ul> <h4 id="modr-m-and-sib-bytes"><a href="#modr-m-and-sib-bytes" class="header-anchor">#</a> ModR/M and SIB Bytes</h4> <p><img src="/assets/img/modrm-sib.png" alt="ModR/M&amp;SIB">
x86通过ModR/M字节来指示内存操作数</p> <ul><li>mod(MSB的两位) 和r/m组合为32种可能的值，包括8个寄存器，24种寻址模式(indexing mode)
<ul><li>32位寻址</li> <li>00 通常代表地址值在寄存器内</li> <li>01 通常代表地址值在寄存器内，还要加上modR/M字节后跟的8-bit位移</li> <li>10 通常代表地址值在寄存器内，还要加上modR/M字节后跟的32-bit位移</li> <li>11 取寄存器内的值</li></ul></li> <li>reg/op(mod后三位) 取决于指令的opcode，通常代表寄存器编号，在某些指令中代表opcode信息。</li> <li>r/m(LSB的三位) 可能代表操作数使用的寄存器，看和mod的组合。</li></ul> <p>SIB字节在r/m为100时使用。加不加位移，位移几位看mod字段。</p> <ul><li>ss 比例因子。00:1B, 01:2B, 10:4B, 11:8B。</li> <li>index 索引寄存器使用的通用寄存器编号</li> <li>base 基址寄存器使用的通用寄存器编号</li></ul> <h4 id="如何阅读指令格式说明页"><a href="#如何阅读指令格式说明页" class="header-anchor">#</a> 如何阅读指令格式说明页</h4> <ul><li>i386手册中的汇编语言格式都是Intel格式, 而objdump的默认格式是AT&amp;T格式, 两者的源操作数和目的操作数位置不一样, 千万不要把它们混淆了! 否则你将会陷入难以理解的bug中.</li> <li>opcode
<ul><li>/digit(0-7) ModR/M字节只使用r/m域，reg/opcode字段包含的数字为指令操作码的扩展。对于含有/digit记号的指令形式, 需要通过指令本身的opcode和ModR/M中的扩展opcode共同决定指令的形式, 例如80 /0表示add指令的一种形式, 而80 /5则表示sub指令的一种形式, 只看opcode的首字节80不能区分它们.</li> <li>/r 表示opcode后跟一个ModR/M字节，reg/opcode字段包含的数字为通用寄存器的编码。</li> <li>cb, cw, cd, cp 操作码后的1-byte(cb),2-byte(cw),4-byte(cd),6-byte(cp)用于指定code offset(相对段寄存器的偏移)或是段寄存器的新值。例如CALL指令的一种</li> <li>ib, iw, id 操作码，modR/M或SIB后的1-byte(ib),2-byte(iw),4-byte(id)是指令的立即数。是否有符号有操作码决定</li> <li>+rb, +rw, +rd分别表示8位, 16位, 32位通用寄存器的编码. 和ModR/M中的reg域不一样的是, 这三种记号表示直接将通用寄存器的编号按数值加到opcode中 (也可以看成通用寄存器的编码嵌在opcode的低三位), 因此识别指令的时候可以通过opcode的低三位确定一个寄存器操作数.</li></ul></li> <li>instruction
<ul><li>以下表示操作数的类型</li> <li>rel8 相对地址，范围从包含指令末尾的之前的128个字符到指令结束后的127个字符</li> <li>rel16,rel32 在同一个Segment内的相对地址。operand-size分别为16-bit和32-bit</li> <li>ptr16:16, ptr16:32 FARPOINTER。略。</li> <li>r8 AL, CL, DL, BL, AH, CH, DH, BH中的一个</li> <li>r16 AX, CX, DX, BX, SP, BP, SI, DI中的一个</li> <li>r32 EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI中的一个</li> <li>imm8 8位有符号立即数。和word，DoubleWord的操作数同时使用时，会进行有符号扩展。</li> <li>imm16 16位有符号立即数。</li> <li>imm32 32位有符号立即数。</li> <li>r/m8|16|32 存储在寄存器或内存中的1B|2B|4B操作数</li> <li>m8|16|32 内存中的操作数</li> <li>m16:16, M16:32 FARPOINTER内存操作数。略。</li> <li>m16 &amp; 32, m16 &amp; 16, m32 &amp; 32 内存数据对</li> <li>moffs8, moffs16, moffs32 某些MOV变体使用的内存偏移(相对于当前Segment的基)，这些变体不会用到modR/M字节</li> <li>Sreg 段寄存器。ES=0, CS=1, SS=2, DS=3, FS=4, and GS=5.</li></ul></li> <li>clock 指令执行需要的时钟周期数
<ul><li>n 重复次数</li> <li>m 执行的下一个指令中的组件数量</li> <li>pm 保护模式</li></ul></li> <li>description
<ul><li>有两个操作数时，通常SRC在右，DEST在左。</li> <li><code>&quot;(*&quot;和&quot;*)&quot;</code>之间是注释</li> <li>寄存器的名字代表寄存器的内容。加了<code>[]</code>后，表示寄存器中内容是地址，该地址的内容为<code>[register]</code>代表的内容。</li> <li><code>[]</code> 就是取地址的内容。地址是相对于段基址的地址。</li> <li>A := B 将B的值赋予A</li> <li>OperandSize 代表指令中的 operand-size attribute。AddressSize，StackAddrSize类似</li> <li>eSP 代表ESP或SP，取决于当前栈中的B-bit。</li></ul></li> <li>opcode map
<ul><li>操作数类型可以用Zz表示，Z表示寻址方式，z表示操作数长度</li> <li>A 直接寻址。没有modR/M字节，操作数直接编码在指令中</li> <li>E opcode后面紧接着一个modR/M字节，指定了操作数。操作数要么是通用寄存器，要么是内存地址。如果是内存地址</li> <li>G modR/M字节的reg字段选择一个通用寄存器</li> <li>F EFLAGS</li> <li>I 立即数。其值编码在指令的下一个字节</li> <li>J 指令包含一个相对EIP的相对位移(relative offset)</li> <li>O 指令没有modR/M字节，操作数的偏移量被编码为单词或双字</li> <li>以下为操作数类型标识符，和operand size attribute无关的前面加-。</li> <li>a 两个单字/双字操作数，在内存中</li> <li>c byte/word</li> <li>p 32/48位指针</li> <li>s Six-byte pseudo-descriptor</li> <li>v 单字/双字</li> <li>-b byte</li> <li>-w word</li> <li>-d double-word</li></ul></li></ul> <h3 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// PUSH</span>
<span class="token constant">IF</span> StackAddrSize <span class="token operator">=</span> <span class="token number">16</span>
<span class="token constant">THEN</span>
 <span class="token constant">IF</span> OperandSize <span class="token operator">=</span> <span class="token number">16</span> <span class="token constant">THEN</span>
 <span class="token constant">SP</span> ← <span class="token constant">SP</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
 <span class="token punctuation">(</span><span class="token constant">SS</span><span class="token operator">:</span><span class="token constant">SP</span><span class="token punctuation">)</span> <span class="token function">←</span> <span class="token punctuation">(</span><span class="token constant">SOURCE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token constant">ELSE</span>
 <span class="token constant">SP</span> ← <span class="token constant">SP</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">;</span>
 <span class="token punctuation">(</span><span class="token constant">SS</span><span class="token operator">:</span><span class="token constant">SP</span><span class="token punctuation">)</span> <span class="token function">←</span> <span class="token punctuation">(</span><span class="token constant">SOURCE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token constant">FI</span><span class="token punctuation">;</span>
<span class="token constant">ELSE</span>
 <span class="token constant">IF</span> OperandSize <span class="token operator">=</span> <span class="token number">16</span>
 <span class="token constant">THEN</span>
 <span class="token constant">ESP</span> ← <span class="token constant">ESP</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
 <span class="token punctuation">(</span><span class="token constant">SS</span><span class="token operator">:</span><span class="token constant">ESP</span><span class="token punctuation">)</span> <span class="token function">←</span> <span class="token punctuation">(</span><span class="token constant">SOURCE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token constant">ELSE</span>
 <span class="token constant">ESP</span> ← <span class="token constant">ESP</span> <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">;</span>
 <span class="token punctuation">(</span><span class="token constant">SS</span><span class="token operator">:</span><span class="token constant">ESP</span><span class="token punctuation">)</span> <span class="token function">←</span> <span class="token punctuation">(</span><span class="token constant">SOURCE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token constant">FI</span><span class="token punctuation">;</span>
<span class="token constant">FI</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>e8 cw CALL rel16 首先PUSH(IP)，在EIP=EIP+rel16&amp;0x0000ffff</li> <li>68 PUSH imm</li></ul> <h2 id="intel-和-at-t-格式汇编的语法差异"><a href="#intel-和-at-t-格式汇编的语法差异" class="header-anchor">#</a> Intel 和 AT&amp;T 格式汇编的语法差异</h2> <table><thead><tr><th>type</th> <th>Intel</th> <th>AT&amp;T</th></tr></thead> <tbody><tr><td>Comments</td> <td>;</td> <td>//</td></tr> <tr><td>Instructions</td> <td>Untagged add</td> <td>Tagged with operand sizes: addq</td></tr> <tr><td>Registers</td> <td>eax, ebx, etc.</td> <td>%eax,%ebx, etc.</td></tr> <tr><td>Immediates</td> <td>0x100</td> <td>$0x100</td></tr> <tr><td>Indirect</td> <td>[eax]</td> <td>(%eax)</td></tr> <tr><td>General indirect</td> <td>[base + reg + reg * scale + displacement]</td> <td>displacement(reg, reg, scale)</td></tr></tbody></table> <p>AT&amp;T and Intel syntax use the opposite order for source and destination operands. Intel add eax, 4 is addl $4, %eax. The source, dest convention is maintained for compatibility with previous Unix assemblers. Note that instructions with more than one source operand, such as the enter instruction, do not have reversed order.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/cs/" class="prev router-link-active">
        计算机概述
      </a></span> <span class="next"><a href="/note/cs/isa-riscv.html">
        riscv
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ebdd7216.js" defer></script><script src="/assets/js/2.f48cadb2.js" defer></script><script src="/assets/js/28.414c523f.js" defer></script>
  </body>
</html>
