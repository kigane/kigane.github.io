<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第八章 图形管线(The Graphics Pipeline) | My Documentations</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.b27f4404.css" as="style"><link rel="preload" href="/assets/js/app.0d7685bc.js" as="script"><link rel="preload" href="/assets/js/2.f48cadb2.js" as="script"><link rel="preload" href="/assets/js/13.703893c2.js" as="script"><link rel="prefetch" href="/assets/js/10.5c0987d9.js"><link rel="prefetch" href="/assets/js/11.9fb5010a.js"><link rel="prefetch" href="/assets/js/12.90bbcd94.js"><link rel="prefetch" href="/assets/js/14.42a94239.js"><link rel="prefetch" href="/assets/js/15.80464858.js"><link rel="prefetch" href="/assets/js/16.6718c932.js"><link rel="prefetch" href="/assets/js/17.6837def7.js"><link rel="prefetch" href="/assets/js/18.1f3591c4.js"><link rel="prefetch" href="/assets/js/19.07ec12ef.js"><link rel="prefetch" href="/assets/js/20.76bf1ea5.js"><link rel="prefetch" href="/assets/js/3.b4d4febe.js"><link rel="prefetch" href="/assets/js/4.d1b6e8ed.js"><link rel="prefetch" href="/assets/js/5.7d8c4629.js"><link rel="prefetch" href="/assets/js/6.3a2a2487.js"><link rel="prefetch" href="/assets/js/7.705f55e4.js"><link rel="prefetch" href="/assets/js/8.20d0c527.js"><link rel="prefetch" href="/assets/js/9.34a79032.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b27f4404.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/ChernoLogo.png" alt="My Documentations" class="logo"> <span class="site-name can-hide">My Documentations</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/hazel/" class="nav-link">
  Hazel
</a></div><div class="nav-item"><a href="/cg/" class="nav-link router-link-active">
  ComputerGraphics
</a></div> <a href="https://github.com/kigane/MyBlogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/blog/" class="nav-link">
  Blog
</a></div><div class="nav-item"><a href="/hazel/" class="nav-link">
  Hazel
</a></div><div class="nav-item"><a href="/cg/" class="nav-link router-link-active">
  ComputerGraphics
</a></div> <a href="https://github.com/kigane/MyBlogs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/cg/" aria-current="page" class="sidebar-link">计算机图形学</a></li><li><a href="/cg/ch8.html" aria-current="page" class="active sidebar-link">第八章 图形管线(The Graphics Pipeline)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cg/ch8.html#画线-line-drawing" class="sidebar-link">画线(Line Drawing)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#光栅化三角形-triangle-rasterization" class="sidebar-link">光栅化三角形(Triangle Rasterization)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#裁剪-clipping" class="sidebar-link">裁剪(clipping)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#在变换之前裁剪-方法一" class="sidebar-link">在变换之前裁剪(方法一)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#齐次坐标中的裁剪-方法二" class="sidebar-link">齐次坐标中的裁剪(方法二)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#用平面裁剪" class="sidebar-link">用平面裁剪</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#简单的2d绘制" class="sidebar-link">简单的2D绘制</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#最小的3d管线" class="sidebar-link">最小的3D管线</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#z-buffer" class="sidebar-link">z-Buffer</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#逐顶点着色-per-vertex-shading-也称gouraud-shading" class="sidebar-link">逐顶点着色(Per-vertex Shading，也称Gouraud Shading)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#逐像素着色-per-fragment-shading" class="sidebar-link">逐像素着色(Per-fragment Shading)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#纹理映射-texture-mapping" class="sidebar-link">纹理映射(Texture Mapping)</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#着色频率" class="sidebar-link">着色频率</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#视体剔除" class="sidebar-link">视体剔除</a></li><li class="sidebar-sub-header"><a href="/cg/ch8.html#背面剔除" class="sidebar-link">背面剔除</a></li></ul></li><li><a href="/cg/ch10.html" class="sidebar-link">表面着色</a></li><li><a href="/cg/ch11.html" class="sidebar-link">纹理</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第八章-图形管线-the-graphics-pipeline"><a href="#第八章-图形管线-the-graphics-pipeline" class="header-anchor">#</a> 第八章 图形管线(The Graphics Pipeline)</h1> <p>第二种主要的渲染方法：在屏幕上逐个绘制对象即对象顺序渲染。 与光线追踪不同，在光线追踪中，我们依次考虑每个像素并找到影响其颜色的对象，现在，我们依次考虑每个几何对象并找到可能对其产生影响的像素。查找图像中被几何图元(geometry primitives)占据的所有像素的过程称为光栅化，因此对象顺序渲染也可以被称为光栅化渲染。从对象开始并以更新图像中的像素结束所需的操作序列，称为图形管线(graphics pipeline)。</p> <p>对象顺序渲染由于其效率而获得了巨大的成功。对于大型场景，数据访问模式的管理对于性能至关重要，在场景上进行一次遍历，一次访问几何体的每个位，与重复搜索场景以获取对每个像素着色所需的对象相比，具有明显的优势。</p> <p>本章的标题暗示只有一种方法可以进行对象顺序渲染。 当然，这是不对的。具有两个截然不同目标的图形管线的两个截然不同的示例是用于通过OpenGL和Direct3D等API支持交互式渲染的硬件管线(hardware pipeline)，以及在电影制作中使用的支持RenderMan等API的软件管线(software/production pipeline)。 硬件管线必须运行地足够快，以便对游戏，可视化和用户界面进行实时响应。 生产管线必须尽可能呈现最高质量的动画和视觉效果，并扩展到巨大的场景，但是这样做可能会花费更多的时间。</p> <p>尽管这两种管线由于不同的目标而做出了不同的设计决策，但在大部分是相同的，并且本章会着眼于通用的基础知识，且更偏向硬件管线。</p> <p>可以将对象顺序渲染中需要完成的工作组织成光栅化本身，光栅化前对几何体进行的操作，光栅化后对像素进行的操作。最常见的几何运算是应用矩阵转换（如前两章所述），以将定义几何体的点从对象空间映射到屏幕空间，以使光栅化器的输入以像素坐标表示。 最常见的按像素操作是隐藏表面移除(hidden surface removal)，该操作将离观看者较近的表面安排在离观看者更远的表面前。 每个阶段还可以包含许多其他操作，从而相同的一般过程可以实现各种不同的渲染效果。</p> <p>在本章中，我们将按照四个阶段来讨论图形管线。 几何对象是从交互式应用程序或场景描述文件输入管道的，并且始终用一组顶点对其进行描述。 在顶点处理阶段(Vertex Processing)对顶点进行操作，然后将使用这些顶点的图元发送到光栅化阶段(Rasterization)。 光栅化器将每个图元分解为多个片段(fragments)，每个图元所覆盖的每个像素对应一个片段。 片段在片段处理阶段(Fragment Processing)中进行处理，然后在融合阶段(Blending)将对应于每个像素的各个片段进行组合。</p> <p><img src="/assets/cg/ch8-0.png" alt="ch8-0"></p> <p>我们将从讨论光栅化开始，然后通过一系列示例说明几何和逐像素处理阶段的目的。</p> <h1 id="光栅化-rasterization"><a href="#光栅化-rasterization" class="header-anchor">#</a> 光栅化(Rasterization)</h1> <p>光栅化是对象顺序图形中的核心操作，而光栅化器是任何图形管线的核心。 对于每个传入的图元，光栅化器都有两个工作：枚举该图元所覆盖的像素，并在整个图元上内插值（称为属性），这些属性的目的将在后面的示例中阐明。 光栅化器的输出是一组片段，每个图元所覆盖的每个像素对应一个片段。 每个片段都“生活”在特定像素上，并带有一组属性值。</p> <p>在本章中，我们将介绍光栅化，以期用它来渲染三维场景。 同样的光栅化方法也可用于在2D中绘制线条和形状-尽管用3D图形系统“在幕后”进行所有2D绘图变得越来越普遍。</p> <h2 id="画线-line-drawing"><a href="#画线-line-drawing" class="header-anchor">#</a> 画线(Line Drawing)</h2> <p>大多数图形包都包含一个画线命令，该命令使用屏幕上的两个端点，并在它们之间画一条线。 例如，对端点（1,1）和（3,2）的调用将打开像素（1,1）和（3,2），并在它们之间填充一个像素。 对于一般的屏幕坐标端点（x_0，y_0）和（x_1，y_1），例程应绘制一些“合理”的像素集，来近似它们之间的线段。 此类线通常基于直线方程，我们有两种类型的方程可供选择：隐式和参数化。本节介绍隐式方程。</p> <p>使用隐式方程画线的最常见方法是中点算法(midpoint algorithm)（Pitteway（1967）; van Aken and Novak（1985））。 中点算法最终得出的结果与布雷森汉姆算法（Bresenham，1965）相同，但更为直接。</p> <p>首先，直线的隐式方程形式为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>≡</mo><mrow><mo fence="true">(</mo><msub><mi>y</mi><mrow><mn>0</mn></mrow></msub><mo>−</mo><msub><mi>y</mi><mrow><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><mi>x</mi><mo>+</mo><mrow><mo fence="true">(</mo><msub><mi>x</mi><mrow><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>0</mn></mrow></msub><mo fence="true">)</mo></mrow><mi>y</mi><mo>+</mo><msub><mi>x</mi><mrow><mn>0</mn></mrow></msub><msub><mi>y</mi><mrow><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>1</mn></mrow></msub><msub><mi>y</mi><mrow><mn>0</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x, y) \equiv\left(y_{0}-y_{1}\right) x+\left(x_{1}-x_{0}\right) y+x_{0} y_{1}-x_{1} y_{0}=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">≡</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">)</span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="minner textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="style-wrap reset-textstyle textstyle uncramped" style="top:0em;">)</span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span></p> <p>假定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>⩽</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_0\leqslant x_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.63667em;"></span><span class="strut bottom" style="height:0.78667em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel amsrm">⩽</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。如果不是，就交换它们的值。直线的斜率为</p> <p>m=\cfrac {y_1-y_0}{x_1-x_0}</p> <p>下面的讨论假设m∈(0,1]。可以对m∈(-∞,-1]，m∈(-1,0]和m∈(1,∞）进行类似的讨论。四种情况涵盖了所有可能性。</p> <p>对于m∈(0,1]的情况，直线在x方向的移动速度快于y方向的移动速度。如果我们有一个API，其中y轴指向下方，则你可能担心这是否会使过程更困难，但实际上，我们可以忽略该细节，因为两种情况的代数计算完全相同，所以可以忽略“上”和“下”的几何概念。中点算法的关键假设是我们尽可能绘制没有间隙的最细线。两个像素的对角线相连也被认为是没有间隙的。</p> <p>随着线从左端点向右行进，只有两种可能性：在与左边的像素相同的高度绘制一个像素，或向高一格绘制一个像素。 端点之间的每一列总会有一个像素。没有像素表示间隙，而两个表示线又太粗。对于我们正在考虑的情况，同一行中可能有两个像素； 该线更偏向水平而非竖直(因为斜率小于1)，有时会向右，有时会向上。图8.2中显示了此概念，其中显示了三条“合理的”线，每条线在水平方向上的前进都比在垂直方向上的前进更多。</p> <p><img src="/assets/cg/ch8-2.png" alt="ch8-2"></p> <p>m∈(0,1]的中点算法首先建立最左边的像素和最右边像素的列号，然后循环建立每个像素的行号。 算法是：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>y <span class="token operator">=</span> y0
<span class="token keyword">for</span> x <span class="token operator">=</span> x0 to x1 <span class="token keyword">do</span>
	<span class="token function">draw</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>some condition<span class="token punctuation">)</span> then
		y <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>注意，x和y是整数。 换句话说，算法在“保持从左到右逐列绘制像素，有时在y方向上向上移动。” 算法的关键是要在if语句中建立高效的决策方法。</p> <p>做出选择的有效方法是查看两个潜在像素中心之间的线的中点。 更具体地说，刚绘制的像素(x, y)其中心是在实际屏幕坐标(x, y)处。 向右绘制的候选像素是像素(x+1, y)和(x+1, y+1)。 两个候选像素中心的中点是(x+1, y+0.5)。 如果直线在此中点以下通过，则绘制下面的像素，否则绘制上面的像素。</p> <p>如何确定中点和直线的位置关系呢？曲线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x,y)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>将空间分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>f</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>f</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f&gt;0,f=0,f&lt;0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">=</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mrel">&lt;</span><span class="mord mathrm">0</span></span></span></span>三个区域。曲线 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x, y)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span> 上某一点的梯度向量和曲线的切向量相互垂直，并且指向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x, y)&gt;0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span> 的区域。易知，直线的梯度向量的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>分量为正(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>&lt;</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_0 &lt; x_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">&lt;</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。)，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>的增长会使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>增大，这意味着直线上方是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(x, y)&gt;0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span> 的区域。也就是说，如果中点的函数值f(x+1,y+0.5)&gt;0，说明中点在直线上方(直线经过中点下方)，则if语句可以这么写：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token function">f</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> then
	y <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面的代码对于具有适当斜率的直线（即介于零和一之间的直线）将非常有效。 读者可以计算出其他三种情况，它们只是细节(如果斜率大于1，则应从下到上逐行绘制像素。斜率正负影响下一个像素是取上还是下，左还是右)上有所不同。</p> <p>如果需要更高效，则可使用增量法。 增量法通过重用上一步中的计算来使循环更有效。 在中点算法中，主要计算是对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x + 1,y + 0.5)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">5</span><span class="mclose">)</span></span></span></span>的求值。 请注意，在循环中，在第一次迭代之后，我们已经评估了f(x − 1,y + 0.5)或f(x − 1,y − 0.5)。 注意到以下关系：</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>+</mo><mo>(</mo><msub><mi>y</mi><mn>0</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x+1, y)=f(x,y)+(y_0-y_1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>+</mo><mo>(</mo><msub><mi>y</mi><mn>0</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo><mo>+</mo><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x+1, y+1)=f(x,y)+(y_0-y_1)+(x_1-x_0)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p> <p>这使我们可以编写代码的增量版本：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>y <span class="token operator">=</span> y0
d <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y0 <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token operator">=</span> x0 to x1 <span class="token keyword">do</span>
	<span class="token function">draw</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
	<span class="token keyword">if</span> d <span class="token operator">&lt;</span> <span class="token number">0</span> then
		y <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">1</span>
		d <span class="token operator">=</span> d <span class="token operator">+</span> <span class="token punctuation">(</span>x1 − x0<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>y0 − y1<span class="token punctuation">)</span>
	<span class="token keyword">else</span>
		d <span class="token operator">=</span> d <span class="token operator">+</span> <span class="token punctuation">(</span>y0 − y1<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>此代码应运行得更快，因为与非增量版本相比，它用很少的额外设置成本换取了更有效率的循环。但由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>0</mn><mi mathvariant="normal">.</mi><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y + 0.5)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">5</span><span class="mclose">)</span></span></span></span>的求值包含了很多加法运算，可能会累积更多的数值错误。但是，鉴于行很少超过几千个像素，因此这种错误不会很严重。通过将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub><mo>)</mo><mo>+</mo><mo>(</mo><msub><mi>y</mi><mn>0</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_1-x_0)+(y_0-y_1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>y</mi><mn>0</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(y_0-y_1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>存储为变量，可以更快地执行循环。 我们可能希望一个好的编译器能够为我们做到这一点，但是如果代码很关键，那么最好检查一下编译结果以确保。</p> <h2 id="光栅化三角形-triangle-rasterization"><a href="#光栅化三角形-triangle-rasterization" class="header-anchor">#</a> 光栅化三角形(Triangle Rasterization)</h2> <p>我们经常想绘制一个屏幕坐标为p_0 =(x_0,y_0)，p_1 =(x_1,y_1)和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">p_1 =(x_1,y_1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">p</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>的2D三角形。 这类似于画线的问题，但是它有一些自己的细微之处。 与画线一样，我们可能希望用顶点的值为三角形内的点插值(颜色或其他属性)。 如果我们有重心坐标，则这很简单。 例如，如果顶点具有颜色\mathbf c_0，\mathbf c_1和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf c_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span><span class="mord mathbf">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，则三角形中具有重心坐标(α,β,γ)的一点的颜色为</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">c</mi><mo>=</mo><mi>α</mi><msub><mi mathvariant="bold">c</mi><mn>0</mn></msub><mo>+</mo><mi>β</mi><msub><mi mathvariant="bold">c</mi><mn>1</mn></msub><mo>+</mo><mi>γ</mi><msub><mi mathvariant="bold">c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf c = \alpha \mathbf c_0+\beta \mathbf  c_1+\gamma \mathbf c_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">c</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.0037em;">α</span><span><span class="mord mathbf">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05278em;">β</span><span><span class="mord mathbf">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05556em;">γ</span><span><span class="mord mathbf">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p> <p>这种颜色插值方法以发明者的名字命名为Gouraud插值。</p> <p>光栅化三角形的另一个细微之处在于光栅化过程中的三角形通常有共享的顶点和边线。 即要光栅化相邻的三角形，所以不会有孔(holes)。 我们可以通过使用中点算法绘制每个三角形的轮廓，然后填充内部像素来实现。这意味着相邻的三角形的边会被绘制两次。如果相邻的三角形具有不同的颜色，则图像将取决于两个三角形的绘制顺序。 避免出现顺序问题并消除孔的最常见的三角形光栅化方法是使用以下约定：当且仅当像素的中心在三角形内(即像素中心的重心坐标都在开区间(0, 1))时才绘制像素。 这就提出了一个问题，即如果中心恰好在三角形的边缘上，该怎么办。 有几种处理此问题的方法，本节稍后将对此进行讨论。 关键的观察结果是，重心坐标使我们能够决定是否要绘制像素以及如果要从顶点内插颜色，则该像素应为哪种颜色。 因此，我们对三角形进行光栅化的问题归结为有效地找到像素中心的重心坐标。 蛮力光栅化算法为：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">for</span> all x <span class="token keyword">do</span>
	<span class="token keyword">for</span> all y <span class="token keyword">do</span>
		<span class="token function">compute</span> <span class="token punctuation">(</span>α<span class="token punctuation">,</span> β<span class="token punctuation">,</span> γ<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>α ∈ <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> and β ∈ <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> and γ ∈ <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> then
			c <span class="token operator">=</span> α<span class="token operator">*</span>c0 <span class="token operator">+</span> β<span class="token operator">*</span>c1 <span class="token operator">+</span> γ<span class="token operator">*</span>c2
			<span class="token function">drawpixel</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> with color c
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>该算法的其余部分将外部循环限制为较小的一组候选像素，以使重心计算更高效。</p> <p>我们可以通过找到三个顶点的边界矩形并仅在该矩形上循环以绘制候选像素来简单地增加效率。我们可以使用公式计算重心坐标。 这产生了算法：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>xmin <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>xi<span class="token punctuation">)</span>
xmax <span class="token operator">=</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>xi<span class="token punctuation">)</span>
ymin <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>yi<span class="token punctuation">)</span>
ymax <span class="token operator">=</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>yi<span class="token punctuation">)</span>
<span class="token keyword">for</span> y <span class="token operator">=</span> ymin to ymax <span class="token keyword">do</span>
	<span class="token keyword">for</span> x <span class="token operator">=</span> xmin to xmax <span class="token keyword">do</span>
		α <span class="token operator">=</span> <span class="token function">f12</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">f12</span><span class="token punctuation">(</span>x0<span class="token punctuation">,</span> y0<span class="token punctuation">)</span>
		β <span class="token operator">=</span> <span class="token function">f20</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">f20</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span>
		γ <span class="token operator">=</span> <span class="token function">f01</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">f01</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>α <span class="token operator">&gt;</span> <span class="token number">0</span> and β <span class="token operator">&gt;</span> <span class="token number">0</span> and γ <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> then
			c <span class="token operator">=</span> α<span class="token operator">*</span>c0 <span class="token operator">+</span> β<span class="token operator">*</span>c1 <span class="token operator">+</span> γ<span class="token operator">*</span>c2
			<span class="token function">drawpixel</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> with color c
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{ij}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>为：</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>0</mn><mn>1</mn></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>y</mi><mrow><mn>0</mn></mrow></msub><mo>−</mo><msub><mi>y</mi><mrow><mn>1</mn></mrow></msub><mo>)</mo><mi>x</mi><mo>+</mo><mo>(</mo><msub><mi>x</mi><mrow><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>0</mn></mrow></msub><mo>)</mo><mi>y</mi><mo>+</mo><msub><mi>x</mi><mrow><mn>0</mn></mrow></msub><msub><mi>y</mi><mrow><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>1</mn></mrow></msub><msub><mi>y</mi><mrow><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f _ { 01 } ( x , y ) = ( y _ { 0 } - y _ { 1 } ) x + ( x _ { 1 } - x _ { 0 } ) y + x _ { 0 } y _ { 1 } - x _ { 1 } y _ { 0 }</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>1</mn><mn>2</mn></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>y</mi><mrow><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>y</mi><mrow><mn>2</mn></mrow></msub><mo>)</mo><mi>x</mi><mo>+</mo><mo>(</mo><msub><mi>x</mi><mrow><mn>2</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>1</mn></mrow></msub><mo>)</mo><mi>y</mi><mo>+</mo><msub><mi>x</mi><mrow><mn>1</mn></mrow></msub><msub><mi>y</mi><mrow><mn>2</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>2</mn></mrow></msub><msub><mi>y</mi><mrow><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f _ { 12 } ( x , y ) = ( y _ { 1 } - y _ { 2 } ) x + ( x _ { 2 } - x _ { 1 } ) y + x _ { 1 } y _ { 2 } - x _ { 2 } y _ { 1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>2</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>y</mi><mrow><mn>2</mn></mrow></msub><mo>−</mo><msub><mi>y</mi><mrow><mn>0</mn></mrow></msub><mo>)</mo><mi>x</mi><mo>+</mo><mo>(</mo><msub><mi>x</mi><mrow><mn>0</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>2</mn></mrow></msub><mo>)</mo><mi>y</mi><mo>+</mo><msub><mi>x</mi><mrow><mn>2</mn></mrow></msub><msub><mi>y</mi><mrow><mn>0</mn></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mn>0</mn></mrow></msub><msub><mi>y</mi><mrow><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f _ { 20 } ( x , y ) = ( y _ { 2 } - y _ { 0 } ) x + ( x _ { 0 } - x _ { 2 } ) y + x _ { 2 } y _ { 0 } - x _ { 0} y _ { 2 }</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p> <p>注意，我们将测试α∈(0,1)换为α&gt; 0，因为如果所有α，β，γ均为正，则它们都小于1，因为α+β+γ= 1。 也可以只计算三个重心变量中的两个，并用该关系中计算第三个变量。但使用增量算法时，这种方法是否可以像画线一样节省计算量仍然不清楚。 每次计算α，β和γ，都要计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>A</mi><mi>x</mi><mo>+</mo><mi>B</mi><mi>y</mi><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">f(x,y)= Ax + By +C</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">A</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span>。在内层循环中，只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>改变，并且只改变一个单位。请注意，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">f(x + 1,y)= f(x,y)+A</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit">A</span></span></span></span>。这是增量算法的基础。 在外循环中，求值从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y+1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，因此也可以达到类似的效率提升。 因为α，β和γ在循环中随常数增量递增，颜色<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">c</mi></mrow><annotation encoding="application/x-tex">\mathbf c</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.44444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">c</span></span></span></span>也在递增。  例如，像素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x+1,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的红色值与像素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的红色值差了一个常数，可以预先计算。 一个颜色插值的三角形的例子如图所示。</p> <p><img src="/assets/cg/ch8-4.png" alt="ch8-4"></p> <p><strong>处理三角形边上的像素</strong></p> <p>我们仍未讨论如何处理正好位于三角形边缘的像素。 如果一个像素恰好在三角形的边缘，那么它也在相邻三角形的边缘。 没有明显的方法可以将像素确定为相邻三角形中的哪一个。 最糟糕的决定是不绘制像素，因为这样在两个三角形之间会产生孔。 更好一点的方法是让两个三角形都绘制像素。 如果三角形是透明的，则将导致双色(double-coloring)。 我们还是想将像素精确地授予三角形中的一个，并且我们希望此过程很简单； 只要选择明确，选择哪个三角形都没有关系。</p> <p><img src="/assets/cg/ch8-5.png" alt="ch8-5"></p> <p>注意到任何屏幕外的点都肯定在共享边的某一侧；对于两个不重叠的相邻三角形，不在共享边上的顶点彼此在共享边的两侧。 这两个顶点中的某一个恰好与屏幕外的点同处于共享边同一侧。 这是测试的基础。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>代表点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>与直线的有符号距离，如果点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">q</span></span></span></span>具有相同的符号，说明两点处于直线的同一侧，这可以通过检验<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>q</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">pq&gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span>进行测试，在大多数环境中都非常有效。</p> <p>请注意，此测试并不完美，因为穿过共享边的线也可能会穿过屏幕外的点。但至少大大减少了有问题的案例的数量。 使用哪个屏幕外的点是任意的，(x, y) =(−1, −1)通常是一个的好选择。 我们将需要添加一个检查，以检查点是否恰好在边缘上。 我们希望对于普通情况（即点完全在内部或外部的测试）不进行此检查。 这表明</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>xmin <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>xi<span class="token punctuation">)</span>
xmax <span class="token operator">=</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>xi<span class="token punctuation">)</span>
ymin <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span>yi<span class="token punctuation">)</span>
ymax <span class="token operator">=</span> <span class="token function">ceiling</span><span class="token punctuation">(</span>yi<span class="token punctuation">)</span>
fα <span class="token operator">=</span> <span class="token function">f12</span><span class="token punctuation">(</span>x0<span class="token punctuation">,</span> y0<span class="token punctuation">)</span>
fβ <span class="token operator">=</span> <span class="token function">f20</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span>
fγ <span class="token operator">=</span> <span class="token function">f01</span><span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span>
<span class="token keyword">for</span> y <span class="token operator">=</span> ymin to ymax <span class="token keyword">do</span>
	<span class="token keyword">for</span> x <span class="token operator">=</span> xmin to xmax <span class="token keyword">do</span>
		α <span class="token operator">=</span> <span class="token function">f12</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">/</span>fα
		β <span class="token operator">=</span> <span class="token function">f20</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">/</span>fβ
		γ <span class="token operator">=</span> <span class="token function">f01</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">/</span>fγ
		<span class="token keyword">if</span> <span class="token punctuation">(</span>α ≥ <span class="token number">0</span> and β ≥ <span class="token number">0</span> and γ ≥ <span class="token number">0</span><span class="token punctuation">)</span> then
			<span class="token keyword">if</span> <span class="token punctuation">(</span>α <span class="token operator">&gt;</span> <span class="token number">0</span> or fα<span class="token operator">*</span><span class="token function">f12</span><span class="token punctuation">(</span>−<span class="token number">1</span><span class="token punctuation">,</span> −<span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">and</span>
				<span class="token punctuation">(</span>β <span class="token operator">&gt;</span> <span class="token number">0</span> or fβ<span class="token operator">*</span><span class="token function">f20</span><span class="token punctuation">(</span>−<span class="token number">1</span><span class="token punctuation">,</span> −<span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">and</span>
				<span class="token punctuation">(</span>γ <span class="token operator">&gt;</span> <span class="token number">0</span> or fγ<span class="token operator">*</span><span class="token function">f01</span><span class="token punctuation">(</span>−<span class="token number">1</span><span class="token punctuation">,</span> −<span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> then
				c <span class="token operator">=</span> α<span class="token operator">*</span>c0 <span class="token operator">+</span> β<span class="token operator">*</span>c1 <span class="token operator">+</span> γ<span class="token operator">*</span>c2
				<span class="token function">drawpixel</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> with color c
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>我们可能希望上面的代码仅在我们对两个三角形使用完全相同的直线方程式的情况下，才能消除孔和重复绘制。 实际上，仅当两个共享顶点在每个三角形的绘制调用中具有相同顺序时，线方程才是相同的。 否则等式可能会翻转符号。 取决于编译器是否更改操作顺序，这可能是一个问题。 因此，如果需要可靠的实现，则可能需要检查编译器和算术单元的详细信息。 上面的伪代码中的前四行必须仔细编码，以处理边缘恰好碰到像素中心的情况。</p> <p>除了要实现经得起检验的增量算法，还要注意几个潜在的早期退出点。 例如，如果α为负，则无需计算β或γ。 尽管这很可能会提高速度，但profiling始终是一个好主意；多余的分支可能会减少流水线操作或并发性，并且可能会使代码变慢。 因此，与往常一样，如果代码是关键部分，请测试所有看上去具有吸引力的优化。</p> <p>上面代码的另一个细节是，对于退化的三角形可能会发生除以零错误，即f_γ= 0。应适当考虑浮点误差条件，或引入其他测试。</p> <h2 id="裁剪-clipping"><a href="#裁剪-clipping" class="header-anchor">#</a> 裁剪(clipping)</h2> <p>仅仅将图元转换到屏幕空间并对其进行光栅化本身并不能完全起作用。 这是因为视图体积之外的图元（尤其是在眼睛后面的图元）最终也会被光栅化，从而导致错误的结果。 例如，考虑图中所示的三角形。</p> <p><img src="/assets/cg/ch8-6.png" alt="ch8-6"></p> <p>视体内有两个顶点，但第三个顶点位于眼睛后面。 投影转换将这个顶点映射到远平面后面的一个毫无意义的位置，如果允许发生这种情况，三角形将被不正确地光栅化。 因此，在光栅化之前必须进行裁剪(clipping)操作，以删除可能延伸到眼睛后面的图元部分。</p> <p>裁剪是图形中的常见操作，每当一个几何实体“切割”另一实体时就需要裁剪。 例如，用一个平面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>去切三角形，如果顶点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>坐标的符号不同，则平面会将三角形切成两部分。 在剪裁的大多数应用中，三角形在平面“错误”侧的部分将被丢弃。 单个平面的操作如图所示。</p> <p>在裁剪以准备进行光栅化时，“错误”侧是视图体积之外的一侧。 始终将视图体积外部的所有几何体剪掉（即，剪裁该体积的所有六个面）是安全的，但是许多系统仅裁剪近平面。</p> <p>本节讨论裁剪模块的基本实现。 那些对实现工业速度削波器(clipper)感兴趣的人应该参阅本章末尾注释中提到的Blinn的书。</p> <p>实施裁剪的两种最常见的方法是</p> <p>1.在世界坐标中使用六个平面来限制截断的视锥</p> <p>2.在4D变换空间中进行齐次划分之前裁剪。</p> <p>对于每个三角形，可以使用以下方法有效地实现这两种可能性（J. Blinn，1996）：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">for</span> each of six planes <span class="token keyword">do</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>triangle entirely outside of plane<span class="token punctuation">)</span> then
		<span class="token keyword">break</span> <span class="token punctuation">(</span>triangle is not visible<span class="token punctuation">)</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> triangle spans plane then
		clip triangle
		<span class="token keyword">if</span> <span class="token punctuation">(</span>quadrilateral is left<span class="token punctuation">)</span> then
			<span class="token keyword">break</span> into two triangles
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="/assets/cg/ch8-7.png" alt="ch8-7"></p> <h2 id="在变换之前裁剪-方法一"><a href="#在变换之前裁剪-方法一" class="header-anchor">#</a> 在变换之前裁剪(方法一)</h2> <p>该实现简单明了。 唯一的问题是，“六个平面方程是什么？” 因为这些方程对于在单个图像中渲染的所有三角形都是相同的，所以我们不需要非常有效地计算它们。也因此，我们可以反转图5.11所示的变换并将其应用于变换后的视体的八个顶点：</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>)</mo><mo>=</mo><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mi>r</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x, y, z) =(l, b, n)/
(r, b, n)/
(l, t, n)/
(r, t, n)/
(l, b, f)/
(r, b, f)/
(l, t, f)/
(r, t, f)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span></p> <p>可以从这里推导出平面方程。 或者，我们可以使用向量几何直接从视图参数获取平面。</p> <h2 id="齐次坐标中的裁剪-方法二"><a href="#齐次坐标中的裁剪-方法二" class="header-anchor">#</a> 齐次坐标中的裁剪(方法二)</h2> <p>出人意料的是，通常的实现是在除<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span></span>之前在齐次坐标中进行裁剪。 此处的视体为4D，并以3D体积（超平面）为边界。 这些是：</p>
\begin{aligned}{c} −x + lw = 0,\\
x − rw = 0,\\
−y + bw = 0,\\
y − tw = 0,\\
−z + nw = 0,\\
z − fw = 0.\end{aligned}
<p>这些平面非常简单，因此效率比方法1更好。仍可以通过将视体[l,r]×[b,t]×[f,n]转换为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo>]</mo><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">[0,1]^3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mclose"><span class="mclose">]</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>来改善它们。事实证明，这种三角形的裁剪方式并不比在3D中复杂。</p> <h2 id="用平面裁剪"><a href="#用平面裁剪" class="header-anchor">#</a> 用平面裁剪</h2> <p>无论我们选择哪种方法，都必须在平面上裁剪。已知点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">q</mi></mrow><annotation encoding="application/x-tex">\mathbf q</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">q</span></span></span></span>和法向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">n</mi></mrow><annotation encoding="application/x-tex">\mathbf n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.44444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">n</span></span></span></span>的隐式方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi mathvariant="bold">p</mi><mo>)</mo><mo>=</mo><mi mathvariant="bold">n</mi><mo>(</mo><mi mathvariant="bold">p</mi><mo>−</mo><mi mathvariant="bold">q</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(\mathbf p)=\mathbf n(\mathbf p-\mathbf q)=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">p</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathbf">n</span><span class="mopen">(</span><span class="mord mathbf">p</span><span class="mbin">−</span><span class="mord mathbf">q</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>，经常写为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi mathvariant="bold">p</mi><mo>)</mo><mo>=</mo><mi mathvariant="bold">n</mi><mo>⋅</mo><mi mathvariant="bold">p</mi><mo>+</mo><mi>D</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(\mathbf p)=\mathbf n\cdot\mathbf p+D=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">p</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathbf">n</span><span class="mbin">⋅</span><span class="mord mathbf">p</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span></p> <p>有趣的是，该等式不仅描述了3D平面，而且还描述了2D线和4D体积。 通常将所有这些实体按其适当的维度称为平面。</p> <p>如果在点a和点b之间有一条线段，则可以使用第12.4.3节中所述的BSP树程序中的3D三角形边沿切割技术用平面将其“裁剪”。 这里，通过检查<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(b)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span>的符号来测试点a和b是否在平面f(\mathbf p)＝ 0的相对侧上。 通常，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi mathvariant="bold">p</mi><mo>)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(\mathbf p)&lt;0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">p</span><span class="mclose">)</span><span class="mrel">&lt;</span><span class="mord mathrm">0</span></span></span></span>定义为在平面“内部”，而将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi mathvariant="bold">p</mi><mo>)</mo><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(\mathbf p)&gt; 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">p</span><span class="mclose">)</span><span class="mrel">&gt;</span><span class="mord mathrm">0</span></span></span></span>定义为在平面“外部”。 如果平面确实分割了线，那么可以解出交点：</p> <p>直线：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">p</mi><mo>=</mo><mi mathvariant="bold">a</mi><mo>+</mo><mi>t</mi><mo>(</mo><mi mathvariant="bold">b</mi><mo>−</mo><mi mathvariant="bold">a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathbf p = \mathbf a+t(\mathbf b-\mathbf a)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">p</span><span class="mrel">=</span><span class="mord mathbf">a</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathbf">b</span><span class="mbin">−</span><span class="mord mathbf">a</span><span class="mclose">)</span></span></span></span></p> <p>代入平面：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">n</mi><mo>⋅</mo><mo>(</mo><mi mathvariant="bold">a</mi><mo>+</mo><mi>t</mi><mo>(</mo><mi mathvariant="bold">b</mi><mo>−</mo><mi mathvariant="bold">a</mi><mo>)</mo><mo>)</mo><mo>+</mo><mi>D</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbf n\cdot(\mathbf a+t(\mathbf b-\mathbf a))+D=0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">n</span><span class="mbin">⋅</span><span class="mopen">(</span><span class="mord mathbf">a</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathbf">b</span><span class="mbin">−</span><span class="mord mathbf">a</span><span class="mclose">)</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span></p> <p>解得：$t=\cfrac{\mathbf n \cdot \mathbf a+D}{\mathbf n \cdot (\mathbf a-\mathbf b)} $</p> <p>找到交点后就可以将线段&quot;剪短&quot;。</p> <p>要裁剪一个三角形，我们可以再次按照第12.4.3节的步骤生成一个或两个三角形。</p> <h1 id="光栅化之前和之后的操作"><a href="#光栅化之前和之后的操作" class="header-anchor">#</a> 光栅化之前和之后的操作</h1> <p>在对图元进行光栅化之前，定义图元的顶点必须位于屏幕坐标中，并且必须已经知道应该在图元上插值的颜色或其他属性。 准备此数据是管线顶点处理阶段的工作。 在此阶段，通过模型(modeling)，视图(viewing)和投影(projection)变换来转换输入的顶点，将它们从原始坐标映射到屏幕空间（在此位置以像素为单位）。同时，根据需要转换其他信息，例如颜色，表面法线或纹理坐标。 我们将在下面的示例中讨论这些其他属性</p> <p>光栅化后，将进行进一步处理以计算每个片段(fragment)的颜色和深度。该处理可以很简单，就像只经过插值的颜色并使用光栅化器计算深度一样。 或可能涉及复杂的着色处理。最后，混合阶段将合并由（可能是多个）图元生成的片段(可能是不同图元的重叠像素，包含了各个图元的信息)，以计算最终的颜色。 最常见的混合方法是选择深度最小（最靠近眼睛）的片段颜色。</p> <p>通过示例可以最好地说明不同阶段的目的。</p> <h2 id="简单的2d绘制"><a href="#简单的2d绘制" class="header-anchor">#</a> 简单的2D绘制</h2> <p>最简单的流水线在顶点或片段阶段不执行任何操作，在混合阶段，每个片段的颜色只会覆盖之前的片段的值。 该应用程序直接在像素坐标中提供图元，而光栅化器完成所有工作。 这种基本安排是许多用于绘制用户界面，绘图，图形和其他2D内容的简单，较旧的API的本质。 通过为每个图元的所有顶点指定相同的颜色，可以绘制纯色形状，并且我们的模型管线还支持使用插值法平滑地改变颜色。</p> <h2 id="最小的3d管线"><a href="#最小的3d管线" class="header-anchor">#</a> 最小的3D管线</h2> <p>要以3D方式绘制对象，对2D绘制管道的唯一更改就是一个矩阵转换：顶点处理阶段将输入的顶点位置乘以建模，相机，投影和视口矩阵的乘积，从而得到屏幕空间三角形，然后以在2D中相同的方式绘制空间三角形。</p> <p>最小3D管道的一个问题是，为了正确地实现遮挡关系（要使更近的对象位于更远的对象之前），必须按从前到后的顺序绘制基元。 这被称为用于隐藏表面去除的画家算法(the painter’s algorithm)，类似于先画一幅画的背景，然后在其上画一幅前景。 画家算法是隐藏表面去除的一种完美有效的方法，但它有几个缺点。它不能处理彼此相交的三角形，因为没有正确的绘制顺序。 同样，即使不相交，也可以在遮挡环(occlusion cycle)中排列几个三角形，如图所示，这是另一种不存在从后到前顺序的情况。 最重要的是，按深度对基元进行排序的速度很慢，尤其是对于大型场景而言，而且会扰乱了使对象顺序渲染如此之快的高效的数据流。 图8.10显示了未按深度对对象进行排序时该过程的结果。</p> <p><img src="/assets/cg/ch8-8.png" alt="ch8-8"></p> <h2 id="z-buffer"><a href="#z-buffer" class="header-anchor">#</a> z-Buffer</h2> <p>实际上，画家算法很少使用； 取而代之的是使用一种简单有效的隐藏表面去除算法，称为z-buffer算法。 该方法非常简单：在每个像素处，我们都跟踪到到目前为止绘制的最接近曲面的距离，并且丢弃比该距离更远的片段。每个像素分配一个额外的值（称为深度或z值）来存储这个最接近的距离。 深度缓冲区(depth buffer)或z-buffer是深度值网格的名称。</p> <p>通过将每个片段的深度与存储在z-buffer中的当前值进行比较，在片段混合阶段中实现了z-buffer算法。如果片段的深度更近，则其颜色和深度值都会覆盖当前颜色和深度缓冲区(frame buffer &amp; z-buffer)中的值。 如果片段的深度更远，则将其丢弃。为了确保第一个片段将通过深度测试，将z-buffer初始化为最大深度（远平面的深度）。 无论绘制表面的顺序如何，相同的片段都将赢得深度测试，并且图像将相同。</p> <p>z-buffer算法要求每个片段都携带一个深度。 只需通过将z-坐标作为顶点属性进行插值即可完成，就像插值颜色或其他属性一样。</p> <p><strong>精度问题</strong></p> <p>实际上，存储在缓冲区中的z值是非负整数。 这比真正的浮点数更好，因为z-buffer需要占用及其有限的快速内存。</p> <p>使用整数会导致一些精度问题。 如果B值范围为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>B</mi><mo>−</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding="application/x-tex">\{0,1,...,B -1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">{</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">}</span></span></span></span>，则可以将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span>映射到近平面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">z = n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord mathit">n</span></span></span></span>，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">B-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>映射到远平面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">z = f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>。 注意，在此讨论中，我们假设z，n和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>为正。 这将产生与负数情况相同的结果，但是参数的细节更易于理解。我们将每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span></span>值分配到深度区间长度为Δz=(f − n)/ B的“桶”(bucket)。 因为内存有限，所以B应该尽可能小。如果我们分配b位来存储z值，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>=</mo><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">B = 2^b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.849108em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">b</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。需要足够的位来确保任何三角形的深度都能映射到不同的深度容器(depth bins)。</p> <p>例如，如果渲染的场景中三角形的间隔至少为一米，则Δz&lt;1应该会生成没有瑕疵(artifacts)的图像。 有两种减小Δz的方法：将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>移近些或增大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span>。 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span></span></span></span>是固定的（在API或特定的硬件平台上是固定的），则调整<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>是唯一的选择。</p> <p>创建透视图像时，必须格外小心地处理z-buffer的精度(这里使用的z值是经过透视投影之后的z值)。 因为Δz在透视归一化(perspective divide)之后使用。回顾第7.3节，透视的结果是：</p> <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><mi>n</mi><mo>+</mo><mi>f</mi><mo>−</mo><mfrac><mrow><mi>f</mi><mi>n</mi></mrow><mrow><msub><mi>z</mi><mi>w</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">z=n+f-\frac{fn}{z_w}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.9322159999999999em;"></span><span class="strut bottom" style="height:1.382216em;vertical-align:-0.44999999999999996em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mbin">−</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.04398em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.44610799999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p> <p>实际的容器深度与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">z_w</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.04398em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02691em;">w</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>相关，而不是与透视归一化后的深度z有关。 我们可以近似得知容器的大小：</p> <p>\Delta z=z_2-z_1=-\cfrac {fn}{z_{w1}}-(-\cfrac {fn}{z_{w2}})=\cfrac {fn(z_{w2}-z_{w1})}{z_{w1}z_{w1}} \approx \cfrac {fn\Delta z_w}{z_w^2}</p> <p>由\Delta z \approx \cfrac {fn\Delta z_w}{z_w^2}，推得\Delta z_w \approx \cfrac {z_w^2\Delta z}{fn}。则每个整数对应的最大的深度容器应该在远平面附近，\Delta z_w^{max} \approx \cfrac {f\Delta z}{n}。</p> <p>请注意，如果我们不想丢失眼前的物体，自然会选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>，从而导致无限大的容器，这是非常糟糕的情况。 为了使Δz^{max}_w尽可能小，我们希望最小化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>并最大化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>。 因此，仔细选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>总是很重要的</p> <h2 id="逐顶点着色-per-vertex-shading-也称gouraud-shading"><a href="#逐顶点着色-per-vertex-shading-也称gouraud-shading" class="header-anchor">#</a> 逐顶点着色(Per-vertex Shading，也称Gouraud Shading)</h2> <p>到目前为止，将三角形发送到管线中的应用程序负责设置颜色。 光栅化器只对颜色进行插值，然后将它们直接写入输出图像。 对于某些应用程序，这已经足够了，但是在许多情况下，我们希望使用着色(shading)来绘制3D对象，并使用与第4章中用于图像顺序渲染的照明方程式相同的照明方程式。回想一下，这些方程式需要光线方向 ，眼睛方向和表面法线以计算表面的颜色。</p> <p>处理着色计算的一种方法是在顶点阶段执行它们。 应用程序在顶点处提供法线向量，并且独立的提供了灯光的位置和颜色（它们在整个曲面上没有变化，因此不需要为每个顶点指定它们）。 对于每个顶点，根据摄影机，灯光和顶点的位置计算出朝向观察者的方向和朝向每个光线的方向。 评估所需的着色方程式以计算颜色，然后将其作为顶点颜色传递到光栅化器。 逐顶点着色有时也称为Gouraud着色。</p> <p>选择进行该着色计算的坐标系很重要。世界空间或相机空间是不错的选择。 选择在世界空间中观察时正交的坐标系很重要，因为着色方程取决于矢量之间的角度，而建模或透视投影等变换等非均匀缩放并不会保留这些角度。相机空间的着色具有不需要跟踪照相机位置的优点，照相机始终位于相机空间的原点，而在正交/透视投影中，视线方向始终为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">+ z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">+</span><span class="mord mathit" style="margin-right:0.04398em;">z</span></span></span></span>。</p> <p>逐顶点着色的缺点是无法在着色中生成任何小于用于绘制曲面的图元的细节，因为它仅对每个顶点计算一次着色，而不会在两个顶点之间计算着色。例如，在用两个大三角形绘制的地板上，在房间中间用光源照明的情况下，仅在房间的各个角落计算着色，导致中心部分因为插值而变得黑暗。 另外，必须使用足够小的图元绘制带有镜面高光的曲面，以正确显示高光。</p> <p><img src="/assets/cg/ch8-9.png" alt="ch8-9"></p> <p>使用Gouraud Shading的两个球体。因为三角形很大，插值的瑕疵清晰可见。</p> <p><img src="/assets/cg/ch8-10.png" alt="ch8-10"></p> <p>使用逐像素着色的两个球体。因为三角形很大，插值的瑕疵清晰可见。</p> <h2 id="逐像素着色-per-fragment-shading"><a href="#逐像素着色-per-fragment-shading" class="header-anchor">#</a> 逐像素着色(Per-fragment Shading)</h2> <p>为了避免与逐顶点着色的插值瑕疵，我们可以在片段阶段进行着色计算来避免对颜色进行插值。 在逐像素着色中，使用相同的着色方程，但使用插值出的向量对每个片段进行评估，而不是使用应用程序中的向量对每个顶点进行评估。</p> <p>在每片段着色中，着色所需的几何信息通过光栅化器作为属性传递，因此顶点阶段必须与片段阶段配合才能适当地准备数据。 一种方法是对相机空间表面法线和相机空间顶点位置进行插值，然后可以像在逐顶点着色中一样使用它们。</p> <h2 id="纹理映射-texture-mapping"><a href="#纹理映射-texture-mapping" class="header-anchor">#</a> 纹理映射(Texture Mapping)</h2> <p>纹理（在第11章中讨论）是用于在表面着色时增加额外细节的图像，否则这些表面看起来过于均匀和人为。想法很简单：每次计算着色时，我们都会从纹理中读取着色计算中使用的值之一（例如，漫反射颜色），而不是使用附加到要渲染的几何图形的属性值。 此操作称为纹理查找(texture lookup)：着色代码指定纹理坐标(texture coordinate)即纹理域中的一个点，纹理映射系统在纹理图像中找到该点的值并将其返回。 然后，将纹理值用于着色计算中。</p> <p>定义纹理坐标的最常见方法是简单地使纹理坐标成为另一个顶点属性。 然后，每个图元都知道它在纹理中的位置。</p> <h2 id="着色频率"><a href="#着色频率" class="header-anchor">#</a> 着色频率</h2> <p>有关在何处放置着色计算的决定取决于颜色变化的速度（即所计算的细节的规模）。 具有大规模特征的着色（例如曲面上的漫反射阴影）可以不用频繁计算，并使用颜色插值：以较低的着色频率进行计算。需要以高着色频率评估产生小规模特征（例如，锐利的高光或详细纹理）的着色。 对于需要在图像中看起来清晰锐利的细节，着色频率必须为每个像素至少一个着色样本。</p> <p>因此，即使定义图元的顶点相距许多像素，也可以在顶点阶段安全地计算出大规模效果。 只要顶点在图像中靠得足够近，也可以在顶点阶段计算需要高阴影频率的效果。 或者，在图元比像素大一点时在片段阶段计算它们。</p> <p>例如，计算机游戏中使用的硬件管线通常使用覆盖几个像素以确保高效率的图元，每个片段执行大多数阴影计算。 另一方面，PhotoRealisticRenderMan系统会在将每个表面细分或切成小四边形（称为微多边形）后，对每个顶点进行所有阴影计算，这些小四边形称为微多边形(micropolygons)，其大小大约为像素。 由于基元很小，因此此系统中的每个顶点着色都是适合细节着色的高着色频率。</p> <h1 id="简单的抗锯齿-antialiasing"><a href="#简单的抗锯齿-antialiasing" class="header-anchor">#</a> 简单的抗锯齿(Antialiasing)</h1> <p>就像光线跟踪一样，如果我们对每个像素是否都在图元内部进行全盘或全盘确定，光栅化将产生锯齿状的线条和三角形边缘。 实际上，由本章中描述的简单三角形栅格化算法生成的片段集（有时称为标准光栅化(standard/aliased rasterization)）与发送一条通过每个像素的中心的光线的光线追踪器将映射到该三角形的像素集完全相同。与在光线追踪中相同，解决方案是允许像素被图元部分覆盖（Crow，1978）。 实际上，这种模糊形式有助于提供视觉质量，尤其是在动画中。 如图顶行所示。</p> <p><img src="/assets/cg/ch8-1.png" alt="ch8-1"></p> <p>在栅格化应用程序中，有许多种不同的抗锯齿方法。 就像在光线追踪器中一样，我们可以通过将每个像素值设置为属于该像素的正方形区域图像的平均颜色来生成抗锯齿图像，这种方法称为盒滤波(box filtering)。这意味着我们必须将所有可绘制的实体视为具有定义明确的区域。 例如，可以认为图8.15中的线近似为一个一像素宽的矩形。</p> <p>实现盒式滤波器抗锯齿的最简单方法是超采样(supersampling)：以非常高的分辨率创建图像，然后进行下采样(downsample)。 例如，如果我们的目标是宽度为1.2像素的线的256×256像素图像，则可以在1024×1024屏幕上光栅化宽度为4.8像素的线的矩形版本，然后平均4×4组像素 以获得“缩小”图像中256×256像素中每个像素的颜色。 这是实际的框滤波图像的近似值，但是某些情况下效果很好(when objects are not extremely small relative to the distance between pixels.)。</p> <p>但是，超采样代价太大。 因为引起混淆(aliasing)的非常尖锐的边缘通常是由图元的边缘，而不是由图元内的着色突然变化，所以广泛使用的优化方法是以比着色更高的速率对可见性进行采样。如果在每个像素内的几个点上存储了有关覆盖范围和深度的信息，即使只计算一种颜色，也可以实现很好的抗锯齿效果。 在使用逐顶点着色的RenderMan之类的系统中，这是通过高分辨率光栅化来实现的：这样做的成本不高，因为只需插值着色即可为许多片段或可见性样本生成颜色。 在具有每片段着色的系统（例如硬件管线）中，通过为每个片段存储单一颜色加上覆盖率蒙版(coverage mask)和一组深度值来实现多样本抗锯齿(multisample antialiasing)。</p> <h1 id="剔除图元-culling-primitives-for-efficiency"><a href="#剔除图元-culling-primitives-for-efficiency" class="header-anchor">#</a> 剔除图元(Culling Primitives for Efficiency)</h1> <p>对象顺序渲染的优势是只需要对场景中的所有几何图形进行一次遍历，这对于复杂场景也是一个弱点。 例如，在整个城市的模型中，在任何给定时间可能只有几栋建筑物可见。 可以通过绘制场景中的所有图元来获得正确的图像，但是将浪费大量的精力来处理可见建筑物后面或观察者身后的几何图形，而这些图形不会对最终图像有所帮助。</p> <p>识别并丢弃不可见的几何图形以节省处理该几何图形所花费的时间，这被称为剔除(culling)。 三种常用的淘汰策略（通常协同使用）是：</p> <ul><li>视体剔除(view volume culling)-移除视体之外的几何图形；</li> <li>遮挡剔除(occlusion culling)-移除在视体内但被更靠近相机的其他几何体遮档的几何体；</li> <li>背面剔除(backface culling)-移除背向相机的图元。</li></ul> <p>我们将简要讨论视图体积剔除和背面剔除，但是在高性能系统中剔除是一个复杂的主题； 有关完整的讨论以及有关遮挡剔除的信息，请参阅（Akenine-M oller等，2008）。</p> <h2 id="视体剔除"><a href="#视体剔除" class="header-anchor">#</a> 视体剔除</h2> <p>当整个图元位于视体之外时，可以将其剔除，因为在光栅化时不会用到。 如果我们可以通过快速测试剔除许多图元，则可能显着加快绘制速度。 另一方面，单独测试图元以准确确定需要绘制的图元可能比让光栅化器消除它们要花费更大代价。</p> <p>当将许多三角形被组合到具有关联边界体积(associated bounding volume)的对象中时，视体剔除（也称为视锥剔除）特别有用。 如果边界体积在视体之外，则构成对象的所有三角形也是如此。 例如，如果我们有1000个三角形，它们被一个以c为中心，半径为r的球体包围，则可以检查该球体是否位于剪切平面((\mathbf p − \mathbf a) · \mathbf n = 0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">a</mi></mrow><annotation encoding="application/x-tex">\mathbf a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.44444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">a</span></span></span></span>为平面上任意一点)之外，这等效于检查从球心<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">c</mi></mrow><annotation encoding="application/x-tex">\mathbf c</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.44444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathbf">c</span></span></span></span>到平面的符号距离是否大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">+r</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">+</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span>。 即检查</p> <p>\cfrac {(\mathbf c-\mathbf a)\cdot\mathbf n}{||\mathbf n||&gt;r}</p> <p>请注意，即使在所有三角形都位于平面之外的情况下，球体也可能与平面重叠。 因此，这是一个保守的测试。 测试的保守程度取决于球体对物体的包围程度。</p> <p>如果场景以第12章中描述的空间数据结构之一进行组织，则可以分层应用相同的想法。</p> <h2 id="背面剔除"><a href="#背面剔除" class="header-anchor">#</a> 背面剔除</h2> <p>当多边形模型是封闭的时(即它们形成了一个无缝的封闭空间)则通常假定它们具有面向外的法向量，如第10章所述。对于此类模型，一定要背对眼睛的多边形一定是被面对眼睛的多边形覆盖。 因此，可以在管线开始之前就将这些多边形剔除。 此条件的测试与10.3.1节中给出的轮廓图测试相同。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cg/" class="prev router-link-active">
        计算机图形学
      </a></span> <span class="next"><a href="/cg/ch10.html">
        表面着色
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0d7685bc.js" defer></script><script src="/assets/js/2.f48cadb2.js" defer></script><script src="/assets/js/13.703893c2.js" defer></script>
  </body>
</html>
