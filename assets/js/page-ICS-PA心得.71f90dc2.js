(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{551:function(s,t,a){"use strict";a.r(t);var r=a(1),n=Object(r.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"pa1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pa1"}},[s._v("#")]),s._v(" PA1")]),s._v(" "),a("h3",{attrs:{id:"nemu准备"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nemu准备"}},[s._v("#")]),s._v(" NEMU准备")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("nemu\n├── include                    # 存放全局使用的头文件\n│   ├── common"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h               # 公用的头文件\n│   ├── cpu\n│   │   ├── decode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h           # 译码相关\n│   │   └── exec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h             # 执行相关\n│   ├── debug"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h                # 一些方便调试用的宏\n│   ├── device                 # 设备相关\n│   ├── isa                    # "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ISA")]),s._v("相关\n│   ├── isa"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h                  # "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ISA")]),s._v("相关\n│   ├── macro"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h                # 一些方便的宏定义\n│   ├── memory                 # 访问内存相关\n│   ├── monitor\n│   │   ├── log"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h              # 日志文件相关\n│   │   └── monitor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h\n│   └── rtl\n│       ├── pesudo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h           # "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("RTL")]),s._v("伪指令\n│       └── rtl"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("h              # "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("RTL")]),s._v("指令相关定义\n├── Makefile                   # 指示"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NEMU")]),s._v("的编译和链接\n├── Makefile"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("git               # git版本控制相关\n├── runall"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("sh                  # 一键测试脚本\n└── src                        # 源文件\n    ├── device                 # 设备相关\n    ├── engine\n    │   └── interpreter        # 解释器的实现\n    ├── isa                    # "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ISA")]),s._v("相关的实现\n    │   ├── mips32\n    │   ├── riscv32\n    │   ├── riscv64\n    │   └── x86\n    ├── main"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c                 # 你知道的"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("...")]),s._v("\n    ├── memory\n    │   └── paddr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c            # 物理内存访问\n    └── monitor\n        ├── cpu"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("exec"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c         # 指令执行的主循环\n        ├── debug              # 简易调试器相关\n        │   ├── expr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c         # 表达式求值的实现\n        │   ├── log"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c          # 日志文件相关\n        │   ├── ui"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c           # 用户界面相关\n        │   └── watchpoint"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c   # 监视点的实现\n        └── monitor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br")])]),a("ul",[a("li",[s._v("make ISA=$ISA run")]),s._v(" "),a("li",[s._v("在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1，但参数类型是uint64_t,因此实际的值为"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("msup",[a("mn",[s._v("2")]),a("mn",[s._v("64")])],1),a("mo",[s._v("−")]),a("mn",[s._v("1")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("2^{64}-1")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.8974em","vertical-align":"-0.0833em"}}),a("span",{staticClass:"mord"},[a("span",{staticClass:"mord"},[s._v("2")]),a("span",{staticClass:"msupsub"},[a("span",{staticClass:"vlist-t"},[a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.8141em"}},[a("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[a("span",{staticClass:"mord mtight"},[s._v("64")])])])])])])])])]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222em"}}),a("span",{staticClass:"mbin"},[s._v("−")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222em"}})]),a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.6444em"}}),a("span",{staticClass:"mord"},[s._v("1")])])])]),s._v("，即0xffffffffffffffff。")]),s._v(" "),a("li",[s._v("三个对调试有用的宏(在nemu/include/debug.h中定义)\n"),a("ul",[a("li",[s._v("Log()是printf()的升级版, 专门用来输出调试信息, 同时还会输出使用Log()所在的源文件, 行号和函数. 当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置")]),s._v(" "),a("li",[s._v("Assert()是assert()的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息")]),s._v(" "),a("li",[s._v("panic()用于输出信息并结束程序, 相当于无条件的assertion fail")])])]),s._v(" "),a("li",[s._v("内存通过在nemu/src/memory/paddr.c中定义的大数组pmem来模拟. 在客户程序运行的过程中, 总是使用vaddr_read()和vaddr_write() (在nemu/include/memory/vaddr.h中定义)来访问模拟的内存. vaddr, paddr分别代表虚拟地址和物理地址.")]),s._v(" "),a("li",[s._v('"单元"是指有独立含义的子串, 它们正式的称呼叫token.')]),s._v(" "),a("li",[s._v("\\33 即 ESC。")]),s._v(" "),a("li",[s._v("makefile中使用awk，因为makefile中"),a("code",[s._v("$")]),s._v("会被特殊对待，所以awk的program text中的"),a("code",[s._v("$")]),s._v("要用"),a("code",[s._v("$$")]),s._v("表示。注意awk的action要写在"),a("code",[s._v("{}")]),s._v("中。")]),s._v(" "),a("li",[s._v("fopen文件路径，在nemu目录下make run时，当前目录就是nemu。")]),s._v(" "),a("li",[s._v("超级经典错误，if (tokens[p].type = '*')。。。。少写个等号")]),s._v(" "),a("li",[s._v("strncpy(dest, src, n) 如果n个字符中没有'\\0'，dest中不会主动加。如果dest中原来字符数大于n,则复制后要使src==dest，需要手动添加'\\0'(dest[n] = '\\0')")])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("number"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("    # 一个数是表达式\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"("')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('")"')]),s._v("     # 在表达式两边加个括号也是表达式\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"+"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("  # 两个表达式相加也是表达式\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"-"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("  # 接下来你全懂了\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"*"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"/"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("expr"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h3",{attrs:{id:"如何调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何调试"}},[s._v("#")]),s._v(" 如何调试")]),s._v(" "),a("p",[s._v("一些软件工程相关的概念:")]),s._v(" "),a("ul",[a("li",[s._v("Fault: 实现错误的代码, 例如if (p = NULL)")]),s._v(" "),a("li",[s._v("Error: 程序执行时不符合预期的状态, 例如p被错误地赋值成NULL")]),s._v(" "),a("li",[s._v("Failure: 能直接观测到的错误, 例如程序触发了段错误")])]),s._v(" "),a("p",[s._v("调试其实就是从观测到的failure一步一步回溯寻找fault的过程, 找到了fault之后, 我们就很快知道应该如何修改错误的代码了. 但从上面的例子也可以看出, 调试之所以不容易, 恰恰是因为:")]),s._v(" "),a("ul",[a("li",[s._v("fault不一定马上触发error")]),s._v(" "),a("li",[s._v("触发了error也不一定马上转变成可观测的failure")]),s._v(" "),a("li",[s._v("error会像滚雪球一般越积越多, 当我们观测到failure的时候, 其实已经距离fault非常遥远了")])]),s._v(" "),a("p",[s._v("理解了这些原因之后, 我们就可以制定相应的策略了:")]),s._v(" "),a("ul",[a("li",[s._v("尽可能把fault转变成error. 这其实就是测试做的事情, 所以我们在上一节中加入了表达式生成器的内容, 来帮助大家进行测试, 后面的实验内容也会提供丰富的测试用例. 但并不是有了测试用例就能把所有fault都转变成error了, 因为这取决于测试的覆盖度. 要设计出一套全覆盖的测试并不是一件简单的事情, 越是复杂的系统, 全覆盖的测试就越难设计. 但是, 如何提高测试的覆盖度, 是学术界一直以来都在关注的问题.")]),s._v(" "),a("li",[s._v("尽早观测到error的存在. 观测到error的时机直接决定了调试的难度: 如果等到触发failure的时候才发现error的存在, 调试就会比较困难; 但如果能在error刚刚触发的时候就观测到它, 调试难度也就大大降低了. 事实上, 你已经见识过一些有用的工具了:\n"),a("ul",[a("li",[s._v("-Wall, -Werror: 在编译时刻把潜在的fault直接转变成failure. 这种工具的作用很有限, 只能寻找一些在编译时刻也觉得可疑的fault, 例如if (p = NULL). 不过随着编译器版本的增强, 编译器也能发现代码中的一些未定义行为. 这些都是免费的午餐, 不吃就真的白白浪费了.")]),s._v(" "),a("li",[s._v("assert(): 在运行时刻把error直接转变成failure. assert()是一个很简单却又非常强大的工具, 只要在代码中定义好程序应该满足的特征, 就一定能在运行时刻将不满足这些特征的error拦截下来. 例如链表的实现, 我们只需要在代码中插入一些很简单的assert()(例如指针解引用时不为空), 就能够几乎告别段错误. 但是, 编写这些assert()其实需要我们对程序的行为有一定的了解, 同时在程序特征不易表达的时候, assert()的作用也较为有限.")]),s._v(" "),a("li",[s._v("printf(): 通过输出的方式观察潜在的error. 这是用于回溯fault时最常用的工具, 用于观测程序中的变量是否进入了错误的状态. 在NEMU中我们提供了输出更多调试信息的宏Log(), 它实际上封装了printf()的功能. 但由于printf()需要根据输出的结果人工判断是否正确, 在便利程度上相对于assert()的自动判断就逊色了不少.")]),s._v(" "),a("li",[s._v("GDB: 随时随地观测程序的任何状态. 调试器是最强大的工具, 但你需要在程序行为的茫茫大海中观测那些可疑的状态, 因此使用起来的代价也是最大的.")])])])]),s._v(" "),a("p",[s._v("建议:")]),s._v(" "),a("ul",[a("li",[s._v("总是使用-Wall和-Werror")]),s._v(" "),a("li",[s._v("尽可能多地在代码中插入assert()")]),s._v(" "),a("li",[s._v("assert()无法捕捉到error时, 通过printf()输出可疑的变量, 期望能观测到error")]),s._v(" "),a("li",[s._v("printf()不易观测error时, 通过GDB理解程序的精确行为")])]),s._v(" "),a("h3",{attrs:{id:"一条指令在nemu中的执行过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一条指令在nemu中的执行过程"}},[s._v("#")]),s._v(" 一条指令在NEMU中的执行过程")]),s._v(" "),a("p",[s._v("事实上, 一个字节最多只能区分256种不同的指令形式. 当指令形式的数目大于256时, 我们需要使用另外的方法来识别它们. x86中有主要有两种方法来解决这个问题(在PA2中你都会遇到这两种情况):")]),s._v(" "),a("ul",[a("li",[s._v("一种方法是使用转义码(escape code), x86中有一个2字节转义码 0x0f, 当指令opcode的第一个字节是0x0f时, 表示需要再读入一个字节才能决定具体的指令形式(部分条件跳转指令就属于这种情况). 后来随着各种SSE指令集的加入, 使用2字节转义码也不足以表示所有的指令形式了, x86在2字节转义码的基础上又引入了3字节转义码, 当指令opcode的前两个字节是0x0f和0x38时, 表示需要再读入一个字节才能决定具体的指令形式.")]),s._v(" "),a("li",[s._v("另一种方法是使用ModR/M字节中的扩展opcode域来对opcode的长度进行扩充. 有些时候, 读入一个字节也还不能完全确定具体的指令形式, 这时候需要读入紧跟在opcode后面的ModR/M字节, 把其中的reg/opcode域当做opcode的一部分来解释, 才能决定具体的指令形式. x86把这些指令划分成不同的指令组(instruction group), 在同一个指令组中的指令需要通过ModR/M字节中的扩展opcode域来区分.")])]),s._v(" "),a("p",[s._v("最一般的寻址格式是"),a("br"),s._v("\ndisplacement(R[base_reg], R[index_reg], scale_factor)"),a("br"),s._v("\n相应内存地址的计算方式为"),a("br"),s._v("\naddr = R[base_reg] + R[index_reg] * scale_factor + displacement"),a("br"),s._v("\n其它寻址格式都可以看作这种一般格式的特例")]),s._v(" "),a("p",[s._v("在NEMU中, RTL寄存器只有以下这些")]),s._v(" "),a("ul",[a("li",[s._v("不同ISA的通用寄存器(在nemu/include/isa/$ISA.h中定义)")]),s._v(" "),a("li",[s._v("id_src, id_src2和id_dest中的操作数内容val(在nemu/include/cpu/decode.h中定义).")]),s._v(" "),a("li",[s._v("临时寄存器s0, s1, s2和t0(在nemu/include/rtl/rtl.h中定义)")]),s._v(" "),a("li",[s._v("零寄存器rz(在nemu/src/monitor/cpu-exec.c中定义), 它的值总是0")]),s._v(" "),a("li",[s._v("x86的ISA相关译码信息中的内存基地址mbr")])]),s._v(" "),a("p",[s._v("RTL基本指令包括(我们使用了一些简单的正则表达式记号):")]),s._v(" "),a("ul",[a("li",[s._v("寄存器-寄存器类型和寄存器-立即数类型的基本算术/逻辑运算, 包括rtl_(add|sub|and|or|xor|shl|shr|sar|setrelop)i?, 它们的定义用到了nemu/src/engine/interpreter/c_op.h中的C语言运算和interpret_relop()函数")]),s._v(" "),a("li",[s._v("寄存器-寄存器类型的乘除法运算, 包括rtl_i?(mul_[lo|hi]|div_[q|r]),")]),s._v(" "),a("li",[s._v("被除数为64位的除法运算rtl_i?div64_[q|r]")]),s._v(" "),a("li",[s._v("guest内存访问rtl_lm, rtl_lms和rtl_sm")]),s._v(" "),a("li",[s._v("host内存访问rtl_host_lm和rtl_host_sm")]),s._v(" "),a("li",[s._v("跳转, 包括直接跳转rtl_j, 间接跳转rtl_jr和条件跳转rtl_jrelop")]),s._v(" "),a("li",[s._v("终止程序rtl_exit(在nemu/src/monitor/cpu-exec.c中定义)")])]),s._v(" "),a("p",[s._v("小型调用约定:")]),s._v(" "),a("ul",[a("li",[s._v("实现RTL伪指令的时候, 尽可能不使用dest之外的寄存器存放中间结果. 由于dest最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.")]),s._v(" "),a("li",[s._v("实在需要使用临时寄存器的时候, 按照以下约定来使用:")]),s._v(" "),a("li",[s._v("t0, t1, ... - 只能在RTL伪指令的实现过程中存放中间结果")]),s._v(" "),a("li",[s._v("s0, s1, ... - 只能在译码辅助函数和执行辅助函数的实现过程中存放中间结果")])]),s._v(" "),a("p",[s._v("RTL寄存器的生存期")]),s._v(" "),a("p",[s._v("任何指令都可以分解为以下4中操作")]),s._v(" "),a("ul",[a("li",[s._v("读取某一主存单元的内容，并将其装入某个寄存器（取指， 取数）")]),s._v(" "),a("li",[s._v("把一个数据从某个寄存器存入给定的主存单元中（存结果）")]),s._v(" "),a("li",[s._v("把一个数据从某寄存器送到另一寄存器或者ALU（取数，存结果）")]),s._v(" "),a("li",[s._v("进行算术或逻辑运算（PC+”1”，计算地址，运算）")])])])}),[],!1,null,null,null);t.default=n.exports}}]);