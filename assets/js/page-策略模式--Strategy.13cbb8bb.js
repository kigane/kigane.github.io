(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{539:function(t,a,r){"use strict";r.r(a);var e=r(1),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),r("p",[t._v("定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。")]),t._v(" "),r("h2",{attrs:{id:"理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[t._v("#")]),t._v(" 理解")]),t._v(" "),r("p",[t._v("继承是个强大的技巧，但很多情况下并不需要使用继承，或者继承不够好。"),r("br"),t._v(" "),r("strong",[t._v("继承只能在不同类层级之间共享")]),t._v("，子类在父类的基础上修改。而没有办法在相同层级进行共享。"),r("br"),t._v("\n例如，同意父类的6个子类，都有一个方法各不相同。但又有一个方法是3个子类一组，组间不同，组内相同的。继承方法无法共享，只能将相同的代码重复3遍。")]),t._v(" "),r("p",[t._v("策略模式通过多态机制，可以很好的实现这种"),r("strong",[t._v("同级共享")]),t._v("。具体来说，"),r("strong",[t._v("将方法抽象为接口，不同的实现封装为不同的实体类")]),t._v("。原来拥有方法的类，现在持有抽象的接口，通过构造函数或Setter方法传入不同的实体类就可以让该类表现出不同的行为。")]),t._v(" "),r("h2",{attrs:{id:"类图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类图"}},[t._v("#")]),t._v(" 类图")]),t._v(" "),r("Mermaid",{attrs:{id:"mermaid-382ee14d","data-code":"classDiagram%0A%20%20%20%20Client%20--%3E%20IStrategy%0A%20%20%20%20IStrategy%20%3C%7C..%20CommonStrategy%0A%20%20%20%20IStrategy%20%3C%7C..%20AmazingStrategy%0A%0A%20%20%20%20class%20Client%7B%0A%20%20%20%20%20%20%20%20-%20IStrategy%20strategy%0A%20%20%20%20%20%20%20%20%2B%20Strategy()%20void%0A%20%20%20%20%20%20%20%20%2B%20SetStrategy(IStrategy%20s)%20void%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20IStrategy%7B%0A%20%20%20%20%20%20%20%20%3C%3CInterface%3E%3E%0A%20%20%20%20%20%20%20%20%2B%20Strategy()%20void%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20CommonStrategy%7B%0A%20%20%20%20%20%20%20%20%2B%20Strategy()%20void%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20AmazingStrategy%7B%0A%20%20%20%20%20%20%20%20%2B%20Strategy()%20void%0A%20%20%20%20%7D%0A"}})],1)}),[],!1,null,null,null);a.default=s.exports}}]);