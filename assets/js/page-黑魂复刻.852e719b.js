(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{532:function(t,a,e){"use strict";e.r(a);var r=e(1),i=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"玩家输入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#玩家输入"}},[t._v("#")]),t._v(" 玩家输入")]),t._v(" "),e("h3",{attrs:{id:"统一输入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#统一输入"}},[t._v("#")]),t._v(" 统一输入")]),t._v(" "),e("p",[t._v("为了统一键盘和手柄等输入，抽象出一个信号概念。")]),t._v(" "),e("ul",[e("li",[t._v("Dup 上下信号")]),t._v(" "),e("li",[t._v("Dright 左右信号")])]),t._v(" "),e("h3",{attrs:{id:"衰减"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#衰减"}},[t._v("#")]),t._v(" 衰减")]),t._v(" "),e("p",[t._v("Mathf.SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = Mathf.Infinity, float deltaTime = Time.deltaTime)")]),t._v(" "),e("ul",[e("li",[t._v("current: 平滑的当前值")]),t._v(" "),e("li",[t._v("target： 目标值")]),t._v(" "),e("li",[t._v("smoothTime: 经过多长时间达到目标值")]),t._v(" "),e("li",[t._v("currentVelocity：变化的速度，一阶导数")])]),t._v(" "),e("h3",{attrs:{id:"使能标志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使能标志"}},[t._v("#")]),t._v(" 使能标志")]),t._v(" "),e("p",[t._v("控制模块的激活与禁用。在脚本内用一个bool变量控制。")]),t._v(" "),e("h3",{attrs:{id:"_1d-blend-tree"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1d-blend-tree"}},[t._v("#")]),t._v(" 1D Blend Tree")]),t._v(" "),e("ul",[e("li",[t._v("在Animator中右键create->from blend tree，创建一个blend tree，双击进入。")]),t._v(" "),e("li",[t._v("默认有一个参数，控制在两个动画之间的平滑变化。")]),t._v(" "),e("li",[t._v("在Motion List中加入要混合的两个动画")]),t._v(" "),e("li",[t._v("threshold表示变化的起止位置")]),t._v(" "),e("li",[t._v("threshold旁边的参数为每个动画的播放速度")])]),t._v(" "),e("h3",{attrs:{id:"连接玩家输入和动画控制器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#连接玩家输入和动画控制器"}},[t._v("#")]),t._v(" 连接玩家输入和动画控制器")]),t._v(" "),e("p",[t._v('anim.SetFloat("Forward", pi.Dup);')]),t._v(" "),e("h3",{attrs:{id:"移动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#移动"}},[t._v("#")]),t._v(" 移动")]),t._v(" "),e("ul",[e("li",[t._v("使用Dup和Dright的和组成移动的方向movingVec，并用此值修改模型的朝向。")]),t._v(" "),e("li",[t._v("使用Dup和Dright的和模控制移动速度。一个问题：斜向速度更快")]),t._v(" "),e("li",[t._v("用rigid.velocity控制移动时，要注意movingVec没有y轴分量，需要使用原来的值。")]),t._v(" "),e("li",[t._v("rigidbody要在FixedUpdate中更新")])]),t._v(" "),e("h3",{attrs:{id:"解决trigger累积的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决trigger累积的问题"}},[t._v("#")]),t._v(" 解决trigger累积的问题")]),t._v(" "),e("p",[t._v("在Animator中使用trigger会有一个问题，如果触发两次以上的SetTrigger，会消耗一个并累积一个，结果造成第二次过渡。")]),t._v(" "),e("p",[t._v("解决方法是在状态上添加一个脚本，在OnStateEnter和OnStateExit上清除累积的trigger。")]),t._v(" "),e("p",[t._v("为了尽量将功能放在顶级游戏对象的组件中，使用SendMessage将具体的处理逻辑延迟到接受Message的方法中。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("SendMessage():只发送到所在的GameObject\nSendMessageUpwards():发送到所在的GameObject和其所有的父对象。")])]),t._v(" "),e("h2",{attrs:{id:"动画"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动画"}},[t._v("#")]),t._v(" 动画")]),t._v(" "),e("ul",[e("li",[t._v("make transition到子状态机，进入子状态机后，会转到子状态机的Entry。")]),t._v(" "),e("li",[t._v("make transition到子状态机内的某个状态，则会从子状态机的(Up)XXLayer状态转过去。")]),t._v(" "),e("li",[t._v("make transition到子状态机内的exit，意味着退出子状态机，转到上一层状态机的Entry。(可以减少一条线哦)")])]),t._v(" "),e("h2",{attrs:{id:"模型出现章鱼一样的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模型出现章鱼一样的情况"}},[t._v("#")]),t._v(" 模型出现章鱼一样的情况")]),t._v(" "),e("ul",[e("li",[t._v("avatar不对")]),t._v(" "),e("li",[t._v("unity没有识别出模型中的一些额外的骨骼。解决方法是，将额外的骨骼塞到同级的骨骼下。")])])])}),[],!1,null,null,null);a.default=i.exports}}]);