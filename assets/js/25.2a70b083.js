(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{378:function(v,_,i){"use strict";i.r(_);var l=i(44),e=Object(l.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h2",{attrs:{id:"gdb-cheatsheet"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gdb-cheatsheet"}},[v._v("#")]),v._v(" gdb cheatsheet")]),v._v(" "),i("p",[i("a",{attrs:{href:"https://sourceware.org/gdb/onlinedocs/gdb/index.html#SEC_Contents",target:"_blank",rel:"noopener noreferrer"}},[v._v("gdb 文档"),i("OutboundLink")],1)]),v._v(" "),i("ul",[i("li",[v._v("-g: 生成debugging symbols，使得调试更高效。-ggdb，包含gdb规定的符号。")])]),v._v(" "),i("p",[v._v("gdb [--args] program [args]进入debug模式")]),v._v(" "),i("ul",[i("li",[v._v("set args <args>")]),v._v(" "),i("li",[v._v("run: 执行程序")]),v._v(" "),i("li",[v._v("kill: 关闭执行的程序")]),v._v(" "),i("li",[v._v("help")])]),v._v(" "),i("p",[v._v("检查栈")]),v._v(" "),i("ul",[i("li",[v._v("backtrace/where | bt: 查看调用栈")]),v._v(" "),i("li",[v._v("backtrace/where full: 查看调用栈，也打印栈帧中的变量")]),v._v(" "),i("li",[v._v("frame frame#: 查看指定帧(backtrace列出的信息开头的数字)")])]),v._v(" "),i("p",[v._v("变量和内存")]),v._v(" "),i("ul",[i("li",[v._v("x/nfu addr: examine addr。查看指定地址的值\n"),i("ul",[i("li",[v._v("n: 要打印的unit数量")]),v._v(" "),i("li",[v._v("f: format")]),v._v(" "),i("li",[v._v("u: unit (b:Byte 1B, h:Half-word 2B, w:Word 4B, g:Giant word 8B)")])])]),v._v(" "),i("li",[v._v("p <what>: 查看变量的值")]),v._v(" "),i("li",[v._v("p arr[n]@m: 查看数组arr从n开始数，共m个元素")]),v._v(" "),i("li",[v._v("print/format <what>: 查看变量的值")]),v._v(" "),i("li",[v._v("display/format <what>: 在每个step指令后打印变量的值")]),v._v(" "),i("li",[v._v("undisplay display#: 不再监视")]),v._v(" "),i("li",[v._v("enable/disable display#")]),v._v(" "),i("li",[v._v("<what>\n"),i("ul",[i("li",[v._v("expressions")]),v._v(" "),i("li",[v._v("filename::variable_name")]),v._v(" "),i("li",[v._v("function::variable_name")]),v._v(" "),i("li",[v._v("{type}address : 在address处的内容，解释为C的type类型。")]),v._v(" "),i("li",[v._v("register: 有名字的寄存器，如esp--栈指针，ebp--帧基址，eip--指令指针")])])]),v._v(" "),i("li",[v._v("format\n"),i("ul",[i("li",[v._v("a: 指针")]),v._v(" "),i("li",[v._v("c: 读为int，打印为char")]),v._v(" "),i("li",[v._v("d: 有符号int")]),v._v(" "),i("li",[v._v("f: 浮点数")]),v._v(" "),i("li",[v._v("o: 八进制int")]),v._v(" "),i("li",[v._v("s: Try to treat as C string")]),v._v(" "),i("li",[v._v("t: 二进制int")]),v._v(" "),i("li",[v._v("u: 无符号int")]),v._v(" "),i("li",[v._v("x: 十六进制int")])])])]),v._v(" "),i("p",[v._v("查看源码")]),v._v(" "),i("ul",[i("li",[v._v("list line_number: 查看101行附件10行")]),v._v(" "),i("li",[v._v("list from,to: 查看从from到to行")]),v._v(" "),i("li",[v._v("list -: 查看前10行")]),v._v(" "),i("li",[v._v("list <where>")])]),v._v(" "),i("p",[v._v("断点")]),v._v(" "),i("ul",[i("li",[v._v("break where: 在指定位置设置一个断点(会输出断点所在具体位置，注意到断点有序号，Breakpoint 1 at 0x29fa0: file main.cc, line 52.)")]),v._v(" "),i("li",[v._v("where\n"),i("ul",[i("li",[v._v("function_name")]),v._v(" "),i("li",[v._v("line_number: 当前文件的某行")]),v._v(" "),i("li",[v._v("file:line_number")])])]),v._v(" "),i("li",[v._v("delete breakpoint#: 删除指定断点")]),v._v(" "),i("li",[v._v("enable breakpoint")]),v._v(" "),i("li",[v._v("disable breakpoint")]),v._v(" "),i("li",[v._v("clear: 删除所有断点")]),v._v(" "),i("li",[v._v("condition 1 var==666: 仅当变量var的值为666时，才触发断点1。")]),v._v(" "),i("li",[v._v("break/watch <where> if <condition>")]),v._v(" "),i("li",[v._v("watch where // breakpoint 和 watchpoint 共用编号。")]),v._v(" "),i("li",[v._v("watchpoint 有两种实现方式，具体取决于你的系统。软件实现方式为在每一步执行后都测试一次expr的值，会很慢。硬件方式更快。")]),v._v(" "),i("li",[v._v("watch [-l|-location] expr [thread thread-id] [mask maskvalue]  为expr设置一个监视点。如果expr的值改变了，则停止执行。\n"),i("ul",[i("li",[v._v("thread thread-id 指定某个线程，只有该线程修改expr的值时才停止执行。(仅限硬件实现)")]),v._v(" "),i("li",[v._v("-l 告诉gdb，如果expr的结果是个地址，则查看该地址的内容。如果结果不是地址，则输出一个错误。")]),v._v(" "),i("li",[v._v("mask maskvalue 默认开启-l。maskvalue用于同时查看多数地址。 watch foo mask 0xffffff00？")])])]),v._v(" "),i("li",[v._v("rwatch expr 在expr被程序读取时break")]),v._v(" "),i("li",[v._v("awatch expr 在expr被读取或被修改时都break")]),v._v(" "),i("li",[v._v("delete/enable/disable watchpoint#")])]),v._v(" "),i("p",[v._v("步进")]),v._v(" "),i("ul",[i("li",[v._v("gdb的一个有用的特性：如果直接按回车，会重复执行上一个命令")]),v._v(" "),i("li",[v._v("step: 到下一行。如果有函数会进入函数")]),v._v(" "),i("li",[v._v("next: 到下一行。不会进入函数")]),v._v(" "),i("li",[v._v("finish: 将当前函数执行完")]),v._v(" "),i("li",[v._v("continue | cont: 继续正常执行")]),v._v(" "),i("li",[v._v("quit: 退出")])]),v._v(" "),i("p",[v._v("反向执行")]),v._v(" "),i("ul",[i("li",[v._v("record 反向执行的前置条件")]),v._v(" "),i("li",[v._v("reverse-step")]),v._v(" "),i("li",[v._v("reverse-next")]),v._v(" "),i("li",[v._v("reverse-continue")]),v._v(" "),i("li",[v._v("reverse-finish 回到函数执行前")]),v._v(" "),i("li",[v._v("set exec-direction reverse 所有next,step...全变为逆向操作")]),v._v(" "),i("li",[v._v("set exec-direction forward 恢复正常")])]),v._v(" "),i("p",[v._v("信息")]),v._v(" "),i("ul",[i("li",[v._v("info args: 当前栈帧的函数参数")]),v._v(" "),i("li",[v._v("info breakpoints/watchpoints")]),v._v(" "),i("li",[v._v("info locals: 当前栈帧的本地变量")]),v._v(" "),i("li",[v._v("info sharedlibrary: 列出已加载的动态库")]),v._v(" "),i("li",[v._v("info signals: 列出所有信号和他们当前是如何处理的")]),v._v(" "),i("li",[v._v("info threads")]),v._v(" "),i("li",[v._v("show directories: 列出GDB搜索涉及到的源文件")]),v._v(" "),i("li",[v._v("show listsize")]),v._v(" "),i("li",[v._v("whatis variable_name: 输出变量的类型")])]),v._v(" "),i("h2",{attrs:{id:"gdb-tui"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gdb-tui"}},[v._v("#")]),v._v(" gdb-tui")]),v._v(" "),i("p",[v._v("标志")]),v._v(" "),i("ul",[i("li",[i("p",[i("code",[v._v(">")]),v._v(" 当前执行的行")])]),v._v(" "),i("li",[i("p",[v._v("断点表示 [b|B][+|-]")]),v._v(" "),i("ul",[i("li",[i("code",[v._v("b")]),v._v(" 表示还没到的断点")]),v._v(" "),i("li",[i("code",[v._v("B")]),v._v(" 表示至少到过一次的断点")]),v._v(" "),i("li",[i("code",[v._v("+")]),v._v(" 表示 enabled")]),v._v(" "),i("li",[i("code",[v._v("-")]),v._v(" 表示 disabled")])])]),v._v(" "),i("li",[i("p",[v._v("C-x a/A/C-a: 进入或离开TUI模式")])]),v._v(" "),i("li",[i("p",[v._v("C-x 1: 保留一个窗口")])]),v._v(" "),i("li",[i("p",[v._v("C-x 2: 保留两个窗口")])]),v._v(" "),i("li",[i("p",[v._v("C-x o: 切换当前活动的窗口")])]),v._v(" "),i("li",[i("p",[v._v("C-x s: 切换到TUI的单键模式")])]),v._v(" "),i("li",[i("p",[v._v("PgUp,PgDn,上下左右可用于操作活动窗口。")])]),v._v(" "),i("li",[i("p",[v._v("当焦点不在cmd窗口时，C-p相当于Up,C-b相当于Left,C-f相当于Right,C-n相当于Down")])]),v._v(" "),i("li",[i("p",[v._v("C-l: 刷新窗口")])])]),v._v(" "),i("p",[v._v("单键模式")]),v._v(" "),i("ul",[i("li",[v._v("s: step")]),v._v(" "),i("li",[v._v("i: step Into")]),v._v(" "),i("li",[v._v("n: next")]),v._v(" "),i("li",[v._v("o: step Over")]),v._v(" "),i("li",[v._v("r: run")]),v._v(" "),i("li",[v._v("c: continue")]),v._v(" "),i("li",[v._v("f: finish")]),v._v(" "),i("li",[v._v("d: down 在frame stack中向下一层")]),v._v(" "),i("li",[v._v("u: up 在frame stack中向上一层")]),v._v(" "),i("li",[v._v("q: 退出单键模式")]),v._v(" "),i("li",[v._v("v: info local")]),v._v(" "),i("li",[v._v("w: where")])]),v._v(" "),i("p",[v._v("TUI命令")]),v._v(" "),i("ul",[i("li",[i("p",[v._v("tui enable: 进入上次使用的tui窗口模式，或默认窗口模式。")])]),v._v(" "),i("li",[i("p",[v._v("tui disable")])]),v._v(" "),i("li",[i("p",[v._v("tui new-layout name window weight [window weight ...]: 新建一个名为name的TUI窗口布局。")]),v._v(" "),i("ul",[i("li",[v._v("可以使用layout name使用该布局")]),v._v(" "),i("li",[v._v("window 有四种 src,asm,regs,cmd")]),v._v(" "),i("li",[v._v("weight 是权重，用于确定每个窗口占屏幕的比例。status的权重应总是设为0")]),v._v(" "),i("li",[v._v("默认是从上到下分割。加-horizontal可改为从左到右分割。")]),v._v(" "),i("li",[v._v("示例1：(gdb) tui new-layout example src 1 regs 1 status 0 cmd 1")]),v._v(" "),i("li",[v._v("示例2：(gdb) tui new-layout example {-horizontal src 1 asm 1} 2 status 0 cmd 1")]),v._v(" "),i("li",[v._v("9.2版本还没有实装")])])]),v._v(" "),i("li",[i("p",[v._v("layout name：使用内置布局或新建的布局")]),v._v(" "),i("ul",[i("li",[v._v("prev: 前一个")]),v._v(" "),i("li",[v._v("next: 后一个")]),v._v(" "),i("li",[v._v("src: 显示源码和命令窗口")]),v._v(" "),i("li",[v._v("asm：显示汇编和命令窗口")]),v._v(" "),i("li",[v._v("split：显示源码，汇编和命令窗口")]),v._v(" "),i("li",[v._v("regs：显示寄存器窗口。如果在src模式则上为寄存器，中为源码。如果在split和asm模式，则上为寄存器，中为汇编。")])])]),v._v(" "),i("li",[i("p",[v._v("focus name: 改变当前活动窗口。")])]),v._v(" "),i("li",[i("p",[v._v("refresh: 刷新窗口")])]),v._v(" "),i("li",[i("p",[v._v("winheight name +count： 改变窗口大小")])]),v._v(" "),i("li",[i("p",[v._v("winheight name -count： 改变窗口大小")])]),v._v(" "),i("li",[i("p",[v._v("tui reg group：显示不同的寄存器分组")]),v._v(" "),i("ul",[i("li",[v._v("general: 通用寄存器")]),v._v(" "),i("li",[v._v("float: 浮点数寄存器")]),v._v(" "),i("li",[v._v("system: 系统寄存器")]),v._v(" "),i("li",[v._v("vector: 向量寄存器")]),v._v(" "),i("li",[v._v("all")])])]),v._v(" "),i("li",[i("p",[v._v("set tui compact-source [on|off]：设置源码的行号和代码间的距离。on-仅一个空格，off-一个tab。")])])]),v._v(" "),i("h2",{attrs:{id:"小技巧"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#小技巧"}},[v._v("#")]),v._v(" 小技巧")]),v._v(" "),i("ul",[i("li",[v._v("对一个大数组，p arr[n]@m，查看数组arr从n开始数，共m个元素")]),v._v(" "),i("li",[v._v("gdb 命令输出在src模式下可见部分太小了。可以使用\n"),i("ul",[i("li",[v._v("set trace-commands on")]),v._v(" "),i("li",[v._v("set logging on")]),v._v(" "),i("li",[v._v("cd where/gdb/is/running")]),v._v(" "),i("li",[v._v("tail -f -n 30 gdb.txt")]),v._v(" "),i("li",[v._v("less +F gdb.txt 可以代替tail。 ctrl+c，退出等待输入模式，进入普通less模式，shift+f进入。")]),v._v(" "),i("li",[v._v("进入TUI模式后，日志会停止，这是个gdb bug。先set logging off，再set logging on即可正常显示。")])])])])])}),[],!1,null,null,null);_.default=e.exports}}]);