(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{561:function(t,a,s){"use strict";s.r(a);var _=s(1),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"os-walk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#os-walk"}},[t._v("#")]),t._v(" os.walk()")]),t._v(" "),s("p",[s("code",[t._v("os.walk(top[, topdown=True])")]),t._v(": 从top目录开始，先序遍历所有子目录")]),t._v(" "),s("div",{staticClass:"language-python line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" dirs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" files "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" os"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("walk"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# str")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dirs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# list")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("files"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# list")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'\\n'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h2",{attrs:{id:"pathlib-os-os-path"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pathlib-os-os-path"}},[t._v("#")]),t._v(" pathlib & os & os.path")]),t._v(" "),s("p",[t._v("path.xxx表示实例方法，Path.xxx表示类方法(@classmethod)。")]),t._v(" "),s("h3",{attrs:{id:"文件操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件操作"}},[t._v("#")]),t._v(" 文件操作")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("os & os.path")]),t._v(" "),s("th",[t._v("pathlib")]),t._v(" "),s("th",[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("os.chmod(mode)")]),t._v(" "),s("td",[t._v("path.chmod(mode)")]),t._v(" "),s("td",[t._v("改变文件模式和权限")])]),t._v(" "),s("tr",[s("td",[t._v("os.mkdir(path)")]),t._v(" "),s("td",[t._v("path.mkdir(path, parents=False)")]),t._v(" "),s("td",[t._v("创建一个名为 path 的目录,如果中间目录不存在会报错")])]),t._v(" "),s("tr",[s("td",[t._v("os.makedirs(path, exist_ok=False)")]),t._v(" "),s("td",[t._v("path.mkdir(path, parents=True, exist_ok=False)")]),t._v(" "),s("td",[t._v("如果 exist_ok 为 false（默认），则在目标已存在的情况下抛出 FileExistsError。为 True 则忽略该异常。")])]),t._v(" "),s("tr",[s("td",[t._v("os.rename(src, dst)")]),t._v(" "),s("td",[t._v("path.rename(target)")]),t._v(" "),s("td",[t._v("重命名。如果dst已存在，则失败。")])]),t._v(" "),s("tr",[s("td",[t._v("os.replace(src, dst)")]),t._v(" "),s("td",[t._v("path.replace(target)")]),t._v(" "),s("td",[t._v("重命名。但dst是文件，且存在时，会直接替换。target无论是文件或目录都会直接替换。")])]),t._v(" "),s("tr",[s("td",[t._v("os.rmdir(path)")]),t._v(" "),s("td",[t._v("path.rmdir()")]),t._v(" "),s("td",[t._v("移除此目录。此目录必须存在且为空。")])]),t._v(" "),s("tr",[s("td",[t._v("os.remove(path)")]),t._v(" "),s("td",[t._v("无对应方法")]),t._v(" "),s("td",[t._v("移除此文件。不能是目录。")])])])]),t._v(" "),s("h3",{attrs:{id:"路径操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路径操作"}},[t._v("#")]),t._v(" 路径操作")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("os & os.path")]),t._v(" "),s("th",[t._v("pathlib")]),t._v(" "),s("th",[t._v("作用")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("os.stat(path)")]),t._v(" "),s("td",[t._v("path.stat()")]),t._v(" "),s("td",[t._v("检查文件属性")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.abspath(path)")]),t._v(" "),s("td",[t._v("path.resolve()")]),t._v(" "),s("td",[t._v("返回path的标准化的绝对路径")])]),t._v(" "),s("tr",[s("td",[t._v("os.getcwd()")]),t._v(" "),s("td",[t._v("Path.cwd()")]),t._v(" "),s("td",[t._v("返回当前工作目录路径")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.exists(path)")]),t._v(" "),s("td",[t._v("path.exists()")]),t._v(" "),s("td",[t._v("检测文件或目录是否存在")])]),t._v(" "),s("tr",[s("td",[t._v("os.listdir(path='.')")]),t._v(" "),s("td",[t._v("path.iterdir()")]),t._v(" "),s("td",[t._v("列出path的所有子文件和子目录")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.isdir(path)")]),t._v(" "),s("td",[t._v("path.is_dir()")]),t._v(" "),s("td",[t._v("检测path是否为目录")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.isfile(path)")]),t._v(" "),s("td",[t._v("path.is_file()")]),t._v(" "),s("td",[t._v("检测path是否为文件")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.join(path, *paths)")]),t._v(" "),s("td",[t._v("path.joinpath(*other)")]),t._v(" "),s("td",[t._v("拼接路径")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.basename(path)")]),t._v(" "),s("td",[t._v("path.name")]),t._v(" "),s("td",[t._v("返回path的基本名称。这是将path传入函数split()之后，返回的一对值中的第二个元素")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.dirname(path)")]),t._v(" "),s("td",[t._v("path.parent")]),t._v(" "),s("td",[t._v("返回path的目录名称。这是将path传入函数split()之后，返回的一对值中的第一个元素")])]),t._v(" "),s("tr",[s("td",[t._v("os.path.splitext(path)")]),t._v(" "),s("td",[t._v("path.suffix")]),t._v(" "),s("td",[t._v("将path拆分为(root, ext)对使得root + ext == path，并且ext为空或以句点打头并最多只包含一个句点。path.suffix == ext")])])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("os.path.split(path)")]),t._v(" "),s("p",[t._v("将path拆分为一对，即(head,tail)，其中，tail是路径的最后一部分，而head里是除最后部分外的所有内容。tail部分不会包含斜杠，如果path以斜杠结尾，则tail将为空。如果path中没有斜杠，head将为空。如果path为空，则head和tail均为空。head末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，join(head,tail)指向的位置都与path相同（但字符串可能不同）。另head==dirname()和tail==basename()。")])]),t._v(" "),s("h2",{attrs:{id:"shutil"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#shutil"}},[t._v("#")]),t._v(" shutil")]),t._v(" "),s("h3",{attrs:{id:"高阶文件操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高阶文件操作"}},[t._v("#")]),t._v(" 高阶文件操作")]),t._v(" "),s("ul",[s("li",[t._v("shutil.copyfile(src, dst): 复制文件src到文件dst。")]),t._v(" "),s("li",[t._v("shutil.copy(src, dst) & shutil.copy2(src, dst: 文件src拷贝到文件或目录dst。")]),t._v(" "),s("li",[t._v("shutil.copytree(src, dst, ignore=None, copy_function=copy2, dirs_exist_ok=False): 将以src为根起点的整个目录树拷贝到名为dst的目录并返回目标目录。dirs_exist_ok指明是否要在dst或任何丢失的父目录已存在的情况下引发异常。")]),t._v(" "),s("li",[t._v("shutil.rmtree(path): 删除一个完整的目录树；path 必须指向一个目录。")]),t._v(" "),s("li",[t._v("shutil.move(src, dst, copy_function=copy2): 递归地将一个文件或目录 (src) 移至另一位置 (dst) 并返回目标位置。")])]),t._v(" "),s("h3",{attrs:{id:"压缩操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#压缩操作"}},[t._v("#")]),t._v(" 压缩操作")]),t._v(" "),s("ul",[s("li",[t._v("shutil.make_archive(base_name, format[, root_dir[, base_dir]])\n"),s("ul",[s("li",[t._v("base_name: 要创建的文件名称，包括路径，去除任何特定格式的扩展名。")]),t._v(" "),s("li",[t._v("format: 归档格式。\n"),s("ul",[s("li",[t._v('"zip" (如果 zlib 模块可用)')]),t._v(" "),s("li",[t._v('"tar", "gztar" (如果 zlib 模块可用)')]),t._v(" "),s("li",[t._v('"bztar" (如果 bz2 模块可用)')]),t._v(" "),s("li",[t._v('"xztar" (如果 lzma 模块可用)')])])]),t._v(" "),s("li",[t._v("root_dir: 归档文件的根目录，归档中的所有路径都将是它的相对路径。相当于先os.chdir(root_dir)。")]),t._v(" "),s("li",[t._v("base_dir: 要执行归档的起始目录。也就是说base_dir将成为归档中所有文件和目录共有的路径前缀。base_dir必须相对于root_dir给出。")]),t._v(" "),s("li",[t._v("root_dir 和 base_dir 默认均为当前目录。")]),t._v(" "),s("li",[t._v("这个函数不是线程安全的")])])]),t._v(" "),s("li",[t._v("shutil.unpack_archive(filename[, extract_dir[, format]])\n"),s("ul",[s("li",[t._v("解包一个归档文件。filename是归档文件的完整路径。")]),t._v(" "),s("li",[t._v("extract_dir是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。")])])]),t._v(" "),s("li",[t._v("shutil.get_archive_formats(): 返回支持的归档格式列表。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);